     1	#include "ProtoSocket.h"
     2	
     3	#include <cstdio>
     4	
     5	int main()
     6	{
     7	    printf("Protocol process starting...\n");
     8	
     9	    CProtoSocket* protoSocket = CProtoSocket::instance();
    10	    protoSocket->run();
    11	
    12	    printf("Protocol process exiting...\n");
    13	
    14	    return 0;
    15	}
    16	
    17	
    18	#ifndef ICMP_H_
    19	#define ICMP_H_
    20	
    21	typedef struct sniff_icmp {
    22	    uint8_t icmp_type;          // type of message
    23	    uint8_t icmp_code;          // type sub code
    24	    uint16_t icmp_sum;          // one complement check sum of struct 
    25	    union {
    26	        uint8_t ih_pptr;        // parameter problem pointer
    27	        struct in_addr ih_gwaddr;   // Gateway Internet Address
    28	        struct ih_idseque {
    29	            uint16_t icd_id;    // identifier
    30	            uint16_t icd_seq;   // sequence number
    31	        } ih_idseque ;
    32	        uint32_t ih_void;
    33	    } icmp_hun ;
    34	#define icmp_pptr_t           icmp_hun.ih_pptr
    35	#define icmp_gwaddr_t         icmp_hun.ih_gwaddr
    36	#define icmp_id_t             icmp_hun.ih_idseque.icd_id
    37	#define icmp_seq_t            icmp_hun.ih_idseque.icd_seq
    38	#define icmp_void_t           icmp_hun.ih_void
    39	    union {
    40	        struct id_ts {
    41	            uint32_t its_otime; // Originate timestamp
    42	            uint32_t its_rtime; // Receive timestamp
    43	            uint32_t its_ttime; // Transmit timestamp
    44	        } id_ts;
    45	        struct id_ip {          
    46	            struct sniff_ip idi_ip;
    47	            /*options and then 64bits of data*/
    48	        } id_ip;
    49	        uint32_t id_mask;
    50	        uint8_t id_data[1];
    51	    } icmp_dun ;
    52	#define icmp_otime_t          icmp_dun.id_ts.its_otime
    53	#define icmp_rtime_t          icmp_dun.id_ts.its_rtime
    54	#define icmp_ttime_t          icmp_dun.id_ts.its_ttime
    55	#define icmp_ip_t             icmp_dun.id_ip.idi_ip
    56	#define icmp_mask_t           icmp_dun.id_mask
    57	#define icmp_data_t           icmp_dun.id_data
    58	} icmphdr_t ;
    59	
    60	#endif  // ICMP_H_
    61	
    62	#pragma once 
    63	
    64	#include "SharedBlock.h"
    65	#include "InetSocket.h"
    66	#include "packet.h"
    67	
    68	#include <map>
    69	#include <set>
    70	#include <string>
    71	
    72	typedef std::map<std::string, InetConnSock*> ConnPMap; // connections, <localAddr.localPort-peerAddr.peerPort, InetConnSock*>
    73	                                                    // actually, value is a pointer to TCP member _connPool's element
    74	
    75	class CProtoSocket
    76	{
    77	    public:
    78	        static CProtoSocket* instance()
    79	        {
    80	            static CProtoSocket inst;
    81	            return &inst;
    82	        }
    83	        ~CProtoSocket();
    84	
    85	        void run();
    86	
    87	        /*
    88	         * Received packet from protocol
    89	         * */
    90	        void received(const packet_t *pkt);
    91	
    92	        /*
    93	         * Called by TCP when a new connection @ics is arrived
    94	         *
    95	         * @name Connection name
    96	         * @ics The connection 
    97	         *
    98	         * To be honest, this method can be avoided
    99	         * */
   100	        void connectFinished(std::string name, InetConnSock *ics);
   101	
   102	        uint32_t selectFD();
   103	
   104	        /*
   105	         * Accepted an established connection from TCP
   106	         *
   107	         * @name Connection name
   108	         * @ics The connection 
   109	         * */
   110	        void accepted(std::string name, InetConnSock *ics);
   111	
   112	        void bytesAvailable(InetConnSock *ics);
   113	
   114	        void closed(std::string name);
   115	         
   116	    private:
   117	        // 
   118	        CProtoSocket();
   119	        CProtoSocket(const CProtoSocket&);
   120	        CProtoSocket & operator=(const CProtoSocket&);
   121	
   122	        /*
   123	         * Create and detach shared memory
   124	         * */
   125	        void createSharedMem();
   126	        void destroySharedMem();
   127	
   128	        void handleSockRequest();
   129	
   130	        void handleCreate(SockPacket *sockPkt);
   131	        void handleBind(SockPacket *sockPkt);
   132	        void handleSendTo(SockPacket *sockPkt);
   133	        void handleRecvFrom(SockPacket *sockPkt);
   134	        void handleSend(SockPacket *sockPkt);
   135	        void handleRecv(SockPacket *sockPkt);
   136	        void handleClose(SockPacket *sockPkt);
   137	        void handleListen(SockPacket *sockPkt);
   138	        void handleConnect(SockPacket *sockPkt);
   139	        void handleAccept(SockPacket *sockPkt);
   140	
   141	        /*
   142	         * Random select an unused port
   143	         * */
   144	        uint16_t selectPort();
   145	
   146	        void setLocalAddr(InetSock * sk);
   147	
   148	        /*
   149	         * Notify socket a given signal
   150	         *
   151	         * @success An int value when 1 for success, 0 for failed
   152	         * @pid The process id
   153	         * @signo The signal number
   154	         * @funcName The calling function name
   155	         * */
   156	        void afterHandle(int success, int pid, int signo, const char * const funcName);
   157	        void afterHandle(int pid, int signo, const char * const funcName);
   158	
   159	        std::set<uint16_t> _pendingAccept;
   160	        ConnPMap _connPPool; // connection pointers map
   161	        std::map<int, InetSock> _sockPool;        // created sockets, <sockfd, InetSock>
   162	        std::set<InetSock *> _pendingSocks;       // pending recvfrom sockets
   163	
   164	        int _shmid;          // shared memory identifier
   165	        SharedBlock *_pBlock;// shared block
   166	};
   167	
   168	#pragma once
   169	
   170	#include "tcp.h"
   171	#include "ProtoSocket.h"
   172	#include "InetSocket.h"
   173	#include "Network.h"
   174	#include "BaseIO.h"
   175	#include <map>
   176	#include <string>
   177	
   178	typedef std::map<std::string, InetConnSock> ConnMap; // connections, <localAddr.localPort-peerAddr.peerPort, InetConnSock>
   179	typedef std::map<uint16_t, InetSock*> InetSockMap;  // listen sockets, <port, InetSock*>
   180	                                                    // actually, value is a pointer to CProtoSocket member _sockPool's
   181	                                                    // element
   182	
   183	class CNetwork;
   184	class CProtoSocket;
   185	
   186	class CTCP : public CBaseIO
   187	{
   188	    public:
   189	        static CTCP * instance()
   190	        {
   191	            static CTCP inst;
   192	            return &inst;
   193	        }
   194	
   195	        ~CTCP();
   196	
   197	        void init();
   198	        int send(packet_t *pkt);
   199	        int received(packet_t *pkt);
   200	
   201	        void connect(InetSock *sk);
   202	        void listen(InetSock *sk);
   203	
   204	        /*
   205	         * Close a connection
   206	         *
   207	         * @name The connection name, can be contructed by keyOf()
   208	         * */
   209	        void close(std::string name);
   210	
   211	        /*
   212	         * Return the key(or name) of a connection.
   213	         * */
   214	        static std::string keyOf(InetConnSock *ics);
   215	        static std::string keyOf(struct in_addr localAddr, uint16_t localPort, struct in_addr peerAddr, uint16_t peerPort);
   216	
   217	    private:
   218	        CTCP(const CTCP&);
   219	        CTCP & operator=(const CTCP&);
   220	
   221	        CTCP() { }
   222	
   223	        InetConnSock * newConnection(InetConnSock *ics);
   224	        void doSend(InetConnSock *ics);
   225	        void __doSend(packet_t *packet, InetConnSock *ics, uint8_t flags, uint8_t *buf, uint32_t size);
   226	
   227	        /*
   228	         * Send a tcp segment without payload
   229	         *
   230	         * @packet The allocated packet
   231	         * @ics The connection
   232	         * @flags The tcp header flags
   233	         * */
   234	        void sendNoData(packet_t *packet, InetConnSock *ics, uint8_t flags);
   235	
   236	        void recvEstablished(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr);
   237	        void recvStateProcess(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr);
   238	        void recvListen(InetSock *ics, packet_t *packet, tcphdr_t *tcphdr);
   239	
   240	        InetSockMap _listenPool;
   241	        ConnMap _connPool; 
   242	        CProtoSocket *_protoSock;
   243	        CNetwork *_network;
   244	};
   245	
   246	#pragma once
   247	
   248	#include <arpa/inet.h>
   249	#include <netinet/ip.h>
   250	#include <memory>
   251	#include "SharedBlock.h"
   252	
   253	class CSocket
   254	{
   255	    public:
   256	        CSocket();
   257	        ~CSocket();
   258	
   259	        int socket(int family, int type, int protocol);
   260	        
   261	        /*
   262	         * Bind socket with address @sockaddr
   263	         * */
   264	        int bind(const struct sockaddr *sockaddr, socklen_t addrlen);
   265	
   266	        /*
   267	         * Connect to address @sockaddr
   268	         * */ 
   269	        int connect(const struct sockaddr *sockaddr, socklen_t addrlen);
   270	
   271	        /*
   272	         * Send to connected peer address
   273	         *
   274	         * @buf The data to send
   275	         * @len The data length in bytes to send
   276	         * */
   277	        int send(const char * buf, size_t len, int flags);
   278	
   279	        /*
   280	         * Receive data from connected peer address, default timeout is 3 seconds.
   281	         *
   282	         * @buf The buffer used to stored received data 
   283	         * @len Maximum bytes to receive
   284	         * */
   285	        int recv(char * buf, size_t len, int flags);
   286	
   287	        /*
   288	         * @return The number of bytes sent.  On error, -1 is returned
   289	         * */
   290	        int sendto(const char* buf, size_t len, int flags,
   291	                const struct sockaddr* dstAddr, socklen_t addrlen);
   292	
   293	        /*
   294	         * @return The  number  of bytes received, or -1 if an error occurred.
   295	         * */
   296	        int recvfrom(char* buf, size_t len, int flags,
   297	                struct sockaddr* srcAddr, socklen_t* addrlen);
   298	
   299	        /*
   300	         * Set this socket to listen mode
   301	         *
   302	         * @backlog The maximum client might in queue 
   303	         * @return On success, zero is returned.  On error, -1 is returned
   304	         * */
   305	        int listen(int backlog);
   306	
   307	        std::unique_ptr<CSocket> accept(struct sockaddr * sockaddr, socklen_t * addrlen);
   308	
   309	        int shutdown();
   310	
   311	        int close();
   312	
   313	        /*
   314	         * Return file descriptor of this socket
   315	         * */
   316	        int getFD()
   317	        {
   318	            return _sock.sockfd;
   319	        }
   320	        // 
   321	    private:
   322	        // 
   323	        CSocket(const CSocket&);            // prevent copy
   324	        CSocket & operator= (const CSocket&);// prevent assign
   325	
   326	        /*
   327	         * Do socket create
   328	         * */
   329	        int init(int family, int type, int protocol);
   330	
   331	        /*
   332	         * Attach and detach shared memory
   333	         * */
   334	        void attachSharedMem();
   335	        void detachSharedMem();
   336	
   337	        /*
   338	         * Wait protocols stack reply
   339	         *
   340	         * @return Theorically, on success, 1 is returned, otherwise return 0 !!!
   341	         * */
   342	        int waitForSuccess(int signo);
   343	
   344	        SockDataHdr makeDataHeader(size_t len, int flag);
   345	
   346	        int _shmid;          // shared memory identifier
   347	        SharedBlock *_pBlock;// shared block
   348	        int _protoPid;          // protocol process id
   349	
   350	        Sock _sock;
   351	        //int _socketId;          // might use process id
   352	        //int _family;
   353	        //int _type;
   354	        //int _protocol;
   355	};
   356	
   357	#ifndef TCP_H_
   358	#define TCP_H_
   359	
   360	#include <sys/types.h>
   361	
   362	#define SIZE_TCP 20
   363	
   364	/*
   365	 * TCP Maximum Segment Size (MTU - SIZE_TCP - SIZE_IP)
   366	 * */
   367	const int cTCPMSS = 1456;
   368	
   369	/* TCP header */
   370	typedef u_int tcp_seq;
   371	
   372	typedef struct sniff_tcp {
   373	        u_short th_sport;               /* source port */
   374	        u_short th_dport;               /* destination port */
   375	        tcp_seq th_seq;                 /* sequence number */
   376	        tcp_seq th_ack;                 /* acknowledgement number */
   377	        u_char  th_offx2;               /* data offset, rsvd */
   378	#define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
   379	        u_char  th_flags;
   380	        #define TH_FIN  0x01
   381	        #define TH_SYN  0x02
   382	        #define TH_RST  0x04
   383	        #define TH_PUSH 0x08
   384	        #define TH_ACK  0x10
   385	        #define TH_URG  0x20
   386	        #define TH_ECE  0x40
   387	        #define TH_CWR  0x80
   388	        #define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
   389	        u_short th_win;                 /* window */
   390	        u_short th_sum;                 /* checksum */
   391	        u_short th_urp;                 /* urgent pointer */
   392	} tcphdr_t ;
   393	
   394	/*
   395	 * TCP control buffer
   396	 * */
   397	typedef struct tagTCPCB {
   398	    // ...
   399	    u_int seq;          // start sequence of buffer 
   400	    u_int endSeq;       // end sequence of buffer
   401	    u_int ack;          // acked number
   402	} TCPCB;
   403	
   404	#define TCP_PKT_CB(__packet) ((TCPCB *)&(__packet)->cb[0])
   405	
   406	#endif  // TCP_H_
   407	
   408	
   409	#ifndef ETHER_H_
   410	#define ETHER_H_
   411	
   412	#include <netinet/ether.h>
   413	
   414	/* ethernet headers are always exactly 14 bytes [1] */
   415	#define SIZE_ETHERNET 14
   416	
   417	#define SIZE_ETHER_SUM 4
   418	
   419	/* Ethernet addresses are 6 bytes */
   420	#ifndef ETHER_ADDR_LEN
   421	#define ETHER_ADDR_LEN	6
   422	#endif
   423	
   424	/*MAC address in ASCII format length*/
   425	#define MAC_ASCII_LEN 18
   426	
   427	/*
   428	 * Ethernet Type Defines, see /usr/include/net/ethernet.h
   429	 * */
   430	
   431	/*#define ETHER_T_IPv4    0x0800      // Internet Protocol Version 4*/
   432	/*#define ETHER_T_IPv6    0x86DD      // Internet Protocol Version 6*/
   433	/*#define ETHER_T_ARP     0x0806      // Address Resolution Protocol */
   434	/*#define ETHER_T_RARP    0x8035      // Reverse Address Resolution Protocol */
   435	/*#define ETHER_T_ETHERTALK   0x809B  // AppleTalk over Ethernet*/
   436	/*#define ETHER_T_PPP     0x880B      // Point-to-Point Protocol*/
   437	/*#define ETHER_T_PPPoEDS     0x8863  // PPPoE Discovery Stage*/
   438	/*#define ETHER_T_PPPoESS     0x8864  // PPPoE Session Stage*/
   439	/*#define ETHER_T_SNMP    0x814C      // Simple Network Management Protocol*/
   440	
   441	/* Ethernet header */
   442	typedef struct sniff_ethernet {
   443	        u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
   444	        u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
   445	        u_short ether_type;                     /* IP? ARP? RARP? etc */
   446	} ethernethdr_t ;
   447	
   448	#endif  // ETHER_H_
   449	
   450	#pragma once
   451	
   452	#include "udp.h"
   453	#include "BaseIO.h"
   454	
   455	class CUDP : public CBaseIO
   456	{
   457	public:
   458	    static CUDP * instance()
   459	    {
   460	        static CUDP inst;
   461	        return &inst;
   462	    }
   463	    //
   464	    void init();
   465	
   466	    /*
   467	     * Send pkt out.
   468	     *
   469	     * @pkt The packet to send
   470	     * */
   471	    int send(packet_t *pkt);
   472	
   473	    /*
   474	     * Receive a packet pkt.
   475	     *
   476	     * @pkt The packet received
   477	     * */
   478	    int received(packet_t *pkt);
   479	private:
   480	    CUDP()
   481	    {
   482	    }
   483	
   484	    CUDP(const CUDP&);
   485	    CUDP & operator= (const CUDP&);
   486	};
   487	#ifndef IP_H_
   488	#define IP_H_
   489	
   490	#include <netinet/in.h>
   491	#include <netinet/ip.h>
   492	
   493	/* to remove option, just set to 0 */
   494	#define SIZE_OPTION 4
   495	#define SIZE_IP (SIZE_OPTION+20)
   496	#define SIZE_IP_HL (SIZE_IP/4)
   497	
   498	const int cIPOptionValue = 0xFF020000; 
   499	
   500	/* IP header */
   501	struct sniff_ip {
   502	        u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
   503	        u_char  ip_tos;                 /* type of service */
   504	        u_short ip_len;                 /* total length */
   505	        u_short ip_id;                  /* identification */
   506	        u_short ip_off;                 /* fragment offset field */
   507	        #define IP_RF 0x8000            /* reserved fragment flag */
   508	        #define IP_DF 0x4000            /* dont fragment flag */
   509	        #define IP_MF 0x2000            /* more fragments flag */
   510	        #define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
   511	        u_char  ip_ttl;                 /* time to live */
   512	        u_char  ip_p;                   /* protocol */
   513	        u_short ip_sum;                 /* checksum */
   514	        struct  in_addr ip_src,
   515	                        ip_dst;         /* source and dest address */ 
   516	        u_int   ip_opt;                 /* option value */
   517	
   518	        bool isFragment() {
   519	            return (ip_off & htons(IP_MF | IP_OFFMASK)) != 0;
   520	        }
   521	
   522	};
   523	
   524	typedef struct sniff_ip iphdr_t;
   525	
   526	#define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
   527	#define IP_V(ip)                (((ip)->ip_vhl) >> 4)
   528	
   529	#endif  // IP_H_
   530	
   531	#pragma once
   532	//#ifndef NEIGHBOR_H_
   533	//#define NEIGHBOR_H_
   534	
   535	#include "Link.h"
   536	#include "arp.h"
   537	#include "packet.h"
   538	
   539	class CARP;
   540	class CLink;
   541	
   542	/*
   543	 * CNeighbor - neighbor subsystem 
   544	 * */
   545	class CNeighbor
   546	{
   547	public:
   548	    // 
   549	    static CNeighbor * instance()
   550	    {
   551	        static CNeighbor inst;
   552	        return &inst;
   553	    }
   554	
   555	    void init();
   556	
   557	    void send(packet_t *packet);
   558	
   559	    void received(packet_t *packet);
   560	
   561	private:
   562	    bool _isInited;
   563	
   564	    CLink *_link;
   565	    CARP *_arp;
   566	
   567	    CNeighbor() : _isInited(false), _arp(nullptr)
   568	    {
   569	    }
   570	
   571	    CNeighbor(const CNeighbor &);
   572	    CNeighbor & operator= (const CNeighbor &);
   573	
   574	};
   575	
   576	//#endif // NEIGHBOR_H_
   577	#pragma once
   578	
   579	#include <arpa/inet.h>
   580	
   581	const char * const cKeyPath = "/home/bdg/.netsimul";   // this file must exist
   582	const int cKeyID = 17;
   583	
   584	const unsigned int cSHMSize = 8192;
   585	const unsigned int cSHMBufSize = 4096;
   586	const unsigned int cSHMDataSize = 4092;
   587	
   588	/*
   589	 * struct sharedblock - a data structure between ProtocolSocket and AppSocket 
   590	 *
   591	 * @buf1 - ProtocolSocket buffer
   592	 * @buf2 - AppSocket buffer
   593	 * */
   594	typedef struct sharedblock {
   595	    char buf1[cSHMBufSize];         // address is &sharedblock
   596	    char buf2[cSHMBufSize];         // address is buf1 + 4096
   597	} SharedBlock;
   598	
   599	typedef enum sockpktype {
   600	    SOCK_CREATE = 1,
   601	    SOCK_BIND,
   602	    SOCK_LISTEN,
   603	    SOCK_CONNECT,
   604	    SOCK_ACCEPT,
   605	    SOCK_SEND,
   606	    SOCK_SENDTO,
   607	    SOCK_RECV,
   608	    SOCK_RECVFROM,
   609	    SOCK_CLOSE,
   610	} SockPktType;
   611	
   612	typedef enum socketstate {
   613	    SS_FREE = 0,
   614	    SS_UNCONNECTED,
   615	    SS_CONNECTED,
   616	    SS_CONNECTING,
   617	    SS_DISCONNECTING
   618	} SocketState;
   619	
   620	/*
   621	 * struct sockpacket - this data structure will save to buf1 or buf2 after conversion
   622	 * */
   623	typedef struct sockpacket {
   624	    SockPktType type;                  // this field must be the first member
   625	    char data[cSHMBufSize - 4];
   626	} SockPacket;
   627	
   628	/////////////// start of sockpacket.data structures ///////////////
   629	
   630	typedef struct tagSock {
   631	    int sockfd;         // socket file descriptor
   632	    int pid;            // process id
   633	    int family;
   634	    int type;
   635	    int protocol;
   636	    struct in_addr addr;// socket bind address
   637	    uint16_t port;      // socket bind port
   638	    struct in_addr peerAddr;// peer socket address
   639	    uint16_t peerPort;      // peer socket port
   640	    SocketState state;  // connection state
   641	
   642	    tagSock() 
   643	    {
   644	        sockfd = pid = family = type = protocol = 0;
   645	        port = peerPort = 0;
   646	        addr.s_addr = peerAddr.s_addr = 0;
   647	        state = SS_UNCONNECTED;
   648	    }
   649	
   650	} Sock;
   651	
   652	typedef struct tagSockDataHdr {
   653	    int sockfd;
   654	    struct sockaddr_in srcAddr;            // source address
   655	    struct sockaddr_in dstAddr;            // destination address
   656	    int flag;           // flag 
   657	    int len;            // data length
   658	} SockDataHdr;
   659	
   660	/////////////// end of sockpacket.data structures   ///////////////
   661	
   662	#pragma once
   663	//#ifndef PACKET_H_
   664	//#define PACKET_H_
   665	
   666	#include <arpa/inet.h>
   667	#include <netinet/ether.h>
   668	#include <cstring>
   669	#include <cstdio>           // use printf to see how many copy used
   670	
   671	#include "ip_arp.h"
   672	
   673	struct packet_cb {
   674	    // ... 
   675	    uint16_t offset;
   676	};
   677	
   678	typedef packet_cb packet_cb_t;
   679	typedef packet_cb PacketCB;
   680	
   681	/*
   682	 * Core structure used for networking, referece to Linux struct sk_buff design.
   683	 * */
   684	struct inject_packet {
   685	    u_char                  *buf;   // packet data send buffer
   686	    size_t                  size;   // size of data bufer
   687	    struct in_addr          saddr,  // source ip address
   688	                            daddr;  // destination ip address
   689	    struct ether_addr       sha,    // source hardware address
   690	                            dha;    // destination hardware address
   691	    uint16_t                sport,  // source port
   692	                            dport;  // destination port
   693	    u_char                  oper;   // operation code
   694	    unsigned char           proto;  // protocol
   695	#define INJECT_OP_TCP(p) (p->oper == 't' || p->oper == 'T')
   696	#define INJECT_OP_UDP(p) (p->oper == 'u' || p->oper == 'U')
   697	    uint16_t                ept;    // ethernet packet type
   698	    //ARPHdr                  arphdr; // arp header 
   699	    //const u_char            *rcvbuf;// packet data receive buffer
   700	
   701	    char                    cb[48]; // control buffer for every process handler
   702	    bool                    allocated;// True if this struct allocated by heap memory
   703	    unsigned int            len;    // Length of the actual data
   704	
   705	    unsigned char           *tail;  // Data tail
   706	    unsigned char           *end;   // Buffer end
   707	    unsigned char           *head,  // Buffer head
   708	                            *data;  // Data pointer
   709	
   710	    inject_packet() : size(0), len(0), allocated(false)
   711	    {
   712	        buf = head = tail = data = tail = nullptr;
   713	        //rcvbuf = nullptr;
   714	    }
   715	
   716	    inject_packet(unsigned int size) : size(size), len(0), allocated(true)
   717	    {
   718	        buf = new unsigned char[size]{0};
   719	
   720	        head = data = tail = buf;
   721	        end = buf + size;
   722	    }
   723	
   724	    /*
   725	     * Copy constructor.
   726	     *
   727	     * So, remember to use reference& in any where you can.
   728	     * */
   729	    inject_packet (const inject_packet &cp)
   730	    {
   731	
   732	        buf = new unsigned char[cp.size]{0};
   733	
   734	        head = data = tail = buf;
   735	        end = buf + cp.size;
   736	
   737	        data = head + (cp.data - cp.head);
   738	        tail = head + (cp.tail - cp.head);
   739	
   740	        len     = cp.len;
   741	        size    = cp.size;
   742	        saddr   = cp.saddr;
   743	        daddr   = cp.daddr;
   744	        sha     = cp.sha;
   745	        dha     = cp.dha;
   746	        sport   = cp.sport;
   747	        dport   = cp.dport;
   748	        oper    = cp.oper;
   749	        proto   = cp.proto;
   750	        ept     = cp.ept;
   751	        //arphdr  = cp.arphdr;
   752	
   753	        allocated = true;
   754	
   755	        memmove(buf, cp.buf, cp.size);
   756	
   757	        printf("**Copied packet**\n");
   758	
   759	    }
   760	
   761	    void copyMetadata(const inject_packet &cp)
   762	    {
   763	        saddr   = cp.saddr;
   764	        daddr   = cp.daddr;
   765	        sha     = cp.sha;
   766	        dha     = cp.dha;
   767	        sport   = cp.sport;
   768	        dport   = cp.dport;
   769	        oper    = cp.oper;
   770	        proto   = cp.proto;
   771	        ept     = cp.ept;
   772	
   773	    }
   774	
   775	    ~inject_packet()
   776	    {
   777	        if (allocated && buf != nullptr) {
   778	            delete [] buf;
   779	            buf = nullptr;
   780	            head = data = tail = end = buf;
   781	            size = len = 0;
   782	        }
   783	
   784	    }
   785	
   786	    /*
   787	     * Reserve space of headroom.
   788	     *
   789	     * Increase the headroom of an empty &sk_buff by reducing the tail
   790	     * room. This is only allowed for an empty buffer.
   791	     * */
   792	    void reserve(unsigned int length)
   793	    {
   794	        data += length;
   795	        tail += length;
   796	    }
   797	
   798	    /*
   799	     * Add data length to a buffer.
   800	     *
   801	     * Extends the used data area of the buffer.
   802	     * */
   803	    void put(unsigned int length)
   804	    {
   805	        tail += length;
   806	        len += length;
   807	    }
   808	
   809	    /*
   810	     * Add data to the start of a buffer.
   811	     *
   812	     * Extends the used data area of the buffer at the buffer start.
   813	     * */
   814	    void push(unsigned int length)
   815	    {
   816	        data -= length;
   817	        len += length;
   818	    }
   819	
   820	    /*
   821	     * Remove data from the start of a buffer.
   822	     *
   823	     * */
   824	    void pull(unsigned int length)
   825	    {
   826	        data += length;
   827	        len -= length;
   828	    }
   829	
   830	    /*
   831	     * Trim data from the end of this buffer, Fri 23 Mar 2018 19:28:04 
   832	     * */
   833	    void trim(unsigned int length)
   834	    {
   835	        tail -= length;
   836	        len -= length;
   837	    }
   838	
   839	    /*
   840	     * Reset data pointer to head, and recalculate length.
   841	     * */
   842	    void resetData()
   843	    {
   844	        data = head;
   845	        len  = tail - data;
   846	    }
   847	
   848	    /*
   849	     * @return The packet control buffer pointer
   850	     * */
   851	    packet_cb_t * getPacketCB() const 
   852	    {
   853	        return (packet_cb_t *)cb;
   854	    }
   855	
   856	    bool isFull() const
   857	    {
   858	        return len == size;
   859	    }
   860	
   861	    bool empty() const 
   862	    {
   863	        return len == 0;
   864	    }
   865	
   866	};
   867	
   868	typedef struct inject_packet packet_t;
   869	typedef struct inject_packet Packet;
   870	
   871	//#endif // PACKET_H_
   872	#pragma once
   873	
   874	#include "SharedBlock.h"
   875	#include "packet.h"
   876	#include <string>
   877	#include <list>
   878	#include <memory>
   879	
   880	/*
   881	 * enum use capital, remember this rule
   882	 * */
   883	typedef enum inetsockstate {
   884	    CLOSED = 0,
   885	    SYN_SENT,
   886	    ESTABLISHED,
   887	    FIN_WAIT_1,
   888	    FIN_WAIT_2,
   889	    TIME_WAIT,
   890	    LISTEN,
   891	    SYN_RCVD,
   892	    CLOSE_WAIT,
   893	    LAST_ACK,
   894	} InetSockState;
   895	
   896	/*
   897	 * struct InetSock - Internet socket
   898	 * */
   899	typedef struct tagInetSock
   900	{
   901	    Sock _sock;
   902	#define sk_sockfd _sock.sockfd
   903	#define sk_pid _sock.pid
   904	#define sk_family _sock.family
   905	#define sk_type _sock.type
   906	#define sk_protocol _sock.protocol
   907	#define sk_addr _sock.addr
   908	#define sk_port _sock.port
   909	#define sk_peerAddr _sock.peerAddr
   910	#define sk_peerPort _sock.peerPort
   911	    InetSockState sk_state;
   912	    int backlog;
   913	} InetSock;
   914	
   915	typedef std::list<std::shared_ptr<packet_t>> PacketQueue;
   916	
   917	typedef struct tagICSWindow 
   918	{
   919	    uint16_t size;          // window size
   920	    uint32_t lastSeq;
   921	    uint32_t lastAck;
   922	    uint32_t nextSeq;
   923	    uint32_t nextAck;
   924	    uint32_t lower;         // window lower bound
   925	    uint32_t upper;         // window upper bound
   926	} ICSWindow;
   927	
   928	/*
   929	 * struct InetConnSock - Internet connection based socket
   930	 * */
   931	typedef struct tagInetConnSock
   932	{
   933	    InetSock _inetSock;
   934	#define ics_sockfd _inetSock.sk_sockfd
   935	#define ics_pid _inetSock.sk_pid
   936	#define ics_family _inetSock.sk_family
   937	#define ics_type _inetSock.sk_type
   938	#define ics_protocol _inetSock.sk_protocol
   939	#define ics_addr _inetSock.sk_addr
   940	#define ics_port _inetSock.sk_port
   941	#define ics_peerAddr _inetSock.sk_peerAddr
   942	#define ics_peerPort _inetSock.sk_peerPort
   943	#define ics_state _inetSock.sk_state
   944	    ICSWindow sendWin,
   945	              recvWin;
   946	    PacketQueue sendQueue,
   947	                recvQueue;
   948	
   949	    tagInetConnSock() 
   950	    {
   951	        memset(&sendWin, 0 , sizeof(ICSWindow));
   952	        memset(&recvWin, 0 , sizeof(ICSWindow));
   953	    }
   954	
   955	} InetConnSock;
   956	
   957	
   958	#ifndef NETSIMUL_H_
   959	#define NETSIMUL_H_
   960	
   961	char __ch;
   962	#define CLEAR() \
   963	    while((__ch = getchar()) != '\n' && __ch != EOF)
   964	
   965	/* default snap length (maximum bytes per packet to capture) */
   966	#define SNAP_LEN 1518
   967	
   968	#define SIZE_TOK_BUF 256
   969	
   970	typedef struct tok {
   971	    int v;              // value
   972	    const char * s;     // string
   973	} tok_t ;
   974	
   975	#endif  // NETSIMUL_H_
   976	
   977	#pragma once
   978	//#ifndef ARP_H_
   979	//#define ARP_H_
   980	
   981	#include "packet.h"
   982	#include "Link.h"
   983	
   984	#include <sys/types.h>
   985	#include <map>
   986	#include <list>
   987	#include <string>
   988	
   989	using std::map;
   990	using std::list;
   991	
   992	const uint16_t cARPMaxTTL = 500;
   993	
   994	/*
   995	 * ARPPacket - ARP packet 
   996	 * */
   997	typedef struct arp_packet {
   998	    ether_header etherhdr;
   999	    ARPHdr arp;
  1000	} ARPPacket;
  1001	
  1002	/*
  1003	 * struct ARPTableItem - Cache avaliable neighbors
  1004	 * */
  1005	typedef struct arp_table_item { 
  1006	    in_addr_t ip;
  1007	    struct ether_addr mac;
  1008	    u_int16_t ttl;
  1009	} ARPTableItem; 
  1010	
  1011	typedef std::map<in_addr_t, ARPTableItem> ARPTable; 
  1012	
  1013	/*
  1014	 * struct ARPQueueItem - Cache pending datagrams
  1015	 * */
  1016	typedef struct arp_queue_item { 
  1017	    packet_t *packet;
  1018	} ARPQueueItem;
  1019	
  1020	typedef std::map<in_addr_t, std::list<ARPQueueItem> > ARPQueue;
  1021	
  1022	class CLink;
  1023	
  1024	class CARP 
  1025	{
  1026	public:
  1027	    static CARP * instance() 
  1028	    {
  1029	        static CARP inst;
  1030	        return &inst;
  1031	    }
  1032	
  1033	    void init();
  1034	
  1035	    ~CARP();
  1036	
  1037	    /*
  1038	     * Send out network layer datagram 
  1039	     * */
  1040	    void sendDatagram(packet_t *packet);
  1041	
  1042	    /*
  1043	     * Send out ARP packet
  1044	     * */
  1045	    void sendARP(const struct in_addr &addr, packet_t *packet);
  1046	
  1047	    /*
  1048	     * Received ARP packet
  1049	     * */
  1050	    void recvARP(packet_t *packet);
  1051	
  1052	private:
  1053	    bool _isInited;
  1054	
  1055	    ARPTable _arpTable;          // arp table cache - Neighbors
  1056	    ARPQueue _arpQueue;          // arp queue - Pending datagrams wait for ARP resolve
  1057	
  1058	    CLink *_link;
  1059	
  1060	    /*
  1061	     * Cache packet to queue with key.  
  1062	     *
  1063	     * @return The item number has been cached with key.
  1064	     * */
  1065	    int cache(const struct in_addr &key, packet_t *packet);
  1066	
  1067	    /*
  1068	     * Cache ARP item to table.
  1069	     * */
  1070	    void cache(const ARPHdr *arphdr);
  1071	
  1072	    /*
  1073	     * Process cached datagrams when arp reply received
  1074	     *
  1075	     * @addr The address resolved
  1076	     * */
  1077	    void processPendingDatagrams(in_addr_t addr, const struct ether_addr * mac);
  1078	
  1079	    void replyARP(const ARPHdr *arphdr);
  1080	
  1081	    CARP() : _isInited(false), _link(nullptr)
  1082	    {
  1083	    }
  1084	
  1085	};
  1086	
  1087	//#endif  // ARP_H_
  1088	#pragma once
  1089	
  1090	#include "Neighbor.h"
  1091	#include "packet.h"
  1092	#include "ip.h"
  1093	#include <map>
  1094	#include <list>
  1095	#include "BaseIO.h"
  1096	
  1097	typedef struct frag_list {
  1098	    struct in_addr          saddr,      // fragment source ip address
  1099	                            daddr;      // fragment destinatin ip address
  1100	    uint8_t                 proto;      // upper protocol used
  1101	    uint16_t                id;         // ip header identifier
  1102	    uint32_t                len;        // total length of original datagram
  1103	    uint32_t                meat;       // received length
  1104	    std::list<packet_t*> fragments;     // fragment lists(Notice: the pointed block must be deleted correctly)
  1105	} IPFragList;
  1106	
  1107	class CNeighbor;
  1108	
  1109	class CNetwork : public CBaseIO
  1110	{
  1111	public:
  1112	    //
  1113	    static CNetwork * instance()
  1114	    {
  1115	        static CNetwork inst;
  1116	        return &inst;
  1117	    }
  1118	
  1119	    ~CNetwork();
  1120	
  1121	    void init();
  1122	
  1123	    /*
  1124	     * Add ip header, then transport this packet
  1125	     *
  1126	     * @pkt The packet to send out from local.
  1127	     * */
  1128	    int send(packet_t *pkt);
  1129	
  1130	    /*
  1131	     * Forward a packet.  The ip header already in the packet.
  1132	     *
  1133	     * @pkt The packet to be forwarded
  1134	     * */
  1135	    void forward(packet_t *pkt);
  1136	
  1137	    /*
  1138	     * Deliver received packet to right protocol handler.
  1139	     *
  1140	     * @pkt The packet to deliver.
  1141	     * */
  1142	    void deliver(packet_t *pkt);
  1143	
  1144	    /*
  1145	     * Received a packet from L2
  1146	     *
  1147	     * @pkt The received packet
  1148	     * */
  1149	    int received(packet_t *pkt);
  1150	
  1151	    /*
  1152	     * Do defragmentation
  1153	     *
  1154	     * @iphdr The ip header
  1155	     * @pkt The packet to defragment
  1156	     * */
  1157	    void defragment(iphdr_t *iphdr, packet_t *pkt);
  1158	
  1159	    /*
  1160	     * Calculate fragment hash code by fragment ip header
  1161	     *
  1162	     * @iphdr The ip header
  1163	     * */
  1164	    uint32_t fragmentHashCode(iphdr_t *iphdr);
  1165	
  1166	    /*
  1167	     * Do fragmentation
  1168	     *
  1169	     * @pkt The packet to fragment
  1170	     * @mtu The maximum data length of each fragment
  1171	     * */
  1172	    void fragment(packet_t *pkt, uint16_t mtu);
  1173	
  1174	private:
  1175	    /*
  1176	     * Return an id and increase it
  1177	     *
  1178	     * @return An Identifier used by ip header
  1179	     * */
  1180	    unsigned short getAndIncID(packet_t *pkt);
  1181	
  1182	    /*
  1183	     * Reassemble a datagram when all fragments available.
  1184	     *
  1185	     * @pFrags Fragment list pointer
  1186	     * */
  1187	    void reasm(IPFragList *pFrags);
  1188	
  1189	    /*
  1190	     * Clear fragment cache.
  1191	     *
  1192	     * @pFrags Target fragment list pointer
  1193	     * */
  1194	    void clear(IPFragList *pFrags);
  1195	
  1196	    CNetwork() : _neigh(nullptr)
  1197	    {
  1198	    }
  1199	
  1200	    CNetwork(const CNetwork&);
  1201	    CNetwork & operator= (const CNetwork&);
  1202	
  1203	    CNeighbor *_neigh;
  1204	    CBaseIO *_tcp;
  1205	    CBaseIO *_udp;
  1206	
  1207	    /*key: destination ip address, value: id for ip header*/
  1208	    std::map<in_addr_t, unsigned short> _idMap;
  1209	
  1210	    /*key: fragment hash code, value: list for datagram fragments*/
  1211	    std::map<uint32_t, IPFragList> _fragsMap;
  1212	
  1213	};
  1214	
  1215	#pragma once
  1216	//#ifndef HARDWARE_H_
  1217	//#define HARDWARE_H_
  1218	
  1219	#include "Device.h"
  1220	#include "packet.h"
  1221	#include "Link.h"
  1222	
  1223	#include <pcap/pcap.h>
  1224	
  1225	#include <list>
  1226	
  1227	/* default snap length (maximum bytes per packet to capture) */
  1228	#define SNAP_LEN 1518
  1229	#define PKT_BUFF_TIME 2000
  1230	
  1231	class CLink;
  1232	
  1233	class CHardware
  1234	{
  1235	public:
  1236	    // 
  1237	    static CHardware * instance()
  1238	    {
  1239	        static CHardware hardware;
  1240	        return &hardware;
  1241	    }
  1242	
  1243	    ~CHardware() 
  1244	    {
  1245	        if (_defaultDev != nullptr && _defaultDev->handler != nullptr) {
  1246	            pcap_close(_defaultDev->handler);
  1247	        }
  1248	        pcap_freealldevs(_foundDevs); 
  1249	    }
  1250	
  1251	    void init();
  1252	    void up();
  1253	    void down();
  1254	    void transmit(const u_char*, size_t size);
  1255	    void received();
  1256	
  1257	    const Device * getDefaultDevice() const 
  1258	    {
  1259	        return _defaultDev;
  1260	    }
  1261	
  1262	private:
  1263	    bool _isInited;
  1264	
  1265	    pcap_if_t *_foundDevs;          // found pcap devices
  1266	
  1267	    std::list<Device> _devs;        // avaliable device list
  1268	    Device *_defaultDev;            // default device
  1269	
  1270	    CLink *_link;
  1271	
  1272	    int detectDevices(char *errbuf);
  1273	
  1274	    static void getPacket(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes);
  1275	
  1276	    CHardware() : _isInited(false), _defaultDev(nullptr), _link(nullptr)
  1277	    {
  1278	    }
  1279	
  1280	    CHardware(const CHardware&);
  1281	    CHardware& operator= (const CHardware&);
  1282	};
  1283	
  1284	//#endif // HARDWARE_H_
  1285	#pragma once
  1286	
  1287	#include "packet.h"
  1288	
  1289	/*
  1290	 * BaseIO - Basic input and output interface
  1291	 * */
  1292	class CBaseIO
  1293	{
  1294	    public:
  1295	        CBaseIO() : _isInited(false)
  1296	        {
  1297	        }
  1298	        virtual ~CBaseIO()
  1299	        {
  1300	        }
  1301	
  1302	        virtual void init() = 0;
  1303	        virtual int send(packet_t *pkt) = 0;
  1304	        virtual int received(packet_t *pkt) = 0;
  1305	    protected:
  1306	        bool _isInited; 
  1307	};
  1308	
  1309	#pragma once
  1310	//#ifndef LINK_H_
  1311	//#define LINK_H_
  1312	
  1313	#include "Hardware.h"
  1314	#include "Neighbor.h"
  1315	#include "Network.h"
  1316	#include "packet.h"
  1317	
  1318	#include <memory>
  1319	
  1320	class CNeighbor;
  1321	class CHardware;
  1322	class CNetwork;
  1323	
  1324	/*
  1325	 * CLink - link layer interface 
  1326	 *
  1327	 * Call neighbor subsystem when send a network datagram.
  1328	 * Call hardware when transmit a packet.
  1329	 * */
  1330	class CLink
  1331	{
  1332	public:
  1333	    static CLink * instance()
  1334	    {
  1335	        static CLink inst;
  1336	        return &inst;
  1337	    }
  1338	
  1339	    ~CLink() 
  1340	    {
  1341	    }
  1342	
  1343	    void init();
  1344	    /*
  1345	     * transmit a packet
  1346	     * */
  1347	    void transmit(packet_t *);
  1348	
  1349	    /*
  1350	     * send a network datagram
  1351	     * */
  1352	    void send(packet_t *packet);
  1353	
  1354	    /*
  1355	     * Receive packet from device
  1356	     * */
  1357	    void received(const u_char *, size_t);
  1358	
  1359	    /*
  1360	     * The default device used to send and receive packet
  1361	     * */
  1362	    const Device * getDefaultDevice() const;
  1363	
  1364	private:
  1365	    bool _isInited;
  1366	    CNetwork *_network;
  1367	    CNeighbor *_neigh;
  1368	    CHardware *_hardware;
  1369	
  1370	    CLink() : _isInited(false), _hardware(nullptr), _neigh(nullptr)
  1371	    {
  1372	        // do not call init() here, will cause '__gnu_cxx::recursive_init_error'
  1373	    }
  1374	
  1375	    CLink(const CLink&);
  1376	    CLink & operator= (const CLink&);
  1377	};
  1378	
  1379	//#endif  // LINK_H_
  1380	
  1381	#ifndef UDP_H_
  1382	#define UDP_H_
  1383	
  1384	#include <netinet/ip.h>
  1385	
  1386	#define SIZE_UDP 8
  1387	
  1388	#define SIZE_PSEUDO_UDP 12
  1389	
  1390	// udp header
  1391	typedef struct sniff_udp {
  1392	    uint16_t uh_sport;          // source port
  1393	    uint16_t uh_dport;          // destination port
  1394	    uint16_t uh_len;            // udp length
  1395	    uint16_t uh_sum;            // udp checksum
  1396	} udphdr_t ;
  1397	
  1398	//pseudo udp header for calculation of check sum
  1399	typedef struct pseudo_udp {
  1400	    struct in_addr saddr;       // source address
  1401	    struct in_addr daddr;       // destination address
  1402	    uint8_t zero;               // zero
  1403	    uint8_t protocol;           // protocol
  1404	    uint16_t len;               // UDP length
  1405	} pseudo_udp_t ;
  1406	
  1407	#endif  // UDP_H_
  1408	
  1409	#pragma once
  1410	//#ifndef IP_ARP_H_
  1411	//#define IP_ARP_H_
  1412	
  1413	#include <sys/types.h>
  1414	
  1415	const u_int8_t cARPHeaderLen = 28;
  1416	
  1417	/*
  1418	 * ARP header - 
  1419	 *
  1420	 * attribute packed is needed to align one byte.
  1421	 * */
  1422	struct sniff_arp {
  1423	    u_int16_t htype;        // Hardware Type
  1424	    u_int16_t ptype;        // Protocol Type
  1425	    u_int8_t hlen;          // Hardware Address Length
  1426	    u_int8_t plen;          // Protocol Address Length
  1427	    u_int16_t oper;         // Operation Code
  1428	    u_int8_t sha[6];        // Sender hardware address
  1429	    u_int32_t spa;          // Sender IP address
  1430	    u_int8_t tha[6];        // Target hardware address
  1431	    u_int32_t tpa;          // Target IP address
  1432	} __attribute__((packed));
  1433	
  1434	typedef struct sniff_arp ARPHdr;
  1435	
  1436	//#endif  // IP_ARP_H_
  1437	#pragma once
  1438	
  1439	#include <arpa/inet.h>
  1440	
  1441	extern uint16_t cksum(const u_char *const buf, size_t size);
  1442	
  1443	#ifndef DEVICE_H_
  1444	#define DEVICE_H_
  1445	
  1446	#include <arpa/inet.h>
  1447	#include <netinet/ether.h>
  1448	
  1449	#include <pcap/pcap.h>
  1450	
  1451	#include <iostream>
  1452	#include <sstream>
  1453	
  1454	typedef struct device {
  1455	    u_int16_t           id;
  1456	    u_int16_t           type;
  1457	    u_int16_t           mtu;        // maximum transmission unit
  1458	    char                *name;
  1459	    struct in_addr      ipAddr;     // ip
  1460	    struct ether_addr   hAddr;      // mac
  1461	
  1462	    pcap_t              *handler;   // pcap packet handler
  1463	
  1464	    device ()
  1465	    {
  1466	        id = type = 0;
  1467	        name = nullptr;
  1468	        handler = nullptr;
  1469	    }
  1470	
  1471	    void show() const
  1472	    {
  1473	        std::cout << toString() << std::endl;
  1474	    }
  1475	
  1476	    std::string toString() const
  1477	    {
  1478	        std::ostringstream oss;
  1479	        oss << "Device ["
  1480	            << "id=" << id
  1481	            << ", type=" << type
  1482	            << ", mtu=" << mtu
  1483	            << ", name=" << name
  1484	            << ", ip=" << inet_ntoa(ipAddr)
  1485	            << ", mac=" << ether_ntoa(&hAddr)
  1486	            << "]";
  1487	        return oss.str();
  1488	    }
  1489	
  1490	} Device; 
  1491	
  1492	#endif  // DEVICE_H_
  1493	#ifndef UTIL_H_
  1494	#define UTIL_H_
  1495	
  1496	#include <cstdio>
  1497	
  1498	#define DBG_PREFIX 1
  1499	#define DBG_NEWLINE (1 << 1)
  1500	#define DBG_DEFAULT (DBG_PREFIX | DBG_NEWLINE)
  1501	#define DBG_NONE 0
  1502	
  1503	#define DEBUG 1
  1504	
  1505	extern void log(const char *format,  ...);
  1506	extern void debug(const char *format,  ...);
  1507	extern void debug(int flag, const char *format,  ...);
  1508	extern void error(const char *format,  ...);
  1509	
  1510	#define SIZE_TOK_BUF 256
  1511	
  1512	typedef struct tok {
  1513	    int v;              // value
  1514	    const char * s;     // string
  1515	} tok_t ;
  1516	
  1517	extern const char * tok2str(const tok_t * tokp,
  1518	        const char * default_msg,
  1519	        int v);
  1520	
  1521	class File 
  1522	{
  1523	    public:
  1524	        File(const char *filename) : file(NULL)
  1525	        {
  1526	            if ((file = fopen(filename, "w")) == NULL) {
  1527	                fprintf(stderr, "Cannot open file: %s, use standard output instead.\n", filename);
  1528	                file = stdout;
  1529	            }
  1530	            else {
  1531	                fprintf(stdout, "Open file: %s\n", filename);
  1532	            }
  1533	        }
  1534	
  1535	        ~File() 
  1536	        {
  1537	            if (file != NULL)
  1538	                fclose(file);
  1539	        }
  1540	
  1541	        FILE *get() const 
  1542	        {
  1543	            return file;
  1544	        }
  1545	
  1546	    private:
  1547	        FILE *file;
  1548	};
  1549	
  1550	#endif // UTIL_H_
  1551	#include "Neighbor.h"
  1552	
  1553	#include "Util.h"
  1554	
  1555	#define TAG "<Neighbor> "
  1556	
  1557	void CNeighbor::init()
  1558	{
  1559	    if (_isInited)
  1560	        return;
  1561	
  1562	    _arp        = CARP::instance();
  1563	    _arp->init();
  1564	
  1565	    _link       = CLink::instance();
  1566	    _link->init();
  1567	
  1568	    _isInited   = true;
  1569	    debug(DBG_DEFAULT, TAG "initied.");
  1570	}
  1571	
  1572	void CNeighbor::send(packet_t *packet)
  1573	{
  1574	    _arp->sendDatagram(packet);
  1575	}
  1576	
  1577	void CNeighbor::received(packet_t *packet)
  1578	{
  1579	    _arp->recvARP(packet);
  1580	
  1581	}
  1582	#include "Network.h"
  1583	
  1584	#include "ip.h"
  1585	#include "CheckSum.h"
  1586	#include "Util.h"
  1587	#include "TCP.h"
  1588	#include "UDP.h"
  1589	
  1590	#include <cstring>
  1591	#include <algorithm>
  1592	
  1593	#define TAG "<Network> "
  1594	
  1595	const tok_t ipproto_values[] = {
  1596	    {IPPROTO_TCP, "TCP"},
  1597	    {IPPROTO_UDP, "UDP"},
  1598	    {IPPROTO_ICMP, "ICMP"},
  1599	    {IPPROTO_IP, "IP"},
  1600	    {0, NULL}
  1601	};
  1602	
  1603	/*
  1604	 * A simple implementation of `ip_select_fb_ident()`
  1605	 * */
  1606	uint16_t CNetwork::getAndIncID(packet_t *pkt)
  1607	{
  1608	    in_addr_t daddr = pkt->daddr.s_addr;
  1609	
  1610	    uint16_t id;
  1611	    if (_idMap.count(daddr) == 1) {
  1612	        // find it
  1613	        id = _idMap.at(daddr) + 1;
  1614	    }
  1615	    else {
  1616	        // not found, create one
  1617	        srand((unsigned int)time(NULL));
  1618	        id = rand() % 0xFFFF;
  1619	    }
  1620	    _idMap[daddr] = id;         // update cache
  1621	    return id;
  1622	
  1623	}
  1624	
  1625	int CNetwork::send(packet_t *pkt)
  1626	{
  1627	    log (TAG "%s.\n", __func__);
  1628	    if (pkt->len > 0xFFFF) {
  1629	        debug(DBG_DEFAULT, "Too big packet to send.");
  1630	        return 0;
  1631	    }
  1632	
  1633	    pkt->ept     = ETH_P_IP;
  1634	
  1635	    const Device *dev = CLink::instance()->getDefaultDevice();
  1636	    uint16_t mtu = dev->mtu;
  1637	
  1638	    if (SIZE_IP + pkt->len > mtu) {
  1639	        fragment(pkt, mtu);
  1640	    }
  1641	    else {
  1642	        // prepare IP header
  1643	        iphdr_t ip;
  1644	        size_t size_new = SIZE_IP + pkt->len; 
  1645	
  1646	        ip.ip_vhl   = 0x40 | SIZE_IP_HL;
  1647	        ip.ip_tos   = 0;
  1648	        ip.ip_len   = htons(size_new);
  1649	        ip.ip_id    = htons(getAndIncID(pkt));
  1650	        ip.ip_off   = htons(IP_DF);     // don't fragment
  1651	        ip.ip_ttl   = IPDEFTTL;         // default TTL
  1652	        ip.ip_p     = pkt->proto;
  1653	        ip.ip_sum   = 0;
  1654	        ip.ip_src   = pkt->saddr;
  1655	        ip.ip_dst   = pkt->daddr;
  1656	        ip.ip_opt   = htonl(cIPOptionValue);
  1657	
  1658	        ip.ip_sum   = cksum((u_char *)&ip, SIZE_IP);
  1659	
  1660	        // push IP header space
  1661	        pkt->push(SIZE_IP);
  1662	        // copy IP header
  1663	        memcpy(pkt->data, &ip, SIZE_IP);
  1664	
  1665	        char *srcIP = inet_ntoa(ip.ip_src);
  1666	        char *dstIP = inet_ntoa(ip.ip_dst);
  1667	        log (TAG "%s() : from source    %s\n", __func__, inet_ntoa(ip.ip_src));
  1668	        log (TAG "%s() : to destination %s\n", __func__, inet_ntoa(ip.ip_dst));
  1669	        _neigh->send(pkt);
  1670	    }
  1671	    return 0;
  1672	
  1673	}
  1674	
  1675	void CNetwork::fragment(packet_t *pkt, uint16_t mtu)
  1676	{
  1677	    debug(DBG_DEFAULT, TAG "Do fragment.");
  1678	    iphdr_t ip;
  1679	
  1680	    ip.ip_vhl   = 0x40 | SIZE_IP_HL;
  1681	    ip.ip_tos   = 0;
  1682	    ip.ip_id    = htons(getAndIncID(pkt));
  1683	    ip.ip_ttl   = IPDEFTTL;         // default TTL
  1684	    ip.ip_p     = pkt->proto;
  1685	    ip.ip_sum   = 0;
  1686	    ip.ip_src   = pkt->saddr;
  1687	    ip.ip_dst   = pkt->daddr;
  1688	    ip.ip_opt   = htonl(cIPOptionValue);
  1689	
  1690	    unsigned int left   = pkt->len; // total length
  1691	    unsigned int len    = 0;        // current fragment length
  1692	    unsigned char *ptr  = pkt->data;// fragment start position
  1693	    uint16_t offset     = 0;
  1694	
  1695	
  1696	    while (left > 0) {
  1697	        len = left;
  1698	
  1699	        if (len + SIZE_IP > mtu) {
  1700	            len = mtu - SIZE_IP;
  1701	        }
  1702	
  1703	        if (len < left) {
  1704	            len &= ~7;          // align eight byte 
  1705	        }
  1706	
  1707	        debug(DBG_DEFAULT, TAG "data left length=%d, now length=%d.", left, len);
  1708	
  1709	        left -= len;
  1710	
  1711	        // allocate fragment packet 
  1712	        packet_t pkt2(ETH_HLEN + SIZE_IP + len); 
  1713	        pkt2.copyMetadata(*pkt);
  1714	        pkt2.reserve(ETH_HLEN + SIZE_IP);
  1715	        pkt2.put(len);
  1716	        memcpy(pkt2.data, ptr, len);
  1717	
  1718	        // set ip header
  1719	        iphdr_t iphdr = ip;
  1720	
  1721	        iphdr.ip_len    = htons(SIZE_IP + len);
  1722	        iphdr.ip_off    = htons(offset >> 3);
  1723	
  1724	        if (left > 0) {
  1725	            iphdr.ip_off |= htons(IP_MF);
  1726	        }
  1727	
  1728	        iphdr.ip_sum    = cksum((u_char *)&iphdr, SIZE_IP);
  1729	
  1730	        pkt2.push(SIZE_IP);
  1731	        memcpy(pkt2.data, &iphdr, SIZE_IP);
  1732	
  1733	        offset += len;
  1734	        ptr += len;
  1735	
  1736	        debug(DBG_DEFAULT, "<Network> send out fragment: %d bytes.", len);
  1737	        _neigh->send(&pkt2);
  1738	
  1739	    } // while
  1740	
  1741	}
  1742	
  1743	void CNetwork::forward(packet_t *pkt)
  1744	{
  1745	    debug(DBG_DEFAULT, TAG "forward to be implemented.");
  1746	}
  1747	
  1748	void CNetwork::deliver(packet_t *pkt)
  1749	{
  1750	    //pkt->pull(SIZE_IP);
  1751	
  1752	    switch (pkt->proto) {
  1753	        case IPPROTO_TCP:
  1754	            {
  1755	                _tcp->received(pkt);
  1756	                break;
  1757	            }
  1758	        case IPPROTO_UDP:
  1759	            {
  1760	                _udp->received(pkt);
  1761	                break;
  1762	            }
  1763	        case IPPROTO_ICMP:
  1764	            {
  1765	                break;
  1766	            }
  1767	        case IPPROTO_IP:
  1768	            {
  1769	                break;
  1770	            }
  1771	        default:
  1772	            break;
  1773	    }
  1774	
  1775	}
  1776	
  1777	uint32_t CNetwork::fragmentHashCode(iphdr_t *iphdr)
  1778	{
  1779	    uint32_t sAddrVal   = iphdr->ip_src.s_addr;
  1780	    uint32_t dAddrVal   = iphdr->ip_dst.s_addr;
  1781	    uint32_t protocol   = iphdr->ip_p;
  1782	    uint32_t id         = iphdr->ip_id;
  1783	
  1784	    //return sAddrVal * 3 + dAddrVal * 5 + protocol * 17 + id * 31;
  1785	    return ((sAddrVal << 1) + sAddrVal)
  1786	        + ((dAddrVal << 2) + dAddrVal)
  1787	        + ((protocol << 4) + protocol)
  1788	        + ((id << 5) - id);
  1789	
  1790	}
  1791	
  1792	void CNetwork::defragment(iphdr_t *iphdr, packet_t *pkt)
  1793	{
  1794	    // assume no overlap 
  1795	    debug(DBG_DEFAULT,  "defragment.");
  1796	
  1797	    // find fragment list it belongs to in fragment map
  1798	    uint32_t keyFrag = fragmentHashCode(iphdr);
  1799	
  1800	    IPFragList *pThisFrags = nullptr;
  1801	    if (_fragsMap.count(keyFrag) == 1) {
  1802	        pThisFrags = &_fragsMap.at(keyFrag);    // found and return the address
  1803	    }
  1804	    else {
  1805	        pThisFrags = &_fragsMap[keyFrag];       // not found, create one and return the address
  1806	
  1807	        pThisFrags->saddr   = iphdr->ip_src;
  1808	        pThisFrags->daddr   = iphdr->ip_dst;
  1809	        pThisFrags->proto   = iphdr->ip_p;
  1810	        pThisFrags->id      = iphdr->ip_id;
  1811	        pThisFrags->len     = 0;
  1812	        pThisFrags->meat    = 0;
  1813	    }
  1814	
  1815	    // calculate offset 
  1816	    uint16_t offset = ntohs(iphdr->ip_off);
  1817	    uint16_t flags = offset & ~IP_OFFMASK;
  1818	    offset &= IP_OFFMASK;
  1819	    offset <<= 3;
  1820	
  1821	    uint16_t end = offset + pkt->len - SIZE_IP;
  1822	
  1823	    if (offset == 0) {
  1824	        // first fragment
  1825	    }
  1826	
  1827	    if ((flags & IP_MF) == 0) {
  1828	        // last fragment
  1829	        pThisFrags->len = end;
  1830	    }
  1831	
  1832	    // copy and insert this fragment to framgent list
  1833	    pkt->pull(SIZE_IP);
  1834	
  1835	    packet_t *pkt2 = new packet_t(*pkt);
  1836	    pkt2->copyMetadata(*pkt);
  1837	    pkt2->getPacketCB()->offset = offset;
  1838	
  1839	    std::list<packet_t *> &frags = pThisFrags->fragments;
  1840	    const auto it = std::find_if(frags.cbegin(), frags.cend(), [=](const packet_t *pkt) {
  1841	                return pkt->getPacketCB()->offset >= offset;
  1842	            });
  1843	    frags.insert(it, pkt2);
  1844	
  1845	    debug(DBG_DEFAULT, TAG "fragment length=%d.", pkt2->len);
  1846	    pThisFrags->meat += pkt2->len;
  1847	    if (pThisFrags->meat == pThisFrags->len) {
  1848	        // completed, do reassemble work
  1849	        reasm(pThisFrags);
  1850	
  1851	        // clear cache
  1852	        clear(pThisFrags);
  1853	        // remove item from map
  1854	        _fragsMap.erase(keyFrag);
  1855	    }
  1856	    
  1857	}
  1858	
  1859	void CNetwork::reasm(IPFragList *pFrags)
  1860	{
  1861	    debug(DBG_DEFAULT, TAG "reassemble fragments of datagram id=%d.", pFrags->id);
  1862	    packet_t pkt(pFrags->len);
  1863	    pkt.saddr = pFrags->saddr;
  1864	    pkt.daddr = pFrags->daddr;
  1865	    pkt.proto = pFrags->proto;
  1866	    
  1867	    std::list<packet_t *> &frags = pFrags->fragments;
  1868	    for (packet_t *fragment : frags) {
  1869	        pkt.put(fragment->len);
  1870	
  1871	        memcpy(pkt.data, fragment->data, fragment->len);
  1872	
  1873	        pkt.pull(fragment->len);
  1874	    }
  1875	
  1876	    pkt.resetData();
  1877	    deliver(&pkt);
  1878	}
  1879	
  1880	void CNetwork::clear(IPFragList *pFrags)
  1881	{
  1882	    debug(DBG_DEFAULT, TAG "clear fragments of datagram id=%d.", pFrags->id);
  1883	    std::list<packet_t *> &frags = pFrags->fragments;
  1884	    auto it = frags.begin();
  1885	    while ( it != frags.end() ) {
  1886	        packet_t *pkt = *it;
  1887	        delete pkt;
  1888	        it = frags.erase(it);
  1889	    }
  1890	
  1891	}
  1892	
  1893	int CNetwork::received(packet_t *pkt)
  1894	{
  1895	    debug(DBG_DEFAULT, "<Network> received.");
  1896	    iphdr_t *iphdr = (iphdr_t *)pkt->data;
  1897	
  1898	    uint32_t sizeIPHdr = IP_HL(iphdr)*4;
  1899	    uint16_t len = ntohs(iphdr->ip_len);
  1900	    if (sizeIPHdr < SIZE_IP) {
  1901	        error("IP header size=%d, ignore\n", sizeIPHdr);
  1902	        return 0;
  1903	    }
  1904	    else {
  1905	        log(TAG "IP header size=%d, datagram len=%d\n", sizeIPHdr, len);
  1906	    }
  1907	
  1908	    if (len < pkt->len) {
  1909	        log(TAG "%s(): there is %d bytes padding data, trim it\n", __func__, pkt->len - len);
  1910	        pkt->trim(pkt->len - len);
  1911	    }
  1912	
  1913	    pkt->saddr = iphdr->ip_src;
  1914	    pkt->daddr = iphdr->ip_dst;
  1915	    pkt->proto = iphdr->ip_p;
  1916	
  1917	    /* print source and destination IP addresses */
  1918	    debug("       From: %s\n", inet_ntoa(pkt->saddr));
  1919	    debug("         To: %s\n", inet_ntoa(pkt->daddr));
  1920	    debug("   Protocol: %s (%03d)\n",
  1921	            tok2str(ipproto_values, "Unknown", pkt->proto), pkt->proto);
  1922	
  1923	    // check for local deliver or forward by compare destination address
  1924	    const Device *dev = CLink::instance()->getDefaultDevice();
  1925	    if (dev->ipAddr.s_addr != pkt->daddr.s_addr ) {
  1926	        forward(pkt);
  1927	    }
  1928	    else {
  1929	        if (iphdr->isFragment()) {
  1930	            defragment(iphdr, pkt);
  1931	        }
  1932	        else {
  1933	            pkt->pull(SIZE_IP);
  1934	            deliver(pkt);
  1935	        }
  1936	    }
  1937	    return 0;
  1938	    
  1939	}
  1940	
  1941	CNetwork::~CNetwork() 
  1942	{
  1943	    // delete still hold cache if needed
  1944	    for (auto pair : _fragsMap) {
  1945	        IPFragList *pFrags = &pair.second;
  1946	
  1947	        clear(pFrags);
  1948	    }
  1949	    _fragsMap.clear();
  1950	
  1951	}
  1952	
  1953	void CNetwork::init()
  1954	{
  1955	    if (_isInited)
  1956	        return;
  1957	
  1958	    _neigh = CNeighbor::instance();
  1959	    _neigh->init();
  1960	
  1961	    _tcp = CTCP::instance();
  1962	    _udp = CUDP::instance();
  1963	
  1964	    _isInited = true;
  1965	    debug(DBG_DEFAULT, "<Network> inited.");
  1966	
  1967	}
  1968	
  1969	#include "arp.h"
  1970	#include "ether.h"
  1971	
  1972	#include "Util.h"
  1973	
  1974	#include <cstring>
  1975	#include <utility>
  1976	#include <algorithm>
  1977	
  1978	#define TAG "<ARP> "
  1979	
  1980	void CARP::init()
  1981	{
  1982	    if (_isInited)
  1983	        return;
  1984	
  1985	    _link       = CLink::instance();
  1986	    // Since the init() is called up to down order, ARP no need to call link's init() any more
  1987	    //_link->init();
  1988	
  1989	    _isInited   = true;
  1990	    debug(DBG_DEFAULT, TAG "initied.");
  1991	
  1992	}
  1993	
  1994	CARP::~CARP()
  1995	{
  1996	    // delete allocated space if there is pending packet
  1997	    for (auto &pair : _arpQueue) {
  1998	        auto & list = pair.second;
  1999	        for (auto &item : list) {
  2000	            delete item.packet;         // delete [1]
  2001	            item.packet = nullptr;
  2002	        }
  2003	    }
  2004	
  2005	}
  2006	
  2007	void CARP::sendDatagram(packet_t *packet)
  2008	{
  2009	    log (TAG "%s.\n", __func__);
  2010	    const Device *dev = _link->getDefaultDevice();
  2011	    if (dev == nullptr) {
  2012	        error("<ARP> Cannot get avaliable device.");
  2013	        return;
  2014	    }
  2015	
  2016	    const struct in_addr & daddr = packet->daddr;
  2017	
  2018	    packet->sha = dev->hAddr;       // set local hardware address
  2019	
  2020	    if (_arpTable.count(daddr.s_addr) == 1) {   // check cache: find
  2021	        debug("Hit cache for: %s\n", inet_ntoa(daddr));
  2022	
  2023	        const ARPTableItem & cache = _arpTable.at(daddr.s_addr);
  2024	        packet->dha = cache.mac;
  2025	
  2026	        _link->transmit(packet);    // call link layer transmit
  2027	    }
  2028	    else {                                      // need send ARP packet
  2029	        debug("No cache for: %s, send ARP.\n", inet_ntoa(daddr));
  2030	
  2031	        int cachedBefore = cache(daddr, packet);    // cache packet for later transmisson
  2032	        
  2033	        if (cachedBefore == 0) {                    // address resolve if no previous request send
  2034	            memcpy(&packet->dha, ether_aton("FF:FF:FF:FF:FF:FF"), ETH_ALEN);
  2035	        
  2036	            sendARP(daddr, packet);
  2037	        } else {}
  2038	    }
  2039	
  2040	}
  2041	
  2042	int CARP::cache(const struct in_addr &key, packet_t *packet)
  2043	{
  2044	    //packet_t copy(*packet);
  2045	    //copy.buf = new u_char[packet->size];
  2046	    //memmove(copy.buf, packet->buf, packet->size);   // in case overlap, use memmove instead
  2047	
  2048	    std::list<ARPQueueItem> & kList = _arpQueue[key.s_addr];
  2049	    ARPQueueItem item;
  2050	    item.packet = new packet_t(*packet);            // new [1]
  2051	    kList.push_back(item);
  2052	
  2053	    return kList.size() - 1;
  2054	
  2055	}
  2056	
  2057	void CARP::sendARP(const struct in_addr &addr, packet_t *packet)
  2058	{
  2059	    ARPHdr arp;
  2060	    arp.htype   = htons(ARPHRD_ETHER);          // linux/if_arp.h
  2061	    arp.ptype   = htons(ETH_P_IP);              // linux/if_ether.h
  2062	    arp.hlen    = ETH_ALEN;
  2063	    arp.plen    = 4;
  2064	    arp.oper    = htons(ARPOP_REQUEST);
  2065	    memcpy(&arp.sha, &packet->sha, ETH_ALEN);
  2066	    arp.spa     = packet->saddr.s_addr;
  2067	    memset(&arp.tha, 0, ETH_ALEN);
  2068	    arp.tpa     = addr.s_addr;
  2069	
  2070	    packet_t pkt(SIZE_ETHERNET + cARPHeaderLen);
  2071	    pkt.sha     = packet->sha;
  2072	    pkt.dha     = packet->dha;
  2073	
  2074	    pkt.reserve(SIZE_ETHERNET);
  2075	    pkt.put( cARPHeaderLen );
  2076	    memcpy(pkt.data, &arp, cARPHeaderLen);
  2077	
  2078	    //packet_t &pkt = *packet;
  2079	    //pkt.arphdr  = arp;
  2080	    pkt.ept     = ETH_P_ARP;
  2081	
  2082	    _link->transmit(&pkt);
  2083	
  2084	}
  2085	
  2086	void CARP::cache(const ARPHdr *arphdr)
  2087	{
  2088	    ARPTableItem item;          
  2089	    item.ip     = arphdr->spa;
  2090	    memcpy(&item.mac, &arphdr->sha, ETH_ALEN);
  2091	    item.ttl    = cARPMaxTTL;
  2092	
  2093	    _arpTable.emplace(item.ip, item);           // cache to arp table
  2094	
  2095	}
  2096	
  2097	void CARP::recvARP(packet_t *packet)
  2098	{
  2099	    debug("<ARP> received.\n");
  2100	    ARPHdr *arphdr = (ARPHdr *)packet->data;
  2101	
  2102	    if (ntohs(arphdr->htype) == ARPHRD_ETHER && ntohs(arphdr->ptype) == ETH_P_IP) {
  2103	        u_int16_t oper = ntohs(arphdr->oper);
  2104	
  2105	        struct in_addr spa, tpa;
  2106	        spa.s_addr = arphdr->spa;
  2107	        tpa.s_addr = arphdr->tpa;
  2108	        debug("Sender      IP: %s, MAC: %s\n", inet_ntoa(spa), ether_ntoa((struct ether_addr *)arphdr->sha));
  2109	        debug("Destination IP: %s, MAC: %s\n", inet_ntoa(tpa), ether_ntoa((struct ether_addr *)arphdr->tha));
  2110	
  2111	        const Device *dev = _link->getDefaultDevice();
  2112	        in_addr_t thisDevAddr = dev->ipAddr.s_addr;
  2113	
  2114	        if (arphdr->tpa != thisDevAddr) {
  2115	            debug(DBG_DEFAULT, "ARP not to this device, ignore.");
  2116	            return;
  2117	        }
  2118	
  2119	        if (oper == ARPOP_REPLY) {
  2120	            debug(DBG_DEFAULT, "arp reply.  cache and process.");
  2121	            cache(arphdr);
  2122	
  2123	            processPendingDatagrams(arphdr->spa,
  2124	                    (struct ether_addr*)arphdr->sha);   // notify for pending ip datagram
  2125	        }
  2126	        else if(oper == ARPOP_REQUEST)  {
  2127	            debug(DBG_DEFAULT, "arp request, cache and reply.");
  2128	            cache(arphdr);
  2129	
  2130	            replyARP(arphdr);
  2131	        }
  2132	        else {
  2133	            debug("Unknown arp operation code: %d\n", oper);
  2134	        }
  2135	    }
  2136	    else {
  2137	        error("Invalid ARP packet.\n");
  2138	    }
  2139	
  2140	}
  2141	
  2142	void CARP::processPendingDatagrams(in_addr_t addr, const struct ether_addr * mac)
  2143	{
  2144	    ARPQueue::iterator it = _arpQueue.find(addr);
  2145	    if (it != _arpQueue.end()) {
  2146	        auto &itemList = it->second;
  2147	
  2148	        for (auto &item : itemList) {
  2149	            packet_t *pkt = item.packet;
  2150	            pkt->dha = *mac;
  2151	            debug(DBG_DEFAULT, "<ARP> process pending datagrams for %s...", inet_ntoa(*(struct in_addr*)&addr));
  2152	            log("<ARP> process pending datagrams for %s...\n", inet_ntoa(*(struct in_addr*)&addr));
  2153	            _link->transmit(item.packet);
  2154	            delete item.packet;         // delete [1]
  2155	            item.packet = nullptr;
  2156	        }
  2157	
  2158	        _arpQueue.erase(it);
  2159	    }
  2160	
  2161	}
  2162	
  2163	void CARP::replyARP(const ARPHdr *arphdr)
  2164	{
  2165	    packet_t packet(ETH_HLEN + cARPHeaderLen); 
  2166	    ARPHdr arp; 
  2167	
  2168	    arp = *arphdr;
  2169	    arp.oper    = htons(ARPOP_REPLY);
  2170	
  2171	    const Device *dev = _link->getDefaultDevice();
  2172	    memcpy(&arp.sha, &dev->hAddr, ETH_ALEN);
  2173	    arp.spa     = dev->ipAddr.s_addr;
  2174	    memcpy(&arp.tha, &arphdr->sha, ETH_ALEN);
  2175	    arp.tpa     = arphdr->spa;
  2176	
  2177	    memcpy(&packet.dha, &arphdr->sha, ETH_ALEN);
  2178	    memcpy(&packet.sha, &arp.sha, ETH_ALEN);
  2179	    packet.ept  = ETH_P_ARP;
  2180	
  2181	    packet.reserve(ETH_HLEN);
  2182	    packet.put(cARPHeaderLen);
  2183	    memcpy(packet.data, &arp, cARPHeaderLen);
  2184	
  2185	    struct in_addr tpa {.s_addr = arp.tpa };
  2186	    debug(DBG_DEFAULT, "<ARP> reply to %s.", inet_ntoa(tpa));
  2187	    log("<ARP> reply to %s.\n", inet_ntoa(tpa));
  2188	    _link->transmit(&packet);
  2189	
  2190	}
  2191	#include "Device.h"
  2192	
  2193	
  2194	#include "Link.h"
  2195	#include "Util.h"
  2196	#include <cstring>
  2197	#include <netinet/ether.h>
  2198	
  2199	#define TAG "<Link> "
  2200	
  2201	const tok_t ethertype_values[] = {
  2202	    {ETH_P_IP,          "IPv4"},
  2203	    {ETH_P_ARP,         "ARP"},
  2204	    {ETH_P_IPV6,        "IPv6"},
  2205	    {ETH_P_LOOPBACK,    "Loopback"},
  2206	    {0, NULL}
  2207	};
  2208	
  2209	void CLink::send(packet_t *packet)
  2210	{
  2211	    _neigh->send(packet);
  2212	}
  2213	
  2214	void CLink::transmit(packet_t *packet)
  2215	{
  2216	    log(TAG "%s.\n", __func__);
  2217	    if ( !(packet->ept == ETH_P_ARP || packet->ept == ETH_P_IP) ) {
  2218	        error("Unsupported ethernet packet.\n");
  2219	        return ;
  2220	    }
  2221	
  2222	    ether_header etherhdr;
  2223	    memcpy(&etherhdr.ether_shost, &packet->sha, ETH_ALEN);
  2224	    memcpy(&etherhdr.ether_dhost, &packet->dha, ETH_ALEN);
  2225	    etherhdr.ether_type     = htons(packet->ept); 
  2226	
  2227	    log (TAG "%s(): From %s.\n", __func__, ether_ntoa((ether_addr*)&etherhdr.ether_shost));
  2228	    log (TAG "%s(): To   %s.\n", __func__, ether_ntoa((ether_addr*)&etherhdr.ether_dhost));
  2229	
  2230	    packet->push(ETH_HLEN);
  2231	    memcpy(packet->data, &etherhdr, ETH_HLEN);
  2232	    _hardware->transmit(packet->data, packet->len);
  2233	
  2234	}
  2235	
  2236	void CLink::received(const u_char *bytes, size_t size)
  2237	{
  2238	    //debug("<Link> received:\n");
  2239	    packet_t packet(size);
  2240	    packet.put(size);
  2241	    memcpy(packet.data, bytes, size);
  2242	
  2243	    struct ether_header *etherhdr = (struct ether_header *)packet.data;
  2244	    memcpy(&packet.dha, &etherhdr->ether_dhost, ETH_ALEN);
  2245	    memcpy(&packet.sha, &etherhdr->ether_shost, ETH_ALEN);
  2246	    packet.ept  = ntohs(etherhdr->ether_type);
  2247	
  2248	    debug("Network Layer Protocol: %s (%04X)\n",
  2249	            tok2str(ethertype_values, "Unknown", packet.ept), packet.ept);
  2250	    debug("Destination MAC: %s\n", ether_ntoa(&packet.dha));
  2251	    debug("Sender      MAC: %s\n", ether_ntoa(&packet.sha));
  2252	
  2253	    packet.pull(ETH_HLEN);
  2254	    switch (packet.ept) {
  2255	        case ETH_P_ARP:
  2256	            _neigh->received(&packet);
  2257	            break;
  2258	        case ETH_P_IP:
  2259	            _network->received(&packet);
  2260	            break;
  2261	        default:
  2262	            return ;
  2263	    }
  2264	
  2265	}
  2266	
  2267	const Device * CLink::getDefaultDevice() const 
  2268	{
  2269	    return _hardware->getDefaultDevice();
  2270	}
  2271	
  2272	void CLink::init()
  2273	{
  2274	    if (_isInited)
  2275	        return;
  2276	
  2277	    _hardware   = CHardware::instance();
  2278	    _hardware->init();
  2279	    _neigh      = CNeighbor::instance();
  2280	    // Since this init() is called by CNeighbor's init(), it must be initialized
  2281	    //   there is no need to call
  2282	    //_neigh->init();
  2283	    _network = CNetwork::instance();
  2284	
  2285	    _isInited   = true;
  2286	    debug(DBG_DEFAULT, TAG "initied.");
  2287	
  2288	}
  2289	#include "Hardware.h"
  2290	
  2291	/*network*/
  2292	#include <arpa/inet.h>
  2293	#include <linux/netdevice.h>
  2294	
  2295	#include <cstring>
  2296	#include <sstream>
  2297	#include <algorithm>
  2298	
  2299	#include <thread>
  2300	
  2301	#include "Util.h"
  2302	
  2303	#define TAG "<Hardware> "
  2304	/*
  2305	 * MTU - Maximum ethernet data size
  2306	 *
  2307	 * Maximum ethernet frame size is MTU+ETH_HLEN+ETH_FCS = 1500+14+4 = 1518
  2308	 *
  2309	 * For some device, MTU is 576.
  2310	 * */
  2311	const u_int16_t cDefaultMTU = 1500;
  2312	
  2313	
  2314	void CHardware::transmit(const u_char *bytes, size_t size)
  2315	{
  2316	    if(_defaultDev == nullptr || _defaultDev->handler == nullptr) {
  2317	        error("Default device not avaliable.");
  2318	        return ;
  2319	    }
  2320	
  2321	    int byteSend = pcap_inject(_defaultDev->handler, bytes, size);
  2322	    if(byteSend == -1) {
  2323	        error("Send packet failed.");
  2324	    }
  2325	    else {
  2326	        debug(DBG_DEFAULT, "Transmited packet to network (%d bytes).", byteSend);
  2327	        log("Transmited packet to network (%d bytes).\n", byteSend);
  2328	    }
  2329	    
  2330	}
  2331	
  2332	void CHardware::getPacket(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)
  2333	{
  2334	    debug("\n<Hardware> received packet (%d bytes).\n", h->len);
  2335	    CHardware *inst = CHardware::instance();
  2336	
  2337	    inst->_link->received(bytes, h->len);
  2338	}
  2339	
  2340	void CHardware::up()
  2341	{
  2342	    if (_defaultDev != nullptr) {
  2343	        pcap_loop(_defaultDev->handler, -1, &CHardware::getPacket, nullptr);
  2344	    }
  2345	    else {
  2346	    }
  2347	}
  2348	
  2349	void CHardware::down()
  2350	{
  2351	    if (_defaultDev != nullptr) {
  2352	        pcap_breakloop(_defaultDev->handler);
  2353	    }
  2354	    else {
  2355	    }
  2356	}
  2357	
  2358	int CHardware::detectDevices(char *errbuf)
  2359	{
  2360	    if (pcap_findalldevs(&_foundDevs, errbuf) == -1) {          // cal pcap findalldevs
  2361	        error("Couldn't find any device: %s\n", errbuf);
  2362	        return -1;
  2363	    }
  2364	
  2365	    std::ostringstream oss;
  2366	    oss << "Detected devices:";
  2367	    int count = 0;
  2368	
  2369	    pcap_if_t *pDev = _foundDevs;
  2370	    while (pDev != NULL) {
  2371	        bpf_u_int32 flag = pDev->flags;
  2372	
  2373	        if ((flag & PCAP_IF_RUNNING) && !(flag & PCAP_IF_LOOPBACK)) {   // find running and not loopback device
  2374	            Device dev;
  2375	            dev.name = pDev->name; 
  2376	
  2377	            int progress = 0;
  2378	
  2379	            pcap_addr_t *paddr = pDev->addresses;   // get address
  2380	            while (paddr != NULL) {
  2381	                struct sockaddr *sa = paddr->addr;
  2382	                
  2383	                if (sa->sa_family == AF_PACKET) {           // find hardware address
  2384	                    struct sockaddr_ll *sall = (struct sockaddr_ll *) sa;
  2385	                    memcpy(&(dev.hAddr), &(sall->sll_addr), ETH_ALEN); 
  2386	                    progress |= 0x01;
  2387	                }
  2388	                else if (sa->sa_family == AF_INET) {        // find ip address
  2389	                    struct sockaddr_in *sai = (struct sockaddr_in *) sa;
  2390	                    memcpy(&(dev.ipAddr), &(sai->sin_addr), sizeof(struct in_addr));
  2391	                    progress |= 0x10;
  2392	                }
  2393	                else {}
  2394	
  2395	                if( (progress & 0x01) && (progress & 0x10) )// we only find mac & ip address
  2396	                    break;
  2397	
  2398	                paddr = paddr->next;
  2399	            }
  2400	
  2401	            dev.mtu     = cDefaultMTU;
  2402	            _devs.push_back(dev);                   // save to cache
  2403	        }
  2404	        else {}
  2405	
  2406	        oss << "\n" << ++count << "." << pDev->name;
  2407	        pDev = pDev->next;
  2408	    }
  2409	
  2410	    log("%s\n", oss.str().c_str());
  2411	    debug(DBG_DEFAULT, oss.str().c_str());
  2412	
  2413	    return _devs.size();
  2414	
  2415	}
  2416	
  2417	void CHardware::init()
  2418	{
  2419	    if(_isInited) 
  2420	        return;
  2421	
  2422	    char errbuf[PCAP_ERRBUF_SIZE];
  2423	
  2424	    int nDevice = detectDevices(errbuf);            // detect avaliable devices
  2425	    if (nDevice <= 0) {                             // make sure we get at least one device
  2426	        error("No suitable device found.\n");
  2427	        return ;
  2428	    }
  2429	
  2430	    _defaultDev = &_devs.front();                   // open the first device as default handler
  2431	    _defaultDev->handler = pcap_open_live (_defaultDev->name, SNAP_LEN, 0, PKT_BUFF_TIME, errbuf);
  2432	    if (_defaultDev->handler == NULL) {
  2433	        error("Couldn't open device %s : %s\n", _defaultDev->name, errbuf); 
  2434	        return ;
  2435	    }
  2436	
  2437	    if (pcap_datalink(_defaultDev->handler) != DLT_EN10MB) { // make sure we're capturing on an Ethernet device
  2438	        error("%s is not an Ethernet device\n", _devs.front().name);
  2439	        return ;
  2440	    }
  2441	
  2442	    std::thread listenThread(std::bind(&CHardware::up, this));
  2443	    listenThread.detach();                          // start listen 
  2444	    //pcap_dispatch(_defaultDev->handler, -1, &CHardware::getPacket, nullptr);  // only dispatch once
  2445	                                                    
  2446	    debug(DBG_DEFAULT, TAG "inited, suitable device list:");
  2447	    log(TAG "inited, suitable device list:\n");
  2448	    for (const Device& dev : _devs) {
  2449	        if(dev.name == _defaultDev->name) {         // use == because we use pointer for default device
  2450	            debug(DBG_DEFAULT, "%s *(default)", dev.toString().c_str());
  2451	            log("%s *(default)\n", dev.toString().c_str());
  2452	        }
  2453	        else {
  2454	            debug(DBG_DEFAULT, dev.toString().c_str());
  2455	            log("%s.\n", dev.toString().c_str());
  2456	        }
  2457	    }
  2458	
  2459	    _link = CLink::instance();
  2460	    _isInited = true;
  2461	
  2462	
  2463	}
  2464	#include "UDP.h"
  2465	#include "Network.h"
  2466	#include "Util.h"
  2467	#include "CheckSum.h"
  2468	#include "ProtoSocket.h"
  2469	#include "ether.h"
  2470	#include <string>
  2471	
  2472	#define TAG "<CUDP> "
  2473	
  2474	const unsigned int cMaxBufferSize = 4096;
  2475	
  2476	uint16_t cksum_udp(const udphdr_t *const udp, const packet_t *const packet)
  2477	{
  2478	
  2479	    uint16_t sum;
  2480	    u_char *buf;
  2481	    size_t size;
  2482	
  2483	    pseudo_udp_t pseudo_udp;
  2484	
  2485	    pseudo_udp.saddr    = packet->saddr;
  2486	    pseudo_udp.daddr    = packet->daddr;
  2487	    pseudo_udp.zero     = 0;
  2488	    pseudo_udp.protocol = IPPROTO_UDP;
  2489	    pseudo_udp.len      = udp->uh_len;
  2490	
  2491	    size = SIZE_PSEUDO_UDP + SIZE_UDP + packet->size;
  2492	    buf = (u_char *)malloc(size);
  2493	    memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
  2494	    memcpy(buf+SIZE_PSEUDO_UDP, udp, SIZE_UDP);
  2495	    memcpy(buf+SIZE_PSEUDO_UDP+SIZE_UDP, packet->buf, packet->size);
  2496	
  2497	    sum = cksum(buf, size);
  2498	
  2499	    free(buf);
  2500	
  2501	    return sum;
  2502	
  2503	}
  2504	
  2505	void CUDP::init()
  2506	{
  2507	    if (_isInited)
  2508	        return ;
  2509	
  2510	    CNetwork::instance()->init();
  2511	    _isInited = true;
  2512	    debug(DBG_DEFAULT, "<UDP> inited.");
  2513	}
  2514	
  2515	int CUDP::send(packet_t *packet)
  2516	{
  2517	    log (TAG "%s\n", __func__);
  2518	    // make a copy of original data
  2519	    int sizeHdr = SIZE_UDP + SIZE_IP + SIZE_ETHERNET;
  2520	
  2521	    // allocate more space include header
  2522	    packet_t pkt(sizeHdr + packet->size);
  2523	    pkt.copyMetadata(*packet);
  2524	
  2525	    pkt.proto = IPPROTO_UDP;
  2526	
  2527	    // reserve space for header
  2528	    pkt.reserve(sizeHdr);
  2529	
  2530	    // copy payload
  2531	    pkt.put(packet->size);
  2532	    memcpy(pkt.data, packet->buf, packet->size);
  2533	
  2534	    // prepare UDP header
  2535	    udphdr_t udp; 
  2536	    size_t size_new = SIZE_UDP + packet->size;
  2537	
  2538	    //udp.uh_sport    = htons(packet->sport);
  2539	    //udp.uh_dport    = htons(packet->dport);
  2540	    udp.uh_sport    = packet->sport;
  2541	    udp.uh_dport    = packet->dport;
  2542	    udp.uh_len      = htons(size_new);
  2543	    udp.uh_sum      = 0;
  2544	
  2545	    udp.uh_sum      = cksum_udp(&udp, packet);
  2546	
  2547	    // push UDP header space
  2548	    pkt.push(SIZE_UDP);
  2549	
  2550	    // copy UDP header
  2551	    memcpy(pkt.data, &udp, SIZE_UDP);
  2552	
  2553	    log (TAG "%s() : from %d to %d.\n", __func__, ntohs(udp.uh_sport), ntohs(udp.uh_dport));
  2554	    // call network to do next work
  2555	    CNetwork *network = CNetwork::instance();
  2556	    network->send(&pkt);
  2557	
  2558	    return 0;
  2559	
  2560	}
  2561	
  2562	int CUDP::received(packet_t *pkt)
  2563	{
  2564	    debug(DBG_DEFAULT, "<UDP> received.");
  2565	    udphdr_t *udphdr = (udphdr_t *)pkt->data;
  2566	    uint16_t dataLen = ntohs( udphdr->uh_len ) - SIZE_UDP;
  2567	
  2568	    pkt->sport  = udphdr->uh_sport;
  2569	    pkt->dport  = udphdr->uh_dport;
  2570	
  2571	    pkt->pull(SIZE_UDP);
  2572	    //std::string msg((const char*)pkt->data, dataLen);
  2573	
  2574	    //debug(DBG_DEFAULT, "Received data length=%d : \n%s", dataLen, msg.c_str());
  2575	    CProtoSocket::instance()->received(pkt);
  2576	    return 0;
  2577	
  2578	}
  2579	
  2580	#include "TCP.h"
  2581	#include "Util.h"
  2582	#include "CheckSum.h"
  2583	
  2584	#include "udp.h"
  2585	#include "ip.h"
  2586	#include "ether.h"
  2587	
  2588	#include <algorithm>
  2589	
  2590	#define TAG "<CTCP> "
  2591	
  2592	using std::string;
  2593	using std::set;
  2594	using std::map;
  2595	
  2596	const uint32_t cMaxHeaderLen = SIZE_ETHERNET + SIZE_IP + SIZE_TCP;
  2597	const uint32_t cBlockSize = 4096;
  2598	
  2599	uint16_t cksum_tcp(const tcphdr_t *const tcp, const packet_t *const packet)
  2600	{
  2601	    uint16_t sum;
  2602	    u_char *buf;
  2603	    size_t size;
  2604	    size_t dataLen;
  2605	    pseudo_udp_t pseudo_udp;
  2606	
  2607	    dataLen = (packet->allocated ? packet->len : packet->size); 
  2608	
  2609	    pseudo_udp.saddr    = packet->saddr;
  2610	    pseudo_udp.daddr    = packet->daddr;
  2611	    pseudo_udp.zero     = 0;
  2612	    pseudo_udp.protocol = IPPROTO_TCP;
  2613	    pseudo_udp.len      = htons(SIZE_TCP + dataLen);
  2614	
  2615	    size = SIZE_PSEUDO_UDP + SIZE_TCP + dataLen;
  2616	    buf = (u_char *)malloc(size);
  2617	    memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
  2618	    memcpy(buf + SIZE_PSEUDO_UDP, tcp, SIZE_TCP);
  2619	    memcpy(buf + SIZE_PSEUDO_UDP + SIZE_TCP, (packet->allocated ? packet->data : packet->buf), dataLen);
  2620	
  2621	    sum = cksum(buf, size);
  2622	
  2623	    free(buf);
  2624	
  2625	    return sum;
  2626	
  2627	}
  2628	
  2629	void CTCP::init()
  2630	{
  2631	    if (_isInited)
  2632	        return;
  2633	
  2634	    _protoSock = CProtoSocket::instance();
  2635	    _network = CNetwork::instance();
  2636	    _network->init();
  2637	
  2638	    _isInited = true;
  2639	    debug(DBG_DEFAULT, TAG "inited.");
  2640	}
  2641	
  2642	CTCP::~CTCP()
  2643	{
  2644	    log(TAG "desconstructed.\n");
  2645	}
  2646	
  2647	int CTCP::send(packet_t *packet)
  2648	{
  2649	    log(TAG "%s().\n", __func__);
  2650	    string key = keyOf(packet->saddr, packet->sport, packet->daddr, packet->dport);
  2651	    ConnMap::iterator it = _connPool.find(key);
  2652	
  2653	    if (it == _connPool.end()) {
  2654	        error (TAG "%s(): no connection %s found.\n", __func__, key.c_str());
  2655	        return 0;
  2656	    }
  2657	
  2658	    // put to queue and return
  2659	
  2660	    // get connection send queue
  2661	    InetConnSock & sk = it->second;
  2662	    PacketQueue & sendQueue = sk.sendQueue;
  2663	
  2664	    u_char *pBuf = packet->buf;
  2665	    int dataLeft = packet->size;
  2666	
  2667	    while (dataLeft > 0) {
  2668	        // split it
  2669	        int dataLen = dataLeft;
  2670	
  2671	        if (sendQueue.empty()) {
  2672	            // should allocate a new packet_t
  2673	            if (dataLen > cTCPMSS) {
  2674	                dataLen = cTCPMSS;
  2675	            }
  2676	            dataLeft -= dataLen;
  2677	
  2678	            // always allocate fixed size, if there is space left, filled by next time
  2679	            std::shared_ptr<packet_t> ppkt(new packet_t(cTCPMSS));
  2680	            ppkt->copyMetadata(*packet);
  2681	            ppkt->put(dataLen);
  2682	            memcpy(ppkt->data, pBuf, dataLen);
  2683	            pBuf += dataLen;
  2684	
  2685	            TCP_PKT_CB(ppkt)->seq = sk.sendWin.nextSeq;
  2686	            uint32_t endSeq = sk.sendWin.nextSeq + dataLen - 1;
  2687	            TCP_PKT_CB(ppkt)->endSeq = endSeq;
  2688	            sk.sendWin.nextSeq = endSeq + 1;
  2689	
  2690	            ppkt->proto = IPPROTO_TCP;
  2691	
  2692	            sendQueue.emplace_back(ppkt);
  2693	        }
  2694	        else {
  2695	            log(TAG "%s(): none empty send queue not handled yet!.\n", __func__);
  2696	            std::shared_ptr<packet_t> &tail = sendQueue.back();
  2697	            if (tail->len == tail->size) {
  2698	                // should allocate a new packet_t
  2699	            }
  2700	            else if (tail->size < cTCPMSS) {
  2701	                // can copy some data here
  2702	            }
  2703	            else {
  2704	                // should not happen
  2705	            }
  2706	        }
  2707	
  2708	    }
  2709	
  2710	    doSend(&sk);
  2711	
  2712	    // actually, the copied bytes number should be returned
  2713	    return packet->size;
  2714	
  2715	}
  2716	
  2717	void CTCP::doSend(InetConnSock *ics)
  2718	{
  2719	    log(TAG "%s().\n", __func__);
  2720	    PacketQueue & sendQueue = ics->sendQueue; 
  2721	
  2722	    PacketQueue::iterator it = std::find_if(sendQueue.begin(), sendQueue.end(), [=](const PacketQueue::value_type &ppkt){
  2723	        return TCP_PKT_CB(ppkt)->seq == ics->sendWin.lastSeq;
  2724	    });
  2725	
  2726	    if (it == sendQueue.end()) {
  2727	        log(TAG "%s(): no match sequence packet found.\n", __func__);
  2728	        return ;
  2729	    }
  2730	
  2731	    // should check send & receive window first 
  2732	
  2733	    std::shared_ptr<packet_t> &ppkt = *it;
  2734	
  2735	    packet_t pkt(ppkt->len + cMaxHeaderLen); 
  2736	    pkt.copyMetadata(*ppkt);
  2737	
  2738	    ics->sendWin.nextAck = TCP_PKT_CB(ppkt)->seq + ppkt->len;
  2739	
  2740	    __doSend(&pkt, ics, 0, ppkt->buf, ppkt->len);
  2741	
  2742	}
  2743	
  2744	void CTCP::__doSend(packet_t *packet, InetConnSock *ics, uint8_t flags, uint8_t *buf, uint32_t size)
  2745	{
  2746	    packet->reserve(cMaxHeaderLen);
  2747	
  2748	    // copy payload
  2749	    packet->put(size);
  2750	    memcpy(packet->data, buf, size); 
  2751	
  2752	    tcphdr_t tcphdr;
  2753	    tcphdr.th_sport = ics->ics_port;
  2754	    tcphdr.th_dport = ics->ics_peerPort;
  2755	    tcphdr.th_seq = htonl(ics->sendWin.lastSeq); 
  2756	    tcphdr.th_ack = htonl(ics->recvWin.lastAck);
  2757	    tcphdr.th_offx2 = 0x50;
  2758	    tcphdr.th_flags = flags;
  2759	    tcphdr.th_win = htons(ics->recvWin.size);
  2760	    tcphdr.th_sum = 0;
  2761	    tcphdr.th_urp = 0;
  2762	
  2763	    tcphdr.th_sum = cksum_tcp(&tcphdr, packet);
  2764	
  2765	    packet->push(SIZE_TCP);
  2766	    memcpy(packet->data, &tcphdr, sizeof(tcphdr));
  2767	
  2768	    log(TAG "%s send seq=%d,ack=%d.\n", keyOf(ics).c_str(), ics->sendWin.lastSeq, ics->recvWin.lastAck);
  2769	    _network->send(packet);
  2770	
  2771	}
  2772	
  2773	void CTCP::sendNoData(packet_t *packet, InetConnSock *ics, uint8_t flags)
  2774	{
  2775	    packet->saddr = ics->ics_addr;
  2776	    packet->sport = ics->ics_port;
  2777	    packet->daddr = ics->ics_peerAddr;
  2778	    packet->dport = ics->ics_peerPort;
  2779	
  2780	    packet->proto = IPPROTO_TCP; 
  2781	    packet->reserve(cMaxHeaderLen); 
  2782	
  2783	    tcphdr_t thdr;
  2784	    thdr.th_sport = ics->ics_port;
  2785	    thdr.th_dport = ics->ics_peerPort;
  2786	    thdr.th_seq = htonl(ics->sendWin.lastSeq);
  2787	    thdr.th_ack = htonl(ics->recvWin.lastAck);
  2788	    thdr.th_offx2 = 0x50;
  2789	    thdr.th_flags = flags;
  2790	    thdr.th_win = ics->recvWin.size;
  2791	    thdr.th_sum = 0;
  2792	    thdr.th_urp = 0;
  2793	
  2794	    packet_t emptyPkt;
  2795	    emptyPkt.copyMetadata(*packet);
  2796	    thdr.th_sum = cksum_tcp(&thdr, &emptyPkt);
  2797	
  2798	    packet->push(SIZE_TCP);
  2799	    memcpy(packet->data, &thdr, sizeof(tcphdr_t));
  2800	
  2801	    log(TAG "%s send seq=%d,ack=%d.\n", keyOf(ics).c_str(), ics->sendWin.lastSeq, ics->recvWin.lastAck);
  2802	    _network->send(packet);
  2803	
  2804	}
  2805	
  2806	int CTCP::received(packet_t *pkt)
  2807	{
  2808	    log(TAG "%s().\n", __func__);
  2809	
  2810	    tcphdr_t *tcphdr = (tcphdr_t *)pkt->data;
  2811	    pkt->sport = tcphdr->th_sport;
  2812	    pkt->dport = tcphdr->th_dport;
  2813	
  2814	    log(TAG "%s(): before pull TCP header, pkt->size = %d, pkt->len = %d.\n", __func__, pkt->size, pkt->len);
  2815	    int sizeTCPHdr = TH_OFF(tcphdr) * 4;
  2816	    pkt->pull(sizeTCPHdr);
  2817	    log(TAG "%s(): after pull TCP header, pkt->size = %d, pkt->len = %d.\n", __func__, pkt->size, pkt->len);
  2818	
  2819	    uint32_t seq = ntohl(tcphdr->th_seq);
  2820	    uint32_t ack = ntohl(tcphdr->th_ack);
  2821	
  2822	    // check existing connection
  2823	    string key = keyOf(pkt->daddr, pkt->dport, pkt->saddr, pkt->sport);
  2824	    ConnMap::iterator it = _connPool.find(key); 
  2825	    if (it != _connPool.end()) {
  2826	        // check current connection state 
  2827	        InetConnSock *conn = &it->second;
  2828	        if (conn->ics_state == ESTABLISHED) {
  2829	            recvEstablished(conn, pkt, tcphdr);
  2830	        }
  2831	        else {
  2832	            recvStateProcess(conn, pkt, tcphdr);
  2833	        }
  2834	    }
  2835	    else {
  2836	        // try listening socket
  2837	        InetSockMap::iterator iter = _listenPool.find(pkt->dport);
  2838	        if (iter != _listenPool.end() && iter->second->sk_state == LISTEN) {
  2839	            log(TAG "find listen socket\n");
  2840	            recvListen(iter->second, pkt, tcphdr);
  2841	        }
  2842	        else {
  2843	            log(TAG "no connection or listen socket found, should send RST\n");
  2844	            // todo: reply RST
  2845	        }
  2846	    }
  2847	
  2848	    return 0;
  2849	
  2850	}
  2851	
  2852	void CTCP::recvEstablished(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr)
  2853	{
  2854	    log(TAG "%s().\n", __func__);
  2855	
  2856	    uint32_t seq = ntohl(tcphdr->th_seq);
  2857	    uint32_t ack = ntohl(tcphdr->th_ack);
  2858	    if (tcphdr->th_flags & TH_RST) {
  2859	        log(TAG "%s(): RST received\n", __func__);
  2860	    }
  2861	    else if (tcphdr->th_flags & TH_FIN) {
  2862	        log(TAG "%s(): FIN received, send ACK\n", __func__);
  2863	        ics->sendWin.lastSeq = ack;
  2864	        ics->recvWin.lastAck = seq + 1;
  2865	        ics->ics_state = CLOSE_WAIT;
  2866	        ics->_inetSock._sock.state = SS_DISCONNECTING;
  2867	        log(TAG "%s(): change to state CLOSE_WAIT\n", __func__);
  2868	        packet_t pkt(cMaxHeaderLen);
  2869	        sendNoData(&pkt, ics, TH_ACK);
  2870	
  2871	        // should wait all data transfered, do send FIN
  2872	        
  2873	        ics->ics_state = LAST_ACK;
  2874	        log(TAG "%s(): change to state LAST_ACK\n", __func__);
  2875	        packet_t pkt2(cMaxHeaderLen);
  2876	        sendNoData(&pkt2, ics, TH_FIN);
  2877	    }
  2878	    else {
  2879	        if(tcphdr->th_flags & TH_ACK){
  2880	            ics->recvWin.lastAck = ack;
  2881	            log(TAG "%s(): ack=%d\n", __func__, ack);
  2882	        }
  2883	        else {
  2884	        }
  2885	
  2886	        uint32_t dataLen = packet->len;
  2887	
  2888	        if (dataLen <= 0) {
  2889	            // it's a pure header, no more process is needed, just return 
  2890	            return ;
  2891	        }
  2892	
  2893	        // if checksum right
  2894	        PacketQueue &recvQueue = ics->recvQueue;
  2895	        if (recvQueue.empty()) {
  2896	            // allocate a new packet_t and copy data
  2897	            // (don't worry the new buffer size less than received bytes, it won't happed)
  2898	            std::shared_ptr<packet_t> ppkt(new packet_t(cBlockSize));
  2899	            
  2900	            ppkt->put(dataLen);
  2901	            memcpy(ppkt->data, packet->data, dataLen);
  2902	            // if you append data to it, remember move data pointer to the end of previous first, then move back 
  2903	
  2904	            recvQueue.emplace_back(ppkt); 
  2905	            _protoSock->bytesAvailable(ics);
  2906	
  2907	            // send ack
  2908	            ics->recvWin.lastAck = seq + dataLen;
  2909	            packet_t pkt(cMaxHeaderLen);
  2910	            sendNoData(&pkt, ics, TH_ACK);
  2911	        }
  2912	        else {
  2913	            log(TAG "%s(): none empty receive queue not handled.\n", __func__);
  2914	            std::shared_ptr<packet_t> &back = recvQueue.back(); 
  2915	            if (back->isFull()) {
  2916	                // allocate a new packet_t and copy data
  2917	            }
  2918	            else {
  2919	                // append data to this packet_t, if not enough, allocate a new one
  2920	            }
  2921	        }
  2922	    }
  2923	}
  2924	
  2925	void CTCP::recvStateProcess(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr)
  2926	{
  2927	    log(TAG "%s().\n", __func__);
  2928	
  2929	    uint32_t seq = ntohl(tcphdr->th_seq);
  2930	    uint32_t ack = ntohl(tcphdr->th_ack);
  2931	    log(TAG "%s(): seq=%d, ack=%d.\n", __func__, seq, ack);
  2932	
  2933	    switch (tcphdr->th_flags) {
  2934	        default:
  2935	            log(TAG "%s(): unknown flag: %d.\n", __func__, tcphdr->th_flags);
  2936	            break;
  2937	        case TH_FIN:
  2938	            {
  2939	                if (ics->ics_state == FIN_WAIT_1 || ics->ics_state == FIN_WAIT_2) {
  2940	                    if (ics->ics_state == FIN_WAIT_1) {
  2941	                        log(TAG "%s(): both closing\n", __func__);
  2942	                    }
  2943	                    log(TAG "%s(): close side received FIN, send ACK\n", __func__);
  2944	                    ics->ics_state = TIME_WAIT; 
  2945	                    log(TAG "%s(): change to state TIME_WAIT\n", __func__);
  2946	
  2947	                    ics->sendWin.lastSeq = ack;
  2948	                    ics->recvWin.lastAck = seq + 1;
  2949	                    packet_t pkt(cMaxHeaderLen);
  2950	                    sendNoData(&pkt, ics, TH_ACK);
  2951	
  2952	                    // should start TIME_WAIT timer here
  2953	                    log(TAG "%s(): change to state CLOSED\n", __func__);
  2954	                    ics->ics_state = CLOSED;
  2955	                    string name = keyOf(ics);
  2956	                    _connPool.erase(name);
  2957	
  2958	                    _protoSock->closed(name);
  2959	                }
  2960	                else {
  2961	                    log (TAG "%s(): received FIN but not FIN_WAIT_1 nor FIN_WAIT_2 state\n", __func__);
  2962	                }
  2963	                break;
  2964	            }
  2965	        case TH_SYN:
  2966	            {
  2967	                log(TAG "%s(): SYN.\n", __func__);
  2968	                break;
  2969	            }
  2970	        case TH_SYN | TH_ACK:
  2971	            {
  2972	                log(TAG "%s(): SYN and ACK.\n", __func__); 
  2973	                if (ics->ics_state == SYN_SENT) {
  2974	                    // todo: send ACK, connect() finish 
  2975	                    if (ics->sendWin.lastSeq + 1 != ack) {
  2976	                        log(TAG "%s(): TH_SYN | TH_ACK ack not match, lastSeq=%d, ack=%d!\n", __func__, ics->sendWin.lastSeq, ack);
  2977	                    }
  2978	                    ics->sendWin.lastSeq = ack;
  2979	                    ics->sendWin.nextSeq = ack;
  2980	                    ics->recvWin.lastAck = seq + 1;
  2981	
  2982	                    packet_t pack(cMaxHeaderLen);
  2983	                    sendNoData(&pack, ics, TH_ACK);
  2984	
  2985	                    // we established a connection at client side
  2986	                    ics->ics_state = ESTABLISHED;
  2987	                    _protoSock->connectFinished(keyOf(ics), ics); 
  2988	                }
  2989	                else {
  2990	                    // what's this?
  2991	                    log(TAG "%s(): get SYN and ACK but connection state is not SYN_SENT, just ignore...\n", __func__); 
  2992	                }
  2993	                break;
  2994	            }
  2995	        case TH_RST:
  2996	        case TH_ACK | TH_RST:
  2997	            {
  2998	                log(TAG "%s(): RST(or ACK|RST).\n", __func__);
  2999	                break;
  3000	            }
  3001	        case TH_PUSH:
  3002	            {
  3003	                log(TAG "%s(): PUSH.\n", __func__);
  3004	                break;
  3005	            }
  3006	        case TH_ACK:
  3007	            {
  3008	                log(TAG "%s(): ACK.\n", __func__);
  3009	                if (ics->ics_state == SYN_RCVD) {
  3010	                    // we established a connection at server side
  3011	                    ics->sendWin.lastSeq = ack;
  3012	                    ics->sendWin.nextSeq = ack;
  3013	                    ics->ics_state = ESTABLISHED;
  3014	                    _protoSock->accepted(keyOf(ics), ics);
  3015	                }
  3016	                else if (ics->ics_state == FIN_WAIT_1){
  3017	                    log(TAG "%s(): FIN_WAIT_1 received ACK\n", __func__);
  3018	                    ics->sendWin.lastSeq = ack;
  3019	                    ics->recvWin.lastAck = seq + 1;
  3020	                    ics->ics_state = FIN_WAIT_2;
  3021	                    log(TAG "%s(): change to state FIN_WAIT_2\n", __func__);
  3022	                }
  3023	                else if(ics->ics_state == LAST_ACK) {
  3024	                    ics->ics_state = CLOSED;
  3025	                    log(TAG "%s(): change to state CLOSED\n", __func__);
  3026	
  3027	                    string name = keyOf(ics);
  3028	                    _connPool.erase(name);
  3029	
  3030	                    _protoSock->closed(name);
  3031	                }
  3032	                else {
  3033	                    log(TAG "%s(): a connection received ACK but state neither SYN_RCVD nor ESTABLISHED, state=%d.\n", __func__, ics->ics_state);
  3034	                }
  3035	                break;
  3036	            }
  3037	        case TH_URG:
  3038	            {
  3039	                log(TAG "%s(): URG.\n", __func__);
  3040	                break;
  3041	            }
  3042	    }
  3043	}
  3044	
  3045	void CTCP::recvListen(InetSock *sock, packet_t *packet, tcphdr_t *tcphdr)
  3046	{
  3047	    uint32_t seq = ntohl(tcphdr->th_seq);
  3048	    uint32_t ack = ntohl(tcphdr->th_ack);
  3049	    log(TAG "%s(): seq=%d,ack=%d\n", __func__, seq, ack);
  3050	
  3051	    // the listen socket only recognize SYN
  3052	    if (tcphdr->th_flags == TH_SYN) {
  3053	        // create a new socket and let:
  3054	        //
  3055	        // sk_state = SYN_RCVD
  3056	        // CTL = SYN, ACK
  3057	        log(TAG "%s(): listened SYN.\n", __func__);
  3058	        InetConnSock ics;
  3059	        ics._inetSock = *sock;
  3060	
  3061	        ics.ics_peerAddr = packet->saddr;
  3062	        ics.ics_peerPort = packet->sport;
  3063	        ics.ics_state = SYN_RCVD;
  3064	
  3065	        InetConnSock *conn = newConnection(&ics);
  3066	
  3067	        // send CTL, Wed 14 Mar 2018 18:38:51 
  3068	        conn->sendWin.lastSeq = ack;
  3069	        conn->recvWin.lastAck = seq + 1;
  3070	        conn->recvWin.size = 0xffff;
  3071	        conn->sendWin.size = conn->recvWin.size >> 1;
  3072	
  3073	        packet_t pack(cMaxHeaderLen);
  3074	        sendNoData(&pack, conn, TH_SYN | TH_ACK);
  3075	        log(TAG "%s(): replied ACK|SYN\n" ,__func__);
  3076	    }
  3077	    else {
  3078	        log(TAG "listen socket received flags not SYN.\n");
  3079	        // todo: reply RST
  3080	    }
  3081	}
  3082	
  3083	void CTCP::connect(InetSock *sk)
  3084	{
  3085	    log(TAG "%s()\n", __func__);
  3086	    // save to connection pool
  3087	    InetConnSock ics;
  3088	    ics._inetSock = *sk;
  3089	    ics.sendWin.lastSeq = 2018;
  3090	    ics.recvWin.lastAck = 0;
  3091	    ics.recvWin.size = 0xffff;
  3092	    ics.sendWin.size = ics.recvWin.size >> 1;
  3093	    ics.ics_state = SYN_SENT;
  3094	
  3095	    string key = keyOf(&ics);
  3096	    _connPool.emplace(key, ics);
  3097	
  3098	    // send SYN
  3099	    packet_t pkt(cMaxHeaderLen);
  3100	    sendNoData(&pkt, &ics, TH_SYN);
  3101	
  3102	}
  3103	
  3104	void CTCP::close(std::string name)
  3105	{
  3106	    log(TAG "%s(): %s\n", __func__, name.c_str());
  3107	    ConnMap::iterator it = _connPool.find(name);
  3108	    if (it == _connPool.end()) {
  3109	        log (TAG "%s(): connection not found\n", __func__);
  3110	        return ;
  3111	    }
  3112	
  3113	    InetConnSock * ics = &it->second;
  3114	    ics->ics_state = FIN_WAIT_1;
  3115	    log(TAG "%s(): change to state FIN_WAIT_1\n", __func__);
  3116	
  3117	    // send FIN
  3118	    packet_t pkt(cMaxHeaderLen);
  3119	    sendNoData(&pkt, ics, TH_FIN);
  3120	}
  3121	
  3122	string CTCP::keyOf(InetConnSock *ics)
  3123	{
  3124	    return keyOf(ics->ics_addr, ics->ics_port, ics->ics_peerAddr, ics->ics_peerPort);
  3125	}
  3126	
  3127	string CTCP::keyOf(struct in_addr localAddr, uint16_t localPort,
  3128	        struct in_addr peerAddr, uint16_t peerPort)
  3129	{
  3130	    //return string(std::to_string(localAddr.s_addr) + "." + std::to_string(localPort) + ","
  3131	            //+ std::to_string(peerAddr.s_addr) + "." + std::to_string(peerPort));
  3132	    string key = string(inet_ntoa(localAddr)) + "." + std::to_string(ntohs(localPort)) + ","
  3133	        + string(inet_ntoa(peerAddr)) + "." + std::to_string(ntohs(peerPort));
  3134	    //log(TAG "%s(): %s.\n", __func__, key.c_str());
  3135	    return key;
  3136	}
  3137	
  3138	InetConnSock * CTCP::newConnection(InetConnSock *ics)
  3139	{
  3140	    ics->ics_sockfd = 0;            // 0 for unaccepted connection
  3141	
  3142	    string key = keyOf(ics);
  3143	    auto pair = _connPool.emplace(key, *ics);// std::pair<map<string,InetConnSock>::iterator,bool>
  3144	    if (pair.second == true) {
  3145	        log (TAG "%s(): created new connection.\n", __func__);
  3146	    }
  3147	
  3148	    return &pair.first->second;
  3149	
  3150	}
  3151	
  3152	void CTCP::listen(InetSock *sk) 
  3153	{
  3154	    _listenPool.emplace(sk->sk_port, sk);
  3155	}
  3156	
  3157	/* This source file must have a .cpp extension so that all C++ compilers
  3158	   recognize the extension without flags.  Borland does not know .cxx for
  3159	   example.  */
  3160	#ifndef __cplusplus
  3161	# error "A C compiler has been selected for C++."
  3162	#endif
  3163	
  3164	/* Version number components: V=Version, R=Revision, P=Patch
  3165	   Version date components:   YYYY=Year, MM=Month,   DD=Day  */
  3166	
  3167	#if defined(__COMO__)
  3168	# define COMPILER_ID "Comeau"
  3169	  /* __COMO_VERSION__ = VRR */
  3170	# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
  3171	# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)
  3172	
  3173	#elif defined(__INTEL_COMPILER) || defined(__ICC)
  3174	# define COMPILER_ID "Intel"
  3175	  /* __INTEL_COMPILER = VRP */
  3176	# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
  3177	# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
  3178	# if defined(__INTEL_COMPILER_UPDATE)
  3179	#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
  3180	# else
  3181	#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
  3182	# endif
  3183	# if defined(__INTEL_COMPILER_BUILD_DATE)
  3184	  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
  3185	#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
  3186	# endif
  3187	# if defined(_MSC_VER)
  3188	#  define SIMULATE_ID "MSVC"
  3189	   /* _MSC_VER = VVRR */
  3190	#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
  3191	#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
  3192	# endif
  3193	
  3194	#elif defined(__PATHCC__)
  3195	# define COMPILER_ID "PathScale"
  3196	# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
  3197	# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
  3198	# if defined(__PATHCC_PATCHLEVEL__)
  3199	#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
  3200	# endif
  3201	
  3202	#elif defined(__clang__)
  3203	# if defined(__apple_build_version__)
  3204	#  define COMPILER_ID "AppleClang"
  3205	#  define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
  3206	# else
  3207	#  define COMPILER_ID "Clang"
  3208	# endif
  3209	# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
  3210	# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
  3211	# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
  3212	# if defined(_MSC_VER)
  3213	#  define SIMULATE_ID "MSVC"
  3214	   /* _MSC_VER = VVRR */
  3215	#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
  3216	#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
  3217	# endif
  3218	
  3219	#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
  3220	# define COMPILER_ID "Embarcadero"
  3221	# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
  3222	# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
  3223	# define COMPILER_VERSION_PATCH HEX(__CODEGEARC_VERSION__     & 0xFFFF)
  3224	
  3225	#elif defined(__BORLANDC__)
  3226	# define COMPILER_ID "Borland"
  3227	  /* __BORLANDC__ = 0xVRR */
  3228	# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
  3229	# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
  3230	
  3231	#elif defined(__WATCOMC__)
  3232	# define COMPILER_ID "Watcom"
  3233	  /* __WATCOMC__ = VVRR */
  3234	# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
  3235	# define COMPILER_VERSION_MINOR DEC(__WATCOMC__ % 100)
  3236	
  3237	#elif defined(__SUNPRO_CC)
  3238	# define COMPILER_ID "SunPro"
  3239	# if __SUNPRO_CC >= 0x5100
  3240	   /* __SUNPRO_CC = 0xVRRP */
  3241	#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
  3242	#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
  3243	#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
  3244	# else
  3245	   /* __SUNPRO_CC = 0xVRP */
  3246	#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
  3247	#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
  3248	#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
  3249	# endif
  3250	
  3251	#elif defined(__HP_aCC)
  3252	# define COMPILER_ID "HP"
  3253	  /* __HP_aCC = VVRRPP */
  3254	# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
  3255	# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
  3256	# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)
  3257	
  3258	#elif defined(__DECCXX)
  3259	# define COMPILER_ID "Compaq"
  3260	  /* __DECCXX_VER = VVRRTPPPP */
  3261	# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
  3262	# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
  3263	# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)
  3264	
  3265	#elif defined(__IBMCPP__)
  3266	# if defined(__COMPILER_VER__)
  3267	#  define COMPILER_ID "zOS"
  3268	# else
  3269	#  if __IBMCPP__ >= 800
  3270	#   define COMPILER_ID "XL"
  3271	#  else
  3272	#   define COMPILER_ID "VisualAge"
  3273	#  endif
  3274	   /* __IBMCPP__ = VRP */
  3275	#  define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
  3276	#  define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
  3277	#  define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
  3278	# endif
  3279	
  3280	#elif defined(__PGI)
  3281	# define COMPILER_ID "PGI"
  3282	# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
  3283	# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
  3284	# if defined(__PGIC_PATCHLEVEL__)
  3285	#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
  3286	# endif
  3287	
  3288	#elif defined(_CRAYC)
  3289	# define COMPILER_ID "Cray"
  3290	# define COMPILER_VERSION_MAJOR DEC(_RELEASE)
  3291	# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
  3292	
  3293	#elif defined(__TI_COMPILER_VERSION__)
  3294	# define COMPILER_ID "TI"
  3295	  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
  3296	# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
  3297	# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
  3298	# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
  3299	
  3300	#elif defined(__SCO_VERSION__)
  3301	# define COMPILER_ID "SCO"
  3302	
  3303	#elif defined(__GNUC__)
  3304	# define COMPILER_ID "GNU"
  3305	# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
  3306	# define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
  3307	# if defined(__GNUC_PATCHLEVEL__)
  3308	#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
  3309	# endif
  3310	
  3311	#elif defined(_MSC_VER)
  3312	# define COMPILER_ID "MSVC"
  3313	  /* _MSC_VER = VVRR */
  3314	# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
  3315	# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
  3316	# if defined(_MSC_FULL_VER)
  3317	#  if _MSC_VER >= 1400
  3318	    /* _MSC_FULL_VER = VVRRPPPPP */
  3319	#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
  3320	#  else
  3321	    /* _MSC_FULL_VER = VVRRPPPP */
  3322	#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
  3323	#  endif
  3324	# endif
  3325	# if defined(_MSC_BUILD)
  3326	#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
  3327	# endif
  3328	
  3329	/* Analog VisualDSP++ >= 4.5.6 */
  3330	#elif defined(__VISUALDSPVERSION__)
  3331	# define COMPILER_ID "ADSP"
  3332	  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */
  3333	# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)
  3334	# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)
  3335	# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)
  3336	
  3337	/* Analog VisualDSP++ < 4.5.6 */
  3338	#elif defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
  3339	# define COMPILER_ID "ADSP"
  3340	
  3341	/* IAR Systems compiler for embedded systems.
  3342	   http://www.iar.com */
  3343	#elif defined(__IAR_SYSTEMS_ICC__ ) || defined(__IAR_SYSTEMS_ICC)
  3344	# define COMPILER_ID "IAR"
  3345	
  3346	#elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)
  3347	# define COMPILER_ID "MIPSpro"
  3348	# if defined(_SGI_COMPILER_VERSION)
  3349	  /* _SGI_COMPILER_VERSION = VRP */
  3350	#  define COMPILER_VERSION_MAJOR DEC(_SGI_COMPILER_VERSION/100)
  3351	#  define COMPILER_VERSION_MINOR DEC(_SGI_COMPILER_VERSION/10 % 10)
  3352	#  define COMPILER_VERSION_PATCH DEC(_SGI_COMPILER_VERSION    % 10)
  3353	# else
  3354	  /* _COMPILER_VERSION = VRP */
  3355	#  define COMPILER_VERSION_MAJOR DEC(_COMPILER_VERSION/100)
  3356	#  define COMPILER_VERSION_MINOR DEC(_COMPILER_VERSION/10 % 10)
  3357	#  define COMPILER_VERSION_PATCH DEC(_COMPILER_VERSION    % 10)
  3358	# endif
  3359	
  3360	/* This compiler is either not known or is too old to define an
  3361	   identification macro.  Try to identify the platform and guess that
  3362	   it is the native compiler.  */
  3363	#elif defined(__sgi)
  3364	# define COMPILER_ID "MIPSpro"
  3365	
  3366	#elif defined(__hpux) || defined(__hpua)
  3367	# define COMPILER_ID "HP"
  3368	
  3369	#else /* unknown compiler */
  3370	# define COMPILER_ID ""
  3371	
  3372	#endif
  3373	
  3374	/* Construct the string literal in pieces to prevent the source from
  3375	   getting matched.  Store it in a pointer rather than an array
  3376	   because some compilers will just produce instructions to fill the
  3377	   array rather than assigning a pointer to a static array.  */
  3378	char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
  3379	#ifdef SIMULATE_ID
  3380	char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
  3381	#endif
  3382	
  3383	#ifdef __QNXNTO__
  3384	char const* qnxnto = "INFO" ":" "qnxnto";
  3385	#endif
  3386	
  3387	/* Identify known platforms by name.  */
  3388	#if defined(__linux) || defined(__linux__) || defined(linux)
  3389	# define PLATFORM_ID "Linux"
  3390	
  3391	#elif defined(__CYGWIN__)
  3392	# define PLATFORM_ID "Cygwin"
  3393	
  3394	#elif defined(__MINGW32__)
  3395	# define PLATFORM_ID "MinGW"
  3396	
  3397	#elif defined(__APPLE__)
  3398	# define PLATFORM_ID "Darwin"
  3399	
  3400	#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
  3401	# define PLATFORM_ID "Windows"
  3402	
  3403	#elif defined(__FreeBSD__) || defined(__FreeBSD)
  3404	# define PLATFORM_ID "FreeBSD"
  3405	
  3406	#elif defined(__NetBSD__) || defined(__NetBSD)
  3407	# define PLATFORM_ID "NetBSD"
  3408	
  3409	#elif defined(__OpenBSD__) || defined(__OPENBSD)
  3410	# define PLATFORM_ID "OpenBSD"
  3411	
  3412	#elif defined(__sun) || defined(sun)
  3413	# define PLATFORM_ID "SunOS"
  3414	
  3415	#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
  3416	# define PLATFORM_ID "AIX"
  3417	
  3418	#elif defined(__sgi) || defined(__sgi__) || defined(_SGI)
  3419	# define PLATFORM_ID "IRIX"
  3420	
  3421	#elif defined(__hpux) || defined(__hpux__)
  3422	# define PLATFORM_ID "HP-UX"
  3423	
  3424	#elif defined(__HAIKU__)
  3425	# define PLATFORM_ID "Haiku"
  3426	
  3427	#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
  3428	# define PLATFORM_ID "BeOS"
  3429	
  3430	#elif defined(__QNX__) || defined(__QNXNTO__)
  3431	# define PLATFORM_ID "QNX"
  3432	
  3433	#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
  3434	# define PLATFORM_ID "Tru64"
  3435	
  3436	#elif defined(__riscos) || defined(__riscos__)
  3437	# define PLATFORM_ID "RISCos"
  3438	
  3439	#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
  3440	# define PLATFORM_ID "SINIX"
  3441	
  3442	#elif defined(__UNIX_SV__)
  3443	# define PLATFORM_ID "UNIX_SV"
  3444	
  3445	#elif defined(__bsdos__)
  3446	# define PLATFORM_ID "BSDOS"
  3447	
  3448	#elif defined(_MPRAS) || defined(MPRAS)
  3449	# define PLATFORM_ID "MP-RAS"
  3450	
  3451	#elif defined(__osf) || defined(__osf__)
  3452	# define PLATFORM_ID "OSF1"
  3453	
  3454	#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
  3455	# define PLATFORM_ID "SCO_SV"
  3456	
  3457	#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
  3458	# define PLATFORM_ID "ULTRIX"
  3459	
  3460	#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
  3461	# define PLATFORM_ID "Xenix"
  3462	
  3463	#else /* unknown platform */
  3464	# define PLATFORM_ID ""
  3465	
  3466	#endif
  3467	
  3468	/* For windows compilers MSVC and Intel we can determine
  3469	   the architecture of the compiler being used.  This is because
  3470	   the compilers do not have flags that can change the architecture,
  3471	   but rather depend on which compiler is being used
  3472	*/
  3473	#if defined(_WIN32) && defined(_MSC_VER)
  3474	# if defined(_M_IA64)
  3475	#  define ARCHITECTURE_ID "IA64"
  3476	
  3477	# elif defined(_M_X64) || defined(_M_AMD64)
  3478	#  define ARCHITECTURE_ID "x64"
  3479	
  3480	# elif defined(_M_IX86)
  3481	#  define ARCHITECTURE_ID "X86"
  3482	
  3483	# elif defined(_M_ARM)
  3484	#  define ARCHITECTURE_ID "ARM"
  3485	
  3486	# elif defined(_M_MIPS)
  3487	#  define ARCHITECTURE_ID "MIPS"
  3488	
  3489	# elif defined(_M_SH)
  3490	#  define ARCHITECTURE_ID "SHx"
  3491	
  3492	# else /* unknown architecture */
  3493	#  define ARCHITECTURE_ID ""
  3494	# endif
  3495	
  3496	#else
  3497	#  define ARCHITECTURE_ID ""
  3498	#endif
  3499	
  3500	/* Convert integer to decimal digit literals.  */
  3501	#define DEC(n)                   \
  3502	  ('0' + (((n) / 10000000)%10)), \
  3503	  ('0' + (((n) / 1000000)%10)),  \
  3504	  ('0' + (((n) / 100000)%10)),   \
  3505	  ('0' + (((n) / 10000)%10)),    \
  3506	  ('0' + (((n) / 1000)%10)),     \
  3507	  ('0' + (((n) / 100)%10)),      \
  3508	  ('0' + (((n) / 10)%10)),       \
  3509	  ('0' +  ((n) % 10))
  3510	
  3511	/* Convert integer to hex digit literals.  */
  3512	#define HEX(n)             \
  3513	  ('0' + ((n)>>28 & 0xF)), \
  3514	  ('0' + ((n)>>24 & 0xF)), \
  3515	  ('0' + ((n)>>20 & 0xF)), \
  3516	  ('0' + ((n)>>16 & 0xF)), \
  3517	  ('0' + ((n)>>12 & 0xF)), \
  3518	  ('0' + ((n)>>8  & 0xF)), \
  3519	  ('0' + ((n)>>4  & 0xF)), \
  3520	  ('0' + ((n)     & 0xF))
  3521	
  3522	/* Construct a string literal encoding the version number components. */
  3523	#ifdef COMPILER_VERSION_MAJOR
  3524	char const info_version[] = {
  3525	  'I', 'N', 'F', 'O', ':',
  3526	  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  3527	  COMPILER_VERSION_MAJOR,
  3528	# ifdef COMPILER_VERSION_MINOR
  3529	  '.', COMPILER_VERSION_MINOR,
  3530	#  ifdef COMPILER_VERSION_PATCH
  3531	   '.', COMPILER_VERSION_PATCH,
  3532	#   ifdef COMPILER_VERSION_TWEAK
  3533	    '.', COMPILER_VERSION_TWEAK,
  3534	#   endif
  3535	#  endif
  3536	# endif
  3537	  ']','\0'};
  3538	#endif
  3539	
  3540	/* Construct a string literal encoding the version number components. */
  3541	#ifdef SIMULATE_VERSION_MAJOR
  3542	char const info_simulate_version[] = {
  3543	  'I', 'N', 'F', 'O', ':',
  3544	  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  3545	  SIMULATE_VERSION_MAJOR,
  3546	# ifdef SIMULATE_VERSION_MINOR
  3547	  '.', SIMULATE_VERSION_MINOR,
  3548	#  ifdef SIMULATE_VERSION_PATCH
  3549	   '.', SIMULATE_VERSION_PATCH,
  3550	#   ifdef SIMULATE_VERSION_TWEAK
  3551	    '.', SIMULATE_VERSION_TWEAK,
  3552	#   endif
  3553	#  endif
  3554	# endif
  3555	  ']','\0'};
  3556	#endif
  3557	
  3558	/* Construct the string literal in pieces to prevent the source from
  3559	   getting matched.  Store it in a pointer rather than an array
  3560	   because some compilers will just produce instructions to fill the
  3561	   array rather than assigning a pointer to a static array.  */
  3562	char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
  3563	char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";
  3564	
  3565	
  3566	
  3567	
  3568	/*--------------------------------------------------------------------------*/
  3569	
  3570	int main(int argc, char* argv[])
  3571	{
  3572	  int require = 0;
  3573	  require += info_compiler[argc];
  3574	  require += info_platform[argc];
  3575	#ifdef COMPILER_VERSION_MAJOR
  3576	  require += info_version[argc];
  3577	#endif
  3578	#ifdef SIMULATE_ID
  3579	  require += info_simulate[argc];
  3580	#endif
  3581	#ifdef SIMULATE_VERSION_MAJOR
  3582	  require += info_simulate_version[argc];
  3583	#endif
  3584	  (void)argv;
  3585	  return require;
  3586	}
  3587	#include "Util.h"
  3588	#include <cstdarg>
  3589	
  3590	File fileDebug("debug.txt");
  3591	FILE *debugOut = fileDebug.get();
  3592	
  3593	void log(const char *fmt, ...)
  3594	{
  3595	    va_list va;
  3596	    va_start(va, fmt);
  3597	    vfprintf(stdout, fmt, va);
  3598	    va_end(va);
  3599	}
  3600	
  3601	void debug(const char *fmt, ...) 
  3602	{
  3603	#ifdef DEBUG
  3604	    va_list va;
  3605	    va_start(va, fmt);
  3606	    vfprintf(debugOut, fmt, va); 
  3607	    va_end(va);
  3608	    fflush(debugOut);
  3609	#endif 
  3610	}
  3611	
  3612	void debug(int flag, const char *fmt, ...) 
  3613	{
  3614	#ifdef DEBUG
  3615	    if (flag & DBG_PREFIX) 
  3616	        fprintf(debugOut, "DEBUG: ");
  3617	    va_list va;
  3618	    va_start(va, fmt);
  3619	    vfprintf(debugOut, fmt, va); 
  3620	    va_end(va);
  3621	    if (flag & DBG_NEWLINE) 
  3622	        fprintf(debugOut, "\n");
  3623	    fflush(debugOut);
  3624	#endif 
  3625	}
  3626	
  3627	void error(const char *fmt, ...)
  3628	{
  3629	    fprintf(stderr, "ERROR: ");
  3630	    va_list va;
  3631	    va_start(va, fmt);
  3632	    vfprintf(stderr, fmt, va);
  3633	    va_end(va);
  3634	}
  3635	
  3636	const char * tok2str(const tok_t * tokp,
  3637	        const char * default_msg,
  3638	        int v)
  3639	{
  3640	
  3641	    static char buf[SIZE_TOK_BUF];
  3642	
  3643	    if(tokp != NULL) {
  3644	        while(tokp->s != NULL) {
  3645	            if(tokp->v == v)
  3646	                return tokp->s;
  3647	            else 
  3648	                ++tokp;
  3649	        }
  3650	    }
  3651	
  3652	    snprintf(buf, SIZE_TOK_BUF, "%s", default_msg);
  3653	    return (const char *)buf;
  3654	}
  3655	
  3656	/*
  3657	 * DemoTimeClient - UDP Demo
  3658	 *
  3659	 * Send "time" to time server, print the feedback.
  3660	 * */
  3661	#include <cstdio>
  3662	#include <cstring>
  3663	#include <string>
  3664	#include "Socket.h"
  3665	
  3666	const char * const cDstAddrStr  = "211.67.27.254";
  3667	const unsigned short cDstPort   = 1618;
  3668	
  3669	void usage(const char *appName) 
  3670	{
  3671	    printf("Default address use %s:%d\n", cDstAddrStr, cDstPort);
  3672	    printf("To change it use addtional parameters:\n\t%s <ip> <port>\n", appName);
  3673	    printf("\n----------\n\n");
  3674	}
  3675	
  3676	int main(int argc, char *argv[])
  3677	{
  3678	    usage(argv[0]);
  3679	
  3680	    // create a socket
  3681	    CSocket socket;
  3682	    int sockfd;
  3683	    if ( (sockfd = socket.socket(AF_INET, SOCK_DGRAM, 0)) <= 0) {
  3684	        fprintf(stderr, "Failed socket().\n");
  3685	        return -1;
  3686	    }
  3687	
  3688	    // set target address
  3689	    struct sockaddr_in dstAddr;
  3690	    dstAddr.sin_family = AF_INET;
  3691	
  3692	    char dstAddrStr[20];
  3693	    unsigned short dstPort;
  3694	
  3695	    strncpy(dstAddrStr, cDstAddrStr, strlen(cDstAddrStr) + 1);
  3696	    dstPort = cDstPort;
  3697	    if (argc > 1) {
  3698	        strncpy(dstAddrStr, argv[1], strlen(argv[1]) + 1);
  3699	    }
  3700	    if (argc > 2) {
  3701	        dstPort = std::stoi(argv[2]);
  3702	    }
  3703	
  3704	    if (inet_aton(dstAddrStr, &dstAddr.sin_addr) <= 0) {
  3705	        fprintf(stderr, "Invalid address: %s\n", dstAddrStr);
  3706	        return -1;
  3707	    }
  3708	    dstAddr.sin_port = htons(dstPort);
  3709	
  3710	    printf("Target %s:%d.\n", dstAddrStr, dstPort);
  3711	
  3712	    // send
  3713	    const char *text = "time";
  3714	    int len = strlen(text);
  3715	    int byteSend = socket.sendto(text, len, 0, (const sockaddr*)&dstAddr, sizeof(dstAddr));
  3716	
  3717	    char buf[1024 + 1];
  3718	    socklen_t socklen = sizeof(dstAddr);
  3719	    if (byteSend > 0) {
  3720	        int byteRecv = socket.recvfrom(buf, 1024, 0, (struct sockaddr *)&dstAddr, &socklen);
  3721	
  3722	        if (byteRecv > 0) {
  3723	            buf[byteRecv] = '\0';
  3724	            printf("> %s\n", buf);
  3725	        }
  3726	        else {
  3727	            fprintf(stderr, "Failed receive.\n");
  3728	        }
  3729	    }
  3730	    else {
  3731	        fprintf(stderr, "Failed sendto().\n");
  3732	    }
  3733	
  3734	    return 0;
  3735	}
  3736	
  3737	
  3738	/*
  3739	 * The injector take user input as a datagram inject to network.
  3740	 * */
  3741	
  3742	#define APP_NAME		"injector"
  3743	#define APP_DESC		"Injector example using libpcap"
  3744	#define APP_COPYRIGHT	"Copyright (c) 2017 BiDong Gong (Antonio)"
  3745	#define APP_DISCLAIMER	"THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM."
  3746	
  3747	#include <unistd.h>
  3748	#include <cstdio>
  3749	#include <cstdlib>
  3750	#include <cstring>
  3751	#include <pcap.h>
  3752	#include <arpa/inet.h>
  3753	#include <linux/netdevice.h>
  3754	#include "ether.h"
  3755	#include "arp.h"
  3756	#include "ip.h"
  3757	#include "tcp.h"
  3758	#include "udp.h"
  3759	#include "netsimul.h"
  3760	
  3761	#include "Network.h"
  3762	#include "Link.h"
  3763	//#include "Hardware.h"
  3764	
  3765	#define SIZE_SEND_BUFFER 4096
  3766	#define SIZE_IP_ADDR_STR 16
  3767	#define SIZE_PORT_STR 5
  3768	
  3769	#define FRAGMENT_TEST 1
  3770	
  3771	const char poem[] = {
  3772	        "The farthest distance in the world\n"\
  3773	        "Is not the distance between life and death\n"\
  3774	        "But you don't know I love you when I stand in front of you\n"\
  3775	        "The farthest distance in the world\n"\
  3776	        "Is not you don't know I love when I stand in front of you\n"\
  3777	        "But I cannot say I love you when I love you so madly\n"\
  3778	        "The farthest distance in the world\n"\
  3779	        "Is not I cannot say I love you when I love you so madly\n"\
  3780	        "But I can only bury it in my heart dispite the unbearable yearing\n"\
  3781	        "The farthest distance in the world\n"\
  3782	        "Is not I can only bury it in my heart dispite the unbearable yearning\n"\
  3783	        "But we cannot be together when we love each other\n"\
  3784	        "The farthest distance in the world\n"\
  3785	        "Is not we cannot be together when we love each other\n"\
  3786	        "But we pretend caring nothing even we know love is unconquerable\n"\
  3787	        "The farthest distance in the world\n"\
  3788	        "Is not the distance between two trees\n"\
  3789	        "But the branches cannot depend on each other in wind even they grow from the same root\n"\
  3790	        "The farthest distance in the world\n"\
  3791	        "Is not the branches cannot depend on each other\n"\
  3792	        "But two stars cannot meet even they watch each other\n"\
  3793	        "The farthest distance in the world\n"\
  3794	        "Is not the track between two stars\n"\
  3795	        "But nowhere to search in a tick after two tracks join\n"\
  3796	        "The farthest distance in the world\n"\
  3797	        "Is not nowhere to search in a tick\n"\
  3798	        "But doomed not to be together before they meet\n"\
  3799	        "The farthest distance in the world\n"\
  3800	        "Is the distance between fish and bird\n"\
  3801	        "One is in the sky, another is in the sea\n"\
  3802	        "\n"\
  3803	        "The farthest distance in the world\n"\
  3804	        "Is the distance between fish and bird\n"\
  3805	        "One is in the sky, another is in the sea\n"\
  3806	        "\n"\
  3807	        "The farthest distance in the world\n"\
  3808	        "Is the distance between fish and bird\n"\
  3809	        "One is in the sky, another is in the sea\n"
  3810	};
  3811	
  3812	void handle_user_input(pcap_t * handler);
  3813	
  3814	void handle_inject(pcap_t *handler, packet_t *packet);
  3815	
  3816	void encap_tcp(pcap_t *handler, packet_t *packet);
  3817	
  3818	void encap_udp(pcap_t *handler, packet_t *packet);
  3819	
  3820	void encap_ip(pcap_t *handler, packet_t *packet);
  3821	
  3822	void encap_ether(pcap_t *handler, packet_t *packet);
  3823	
  3824	int send_packet(pcap_t *handler, const u_char *buf, size_t size);
  3825	
  3826	/*
  3827	 * app name/banner
  3828	 */
  3829	void print_app_banner()
  3830	{
  3831	
  3832		printf("%s - %s\n", APP_NAME, APP_DESC);
  3833		printf("%s\n", APP_COPYRIGHT);
  3834		printf("%s\n", APP_DISCLAIMER);
  3835		printf("\n");
  3836	
  3837	}
  3838	
  3839	/*
  3840	 * Send out packet to network
  3841	 *
  3842	 * @handler     A pcap_t handler use to inject packet to network
  3843	 * @buf         The packet to send
  3844	 * @size        The packet size
  3845	 * */
  3846	int send_packet(pcap_t *handler, const u_char *buf, size_t size)
  3847	{
  3848	
  3849	    int bytes_send;
  3850	
  3851	    bytes_send = pcap_inject(handler, buf, size);
  3852	    if(bytes_send == -1) {
  3853	        fprintf(stderr, "Send packet failed.");
  3854	    }
  3855	    else {
  3856	        printf("Injected packet to network (%d bytes).\n", bytes_send);
  3857	    }
  3858	
  3859	    return bytes_send;
  3860	
  3861	}
  3862	
  3863	void encap_tcp(pcap_t *handler, packet_t *packet)
  3864	{
  3865	
  3866	    send_packet(handler, packet->buf, packet->size);
  3867	    /*int bytes_send;                                                  */
  3868	
  3869	    /*bytes_send = send_packet(handler, packet->buf, packet->size);    */
  3870	    /*if(bytes_send == -1) {                                           */
  3871	    /*    fprintf(stderr, "Send packet failed");                       */
  3872	    /*}                                                                */
  3873	    /*else {                                                           */
  3874	    /*    printf("Injected packet to network (%d bytes).", bytes_send);*/
  3875	    /*}                                                                */
  3876	
  3877	}
  3878	
  3879	uint16_t cksum(const u_char *const buf, size_t size)
  3880	{
  3881	    uint32_t sum;
  3882	    uint16_t *p = (uint16_t *)buf;
  3883	
  3884	    sum = 0;
  3885	    while(size > 1) {
  3886	        sum += *p++;
  3887	        size -= 2;
  3888	    }
  3889	
  3890	    // padding as needed
  3891	    if(size == 1) {
  3892	        sum += *((u_char *)p);
  3893	    }
  3894	
  3895	    while(sum >> 16)
  3896	        sum = (sum & 0xFFFF) + (sum >> 16);
  3897	
  3898	    return (uint16_t)((~sum) & 0xFFFF);
  3899	}
  3900	
  3901	uint16_t cksum_udp(const udphdr_t *const udp, const packet_t *const packet)
  3902	{
  3903	
  3904	    uint16_t sum;
  3905	    u_char *buf;
  3906	    size_t size;
  3907	
  3908	    pseudo_udp_t pseudo_udp;
  3909	
  3910	    pseudo_udp.saddr    = packet->saddr;
  3911	    pseudo_udp.daddr    = packet->daddr;
  3912	    pseudo_udp.zero     = 0;
  3913	    pseudo_udp.protocol = IPPROTO_UDP;
  3914	    pseudo_udp.len      = udp->uh_len;
  3915	
  3916	    size = SIZE_PSEUDO_UDP + SIZE_UDP + packet->size;
  3917	    buf = (u_char *)malloc(size);
  3918	    memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
  3919	    memcpy(buf+SIZE_PSEUDO_UDP, udp, SIZE_UDP);
  3920	    memcpy(buf+SIZE_PSEUDO_UDP+SIZE_UDP, packet->buf, packet->size);
  3921	
  3922	    sum = cksum(buf, size);
  3923	
  3924	    free(buf);
  3925	
  3926	    return sum;
  3927	
  3928	}
  3929	
  3930	void encap_udp(pcap_t *handler, packet_t *packet)
  3931	{
  3932	
  3933	    udphdr_t udp; 
  3934	
  3935	    u_char *buf;
  3936	    size_t size_new;
  3937	
  3938	    size_new = SIZE_UDP + packet->size;
  3939	
  3940	    /*create UDP header*/
  3941	    udp.uh_sport    = htons(packet->sport);
  3942	    udp.uh_dport    = htons(packet->dport);
  3943	    udp.uh_len      = htons(size_new);
  3944	    udp.uh_sum      = 0;
  3945	
  3946	    udp.uh_sum      = cksum_udp(&udp, packet);
  3947	
  3948	    /*add UDP header*/
  3949	    buf = (u_char*)malloc(size_new);            // to be free() [1]
  3950	    memcpy(buf, &udp, SIZE_UDP);
  3951	    memcpy(buf+SIZE_UDP, packet->buf, packet->size);
  3952	    packet->buf     = buf;
  3953	    packet->size    = size_new;
  3954	
  3955	    encap_ip(handler, packet);
  3956	
  3957	}
  3958	
  3959	void encap_udp2(pcap_t *handler, packet_t *packet)
  3960	{
  3961	
  3962	    // make a copy of original data
  3963	    int sizeUDPHdr = 8;         // size in bytes
  3964	    int sizeIPHdr = 20;
  3965	    int sizeEtherHdr = 14;
  3966	    int sizeHdr = sizeUDPHdr + sizeIPHdr + sizeEtherHdr;
  3967	
  3968	    // allocate more space include header
  3969	    packet_t pkt(sizeHdr + packet->size);
  3970	    pkt.copyMetadata(*packet);
  3971	
  3972	    pkt.proto = IPPROTO_UDP;
  3973	
  3974	    // reserve space for header
  3975	    pkt.reserve(sizeHdr);
  3976	
  3977	    // copy payload
  3978	    pkt.put(packet->size);
  3979	    memcpy(pkt.data, packet->buf, packet->size);
  3980	
  3981	    // prepare UDP header
  3982	    udphdr_t udp; 
  3983	    size_t size_new = SIZE_UDP + packet->size;
  3984	
  3985	    udp.uh_sport    = htons(packet->sport);
  3986	    udp.uh_dport    = htons(packet->dport);
  3987	    udp.uh_len      = htons(size_new);
  3988	    udp.uh_sum      = 0;
  3989	
  3990	    udp.uh_sum      = cksum_udp(&udp, packet);
  3991	
  3992	    // push UDP header space
  3993	    pkt.push(SIZE_UDP);
  3994	
  3995	    // copy UDP header
  3996	    memcpy(pkt.data, &udp, SIZE_UDP);
  3997	
  3998	    // call network to do next work
  3999	    CNetwork *network = CNetwork::instance();
  4000	    network->send(&pkt);
  4001	
  4002	}
  4003	
  4004	uint16_t cksum_ip(const iphdr_t * const ip)
  4005	{
  4006	
  4007	    return cksum((u_char *)ip, SIZE_IP);
  4008	
  4009	}
  4010	
  4011	void encap_ip(pcap_t *handler, packet_t *packet)
  4012	{
  4013	
  4014	    iphdr_t ip;
  4015	
  4016	    u_char *buf;
  4017	    size_t size_new;
  4018	
  4019	    size_new = SIZE_IP + packet->size;
  4020	
  4021	    /*create IP header*/
  4022	    ip.ip_vhl   = 0x45;
  4023	    ip.ip_tos   = 0;
  4024	    ip.ip_len   = htons(size_new);
  4025	    ip.ip_id    = htons(0xF96D);
  4026	    ip.ip_off   = htons(IP_DF);     // don't fragment
  4027	    ip.ip_ttl   = IPDEFTTL;         // default TTL
  4028	    ip.ip_p     = INJECT_OP_TCP(packet) ? IPPROTO_TCP : IPPROTO_UDP;
  4029	    ip.ip_sum   = 0;
  4030	    ip.ip_src   = packet->saddr;
  4031	    ip.ip_dst   = packet->daddr;
  4032	
  4033	    ip.ip_sum   = cksum_ip(&ip);
  4034	
  4035	    /*printf("Debug - header length: %d\n", IP_HL(&ip));                    */
  4036	    /*printf("Debug - total length: %d(%d)\n", ip.ip_len, ntohs(ip.ip_len));*/
  4037	    /*printf("Debug - protocol: %d\n", ip.ip_p);                            */
  4038	    /*printf("Debug - src: %s\n", inet_ntoa(ip.ip_src));                    */
  4039	    /*printf("Debug - dst: %s\n", inet_ntoa(ip.ip_dst));                    */
  4040	
  4041	    /*add IP header*/
  4042	    buf = (u_char*)malloc(size_new);
  4043	    memcpy(buf, &ip, SIZE_IP);
  4044	    memcpy(buf+SIZE_IP, packet->buf, packet->size);
  4045	    free(packet->buf);          // do free() [1]
  4046	    packet->buf     = buf;      // to be free() [2]
  4047	    packet->size    = size_new;
  4048	
  4049	    packet->ept     = ETH_P_IP;
  4050	
  4051	    //encap_ether(handler, packet);
  4052	
  4053	    //CNetwork *network = CNetwork::instance();
  4054	    //network->send(packet);
  4055	    //CLink *link = CLink::instance();
  4056	    //link->send(packet);
  4057	
  4058	    delete packet->buf;         // do free() [2]
  4059	
  4060	}
  4061	
  4062	void encap_ether(pcap_t *handler, packet_t *packet)
  4063	{
  4064	    
  4065	    ethernethdr_t ether;
  4066	
  4067	    struct ether_addr *shost, *dhost;
  4068	
  4069	    const char *default_shost = "08:00:27:a8:01:cc";  // 192.168.0.5
  4070	    const char *default_dhost = "08:00:27:05:6e:fb";  // 192.168.0.3
  4071	
  4072	    u_char *buf;
  4073	    size_t size_new;
  4074	    uint32_t fcs;                   // frame check sequence
  4075	
  4076	    /*create Ethernet header*/
  4077	    ether.ether_type = htons(ETHERTYPE_IP);
  4078	
  4079	    //shost = ether_aton(default_shost);
  4080	    shost = ether_aton(default_shost);
  4081	    memcpy(ether.ether_shost, shost, ETHER_ADDR_LEN);
  4082	    //dhost = ether_aton(default_dhost);
  4083	    dhost = ether_aton(default_dhost);
  4084	    memcpy(ether.ether_dhost, dhost, ETHER_ADDR_LEN);
  4085	
  4086	    /*add Ethernet header*/
  4087	    size_new = SIZE_ETHERNET + packet->size + SIZE_ETHER_SUM;
  4088	    buf = (u_char*)malloc(size_new);
  4089	    memset(buf, 0, size_new);
  4090	    memcpy(buf, &ether, SIZE_ETHERNET);
  4091	    memcpy(buf+SIZE_ETHERNET, packet->buf, packet->size);
  4092	    fcs = 0;
  4093	    memcpy(buf+SIZE_ETHERNET+packet->size, &fcs, SIZE_ETHER_SUM);
  4094	
  4095	    free(packet->buf);          // do free() [2]
  4096	    packet->buf     = buf;      // to be free() [3]
  4097	    packet->size    = size_new;
  4098	
  4099	    //CHardware *hardware = CHardware::instance();
  4100	    //hardware->transmit(packet);
  4101	    //send_packet(handler, buf, size_new); 
  4102	
  4103	    free(packet->buf);          // do free() [3]
  4104	
  4105	}
  4106	
  4107	void handle_inject(pcap_t *handler, packet_t *packet)
  4108	{
  4109	
  4110	    if(INJECT_OP_TCP(packet)) {
  4111	        printf("\nInject with TCP...\n");
  4112	        encap_tcp(handler, packet);
  4113	    }
  4114	    else {
  4115	        printf("\nInject with UDP2...\n");
  4116	        encap_udp2(handler, packet);
  4117	    }
  4118	
  4119	}
  4120	
  4121	void handle_user_input(pcap_t * handler)
  4122	{
  4123	
  4124	    packet_t packet;                    // inject packet 
  4125	    char buf[SIZE_SEND_BUFFER], ch;     // temporary input buffer
  4126	    int count;                          // inject message character count
  4127	    char saddr[16], daddr[16];          // source & destination ip address
  4128	    uint16_t sport, dport;              // source & destination port
  4129	    char tmpstr[16];
  4130	
  4131	    const char *default_saddr = "192.168.0.5";
  4132	    default_saddr = inet_ntoa( CLink::instance()->getDefaultDevice()->ipAddr );
  4133	    //const char *default_daddr = "192.168.0.3";
  4134	    const char *default_daddr = "211.67.27.254";
  4135	    uint16_t default_sport = 1314;
  4136	    uint16_t default_dport = 1618;
  4137	
  4138	#if FRAGMENT_TEST==1
  4139	
  4140	    printf("\nUsed test string, length=%ld\n\n", sizeof(poem));
  4141	
  4142	    packet.buf = (unsigned char*)poem;
  4143	    packet.size = sizeof(poem);
  4144	
  4145	#else
  4146	
  4147	    /*Enter inject message */
  4148	    printf("\nEnter message to inject (ends with an empty line):\n"); 
  4149	    count = 0;
  4150	    while(1) {
  4151	        ch = getchar();
  4152	        if(count < SIZE_SEND_BUFFER) {
  4153	            buf[count] = ch;
  4154	        }
  4155	        else {
  4156	            printf("\n--maximum characters meeted (%d), end of input--\n", SIZE_SEND_BUFFER);
  4157	            break;
  4158	        }
  4159	
  4160	        if(count > 0 && ch == '\n' && buf[count-1] == '\n') {
  4161	            break;
  4162	        }
  4163	        ++count;
  4164	    }
  4165	    buf[count] = '\0';
  4166	    packet.buf = (u_char *)buf;
  4167	    packet.size = count;
  4168	
  4169	#endif
  4170	
  4171	    printf("**MESSAGE TO SEND**\n\n%s\n\n", packet.buf);
  4172	
  4173	    /*Determine inject protocol*/
  4174	    printf("Inject with TCP or UDP? [T/U]: "); 
  4175	    ch = getchar(); CLEAR();
  4176	    while (!(ch == 't' || ch == 'T' || ch == 'u' || ch == 'U')) {
  4177	        printf("Please enter T(t) or U(u): ");
  4178	        ch = getchar(); CLEAR();
  4179	    }
  4180	    packet.oper = ch;
  4181	
  4182	    /*Determine inject source & destination*/
  4183	    printf("Sender ip address (default %s, use it just press <enter>): ", default_saddr);
  4184	    ch = getchar();
  4185	    if(ch == '\n') {
  4186	        strncpy(saddr, default_saddr, SIZE_IP_ADDR_STR);    
  4187	    }
  4188	    else {
  4189	        saddr[0] = ch;
  4190	        fgets(saddr+1, SIZE_IP_ADDR_STR, stdin);
  4191	        saddr[strlen(saddr)-1] = '\0';          // eliminate the newline character
  4192	    }
  4193	
  4194	    printf("Sender port (default %d, use it just press <enter>): ", default_sport);
  4195	    ch = getchar();
  4196	    if(ch == '\n') {
  4197	        sport = default_sport;  
  4198	    }
  4199	    else {
  4200	        tmpstr[0] = ch;
  4201	        fgets(tmpstr+1, SIZE_PORT_STR, stdin);
  4202	        sport = atoi(tmpstr);
  4203	    }
  4204	
  4205	    printf("Destination ip address (default %s, use it just press <enter>): ", default_daddr);
  4206	    ch = getchar();
  4207	    if(ch == '\n') {
  4208	        strncpy(daddr, default_daddr, SIZE_IP_ADDR_STR);    
  4209	    }
  4210	    else {
  4211	        daddr[0] = ch;
  4212	        fgets(daddr+1, SIZE_IP_ADDR_STR, stdin);
  4213	        daddr[strlen(daddr)-1] = '\0';          // eliminate the newline character
  4214	    }
  4215	
  4216	    printf("Destination port (default %d, use it just press <enter>): ", default_dport);
  4217	    ch = getchar();
  4218	    if(ch == '\n') {
  4219	        dport = default_dport;  
  4220	    }
  4221	    else {
  4222	        tmpstr[0] = ch;
  4223	        fgets(tmpstr+1, SIZE_PORT_STR, stdin);
  4224	        dport = atoi(tmpstr);
  4225	    }
  4226	
  4227	    if( inet_aton(saddr, &packet.saddr) == 0) {
  4228	        fprintf(stderr, "Invalid source address: %s\n", saddr); 
  4229	        exit(EXIT_FAILURE);
  4230	    }
  4231	    if( inet_aton(daddr, &packet.daddr) == 0) {
  4232	        fprintf(stderr, "Invalid destination address: %s\n", daddr); 
  4233	        exit(EXIT_FAILURE);
  4234	    }
  4235	    packet.sport = sport;
  4236	    packet.dport = dport;
  4237	
  4238	    printf("\n%s:%d > %s:%d\n", saddr, packet.sport, daddr, packet.dport);
  4239	
  4240	    handle_inject(handler, &packet);
  4241	
  4242	}
  4243	
  4244	int main(int argc, char** argv) {
  4245	    //CHardware * hardware = CHardware::instance();
  4246	    //hardware->init();
  4247	    //CLink *link = CLink::instance();
  4248	    //link->init();
  4249	    CNetwork::instance()->init();
  4250	
  4251	    int k = 2;
  4252	    while (k-- > 0) {
  4253	        handle_user_input(nullptr);
  4254	
  4255	        sleep(2);
  4256	    }
  4257	
  4258	    return 0;
  4259	}
  4260	
  4261	/*
  4262	 * Compile: (path = $NETSIMUL/src/test)
  4263	 *
  4264	 * :!g++ % ../Util.cpp -I../include -o testUtil
  4265	 * */
  4266	#include "Util.h"
  4267	
  4268	int main()
  4269	{
  4270	    debug("Hi?\n");
  4271	    debug("Hi? %d\n", 7);
  4272	    debug("Hi? %d %d\n", 7, 17);
  4273	    return 0;
  4274	}
  4275	
  4276	/*
  4277	 * Simple ARP Sniffer.
  4278	 * To compile: g++ simple_arp_sniffer.cpp -o simple_arp_sniffer -lpcap
  4279	 * Run as root!
  4280	 * */
  4281	
  4282	#include <pcap.h>
  4283	#include <netinet/in.h>
  4284	#include <cstdlib>
  4285	#include <cstring>
  4286	
  4287	//ARP Header, (assuming Ethernet+IPv4)
  4288	#define ARP_REQUEST 1
  4289	#define ARP_REPLY 2
  4290	
  4291	typedef struct arphdr {
  4292	    u_int16_t htype;        // Hardware Type
  4293	    u_int16_t ptype;        // Protocol Type
  4294	    u_char hlen;            // Hardware Address Length
  4295	    u_char plen;            // Protocol Address Length
  4296	    u_int16_t oper;         // Operation Code
  4297	    u_char sha[6];          // Sender harder address
  4298	    u_char spa[4];          // Sender IP address
  4299	    u_char tha[6];          // Target harder address
  4300	    u_char tpa[4];          // Target IP address
  4301	} arphdr_t;
  4302	
  4303	#define MAXBYTES2CAPTURE 2048
  4304	
  4305	int main(int argc, char * argv[]) {
  4306	    int i = 0;
  4307	
  4308	    bpf_u_int32 netaddr = 0, mask = 0;  // To store network address and netmask
  4309	
  4310	    struct bpf_program filter;          // Place to store the BPF filter program
  4311	
  4312	    char errbuf[PCAP_ERRBUF_SIZE];      // Error buffer
  4313	
  4314	    pcap_t *descr = NULL;               // Network interface handler
  4315	
  4316	    struct pcap_pkthdr pkthdr;          // Packet information(timestamp,size...)
  4317	
  4318	    const unsigned char * packet = NULL;// Received raw data
  4319	
  4320	    arphdr_t * arpheader = NULL;        // Pointer to the ARP header
  4321	    memset(errbuf, 0, PCAP_ERRBUF_SIZE);
  4322	
  4323	    if(argc != 2) {
  4324	        printf("USAGE: simple_arp_sniffer <interface>\n");
  4325	        exit(1);
  4326	    }
  4327	
  4328	    // Open network device for packet capture
  4329	    descr = pcap_open_live(argv[1], MAXBYTES2CAPTURE, 0, -1, errbuf);
  4330	    //descr = pcap_open_live(argv[1], MAXBYTES2CAPTURE, 0, 512, errbuf);
  4331	    
  4332	    // Look up info from the capture device.
  4333	    pcap_lookupnet(argv[1], &netaddr, &mask, errbuf);
  4334	
  4335	    // Compiles the filter expression into a BPF filter program
  4336	    pcap_compile(descr, &filter, "arp", 1, mask);
  4337	
  4338	    // Load the filter program into the packet capture 
  4339	    pcap_setfilter(descr, &filter);
  4340	
  4341	    while(1) {
  4342	        // Get one packet
  4343	        packet = pcap_next(descr, &pkthdr);
  4344	
  4345	        // Point to the ARP header
  4346	        arpheader = (struct arphdr *)(packet + 14);
  4347	
  4348	        printf("\n\nReceived Packet Size: %d bytes\n", pkthdr.len);
  4349	        printf("Hardware type: %s\n", ((ntohs(arpheader->htype) == 1) ? "Ethernet" : "Unknown"));
  4350	        printf("Protocol type: %s\n", ((ntohs(arpheader->ptype) == 0x0800) ? "IPv4" : "Unknown"));
  4351	        printf("Operation: %s\n", ((ntohs(arpheader->oper) == ARP_REQUEST) ? "ARP Request" : "ARP Reply"));
  4352	
  4353	        //If is Ethernet and IPv4, print packet contents
  4354	        if( ntohs(arpheader->htype) == 1 && ntohs(arpheader->ptype) == 0x0800) {
  4355	            printf("Sender MAC: ");
  4356	            for(i=0; i<6 ; ++i)
  4357	                printf("%02X:", arpheader->sha[i]);
  4358	            printf("\nSender IP: ");
  4359	            for(i=0; i<4 ; ++i)
  4360	                printf("%d.", arpheader->spa[i]);
  4361	            printf("\nTarget MAC: ");
  4362	            for(i=0; i<6 ; ++i)
  4363	                printf("%02X:", arpheader->tha[i]);
  4364	            printf("\nTarget IP: ");
  4365	            for(i=0; i<4 ; ++i)
  4366	                printf("%d.", arpheader->tpa[i]);
  4367	            printf("\n");
  4368	        }
  4369	    }
  4370	
  4371	    return 0;
  4372	}
  4373	
  4374	
  4375	/*
  4376	 * DemoEchoClient - TCP Demo
  4377	 *
  4378	 * Send something like "hello" to echo server, print the reply.
  4379	 * */
  4380	#include <cstdio>
  4381	#include <cstring>
  4382	#include <string>
  4383	#include "Socket.h"
  4384	
  4385	const char * const cDstAddrStr  = "211.67.27.254";
  4386	const unsigned short cDstPort   = 2333;
  4387	
  4388	void usage(const char *appName) 
  4389	{
  4390	    printf("Default address use %s:%d\n", cDstAddrStr, cDstPort);
  4391	    printf("To change it use addtional parameters:\n\t%s <ip> <port>\n", appName);
  4392	    printf("\n----------\n\n");
  4393	}
  4394	
  4395	int main(int argc, char *argv[])
  4396	{
  4397	    usage(argv[0]);
  4398	
  4399	    // create a socket
  4400	    CSocket socket;
  4401	    int sockfd;
  4402	    if ( (sockfd = socket.socket(AF_INET, SOCK_STREAM, 0)) <= 0) { 
  4403	        fprintf(stderr, "Failed socket().\n");
  4404	        return -1;
  4405	    }
  4406	
  4407	    // set server address
  4408	    struct sockaddr_in svrAddr;
  4409	    svrAddr.sin_family = AF_INET;
  4410	
  4411	    char svrAddrStr[20];
  4412	    unsigned short svrPort;
  4413	
  4414	    strncpy(svrAddrStr, cDstAddrStr, strlen(cDstAddrStr) + 1);
  4415	    svrPort = cDstPort;
  4416	    if (argc > 1) {
  4417	        strncpy(svrAddrStr, argv[1], strlen(argv[1]) + 1);
  4418	    }
  4419	    if (argc > 2) {
  4420	        svrPort = std::stoi(argv[2]);
  4421	    }
  4422	
  4423	    if (inet_aton(svrAddrStr, &svrAddr.sin_addr) <= 0) {
  4424	        fprintf(stderr, "Invalid address: %s\n", svrAddrStr);
  4425	        return -1;
  4426	    }
  4427	    svrAddr.sin_port = htons(svrPort);
  4428	
  4429	    printf("Target %s:%d.\n", svrAddrStr, svrPort);
  4430	
  4431	    // connect
  4432	    printf("Connecting server...");
  4433	    int success = socket.connect((const sockaddr*)&svrAddr, sizeof(svrAddr));
  4434	
  4435	    if (success != -1) {
  4436	        // send
  4437	        printf("connected, will send 'hello'.\n");
  4438	        const char *text = "hello";
  4439	        int len = strlen(text);
  4440	        int byteSend = socket.send(text, len, 0);
  4441	
  4442	        if (byteSend > 0) {
  4443	            printf("Send out 'hello'.\n");
  4444	            char buf[1024 + 1];
  4445	            socklen_t socklen = sizeof(svrAddr);
  4446	            printf("Receiving...\n");
  4447	            int byteRecv = socket.recv(buf, 1024, 0);
  4448	
  4449	            if (byteRecv > 0) {
  4450	                buf[byteRecv] = '\0';
  4451	                printf("received: %s\n", buf);
  4452	            }
  4453	            else {
  4454	                printf("failed recv().\n");
  4455	            }
  4456	        }
  4457	        else {
  4458	            printf("Send out 'hello' failed.\n");
  4459	        }
  4460	
  4461	        socket.close();
  4462	    }
  4463	    else {
  4464	        printf("failed connect().\n");
  4465	    }
  4466	
  4467	    return 0;
  4468	
  4469	}
  4470	
  4471	/*
  4472	 * DemoEchoServer - TCP Demo
  4473	 *
  4474	 * Receive something from client and reply the same thing.
  4475	 * */
  4476	
  4477	#include "Socket.h"
  4478	#include <string>
  4479	#include <cstring>
  4480	#include <time.h>
  4481	
  4482	const int cPort = 2333;
  4483	const int cBufSize = 4096;
  4484	const int cBackLog = 10;
  4485	
  4486	int main(int argc, char* argv[])
  4487	{
  4488	    if (argc < 2) {
  4489	        printf("Usage: %s <ip> <port>.\n", argv[0]);
  4490	        return (0);
  4491	    }
  4492	
  4493	    int sockfd;
  4494	    struct sockaddr_in svrAddr;
  4495	    CSocket socket;
  4496	
  4497	    if ((sockfd = socket.socket(AF_INET, SOCK_STREAM, 0)) == -1) {
  4498	        printf("Failed socket().\n");
  4499	        return 0;
  4500	    }
  4501	
  4502	    svrAddr.sin_family = AF_INET;
  4503	    inet_aton(argv[1], &svrAddr.sin_addr);
  4504	
  4505	    if (argc > 2) {
  4506	        svrAddr.sin_port = htons(std::stoi(argv[2]));
  4507	    }
  4508	    else {
  4509	        svrAddr.sin_port = htons(cPort);
  4510	    }
  4511	
  4512	    // bind local address
  4513	    if (socket.bind((struct sockaddr*)&svrAddr, sizeof(struct sockaddr)) == -1) {
  4514	        fprintf(stderr, "Failed bind().\n");
  4515	        return 0;
  4516	    }
  4517	    else {
  4518	        printf("%s run with %s:%d.\n\n", argv[0], argv[1], ntohs(svrAddr.sin_port));
  4519	    }
  4520	
  4521	    // start listen 
  4522	    socket.listen(cBackLog);
  4523	
  4524	    struct sockaddr_in client;
  4525	    unsigned int addrlen = sizeof(client);
  4526	
  4527	    char buf[cBufSize];
  4528	    int k = 12;
  4529	    while (k-- > 0) {
  4530	        std::unique_ptr<CSocket> clientSocket = socket.accept((struct sockaddr*)&client, &addrlen);
  4531	
  4532	        if (clientSocket->getFD() > 0) {
  4533	            printf("Accepted a connection: %d, %s:%d.\n", clientSocket->getFD(),
  4534	                    inet_ntoa(client.sin_addr), ntohs(client.sin_port));
  4535	            int bytesRecv = clientSocket->recv(buf, cBufSize, 0);
  4536	            if (bytesRecv > 0) {
  4537	                // print received message
  4538	                buf[bytesRecv] = '\0';
  4539	                printf("Server received: %s.\n", buf);
  4540	
  4541	                // reply client
  4542	                clientSocket->send(buf, bytesRecv, 0);
  4543	                printf("Replied client: %s.\n", buf);
  4544	            }
  4545	            else {
  4546	                fprintf(stderr, "Server receive error, bytesRecv = %d.\n", bytesRecv);
  4547	            }
  4548	        }
  4549	        else {
  4550	            fprintf(stderr, "Failed accept connection.\n");
  4551	        }
  4552	
  4553	    }
  4554	
  4555	    return 0;
  4556	
  4557	}
  4558	
  4559	/*
  4560	 * Echo server.
  4561	 *
  4562	 * Repeat received message to client.
  4563	 *
  4564	 * date: Sat 11 Nov 2017 09:58:27 
  4565	 * */
  4566	#include <arpa/inet.h>
  4567	#include <netinet/ip.h>
  4568	#include <unistd.h>
  4569	#include <cstdio>
  4570	#include <cstdlib>
  4571	#include <cstring>
  4572	#include "echoapp.h"
  4573	
  4574	class CEchoServer {
  4575	    private:
  4576	        struct sockaddr_in _svraddr;
  4577	        int _svrsock;
  4578	        uint16_t _port;
  4579	
  4580	    public:
  4581	        CEchoServer() :
  4582	            _port(cDefaultPort)
  4583	        {
  4584	            init();
  4585	        }
  4586	        CEchoServer(uint16_t port) : 
  4587	            _port(port)
  4588	        {
  4589	            init();
  4590	        }
  4591	
  4592	        ~CEchoServer() 
  4593	        {
  4594	            close(_svrsock);
  4595	        }
  4596	
  4597	        void init();
  4598	        void run();
  4599	        void handleClient(const struct sockaddr_in *cliaddr, const char *msg, size_t bytes_recv);
  4600	
  4601	        static uint16_t cDefaultPort;
  4602	
  4603	};
  4604	
  4605	uint16_t CEchoServer::cDefaultPort = 1314;
  4606	
  4607	void CEchoServer::init() 
  4608	{
  4609	
  4610	    _svraddr.sin_family         = AF_INET;
  4611	    _svraddr.sin_port           = htons(_port);
  4612	    _svraddr.sin_addr.s_addr    = INADDR_ANY;
  4613	
  4614	    if( (_svrsock = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
  4615	        fprintf(stderr, "socket error.\n");
  4616	        exit(EXIT_FAILURE);
  4617	    }
  4618	
  4619	    if ( bind(_svrsock, (struct sockaddr *)&_svraddr, sizeof(_svraddr)) < 0 ) {
  4620	        fprintf(stderr, "bind socket address failed.\n");
  4621	        exit(EXIT_FAILURE);
  4622	    }
  4623	
  4624	}
  4625	
  4626	void CEchoServer::run()
  4627	{
  4628	
  4629	    char buf[cMaxBufSize];
  4630	    struct sockaddr_in cliaddr;
  4631	    socklen_t clilen = sizeof(cliaddr);         // this is important for the first time received ip address none zero.
  4632	    while(true) {
  4633	        int bytes_recv = recvfrom(_svrsock, buf, cMaxBufSize, 0, 
  4634	                (struct sockaddr *)&cliaddr, &clilen);
  4635	
  4636	        if(bytes_recv > 0) {
  4637	            buf[bytes_recv] = '\0';
  4638	            handleClient(&cliaddr, buf, bytes_recv);
  4639	        }
  4640	    }
  4641	
  4642	}
  4643	
  4644	void CEchoServer::handleClient(const struct sockaddr_in *cliaddr, const char *msg, size_t bytes_recv)
  4645	{
  4646	
  4647	    fprintf(stdout, "%s:%u > %s\n", inet_ntoa(cliaddr->sin_addr), ntohs(cliaddr->sin_port), msg);
  4648	
  4649	    int bytes_send = sendto(_svrsock, msg, bytes_recv, 0, 
  4650	            (const struct sockaddr *)cliaddr, sizeof(struct sockaddr_in)); 
  4651	    if(bytes_send <= 0) {
  4652	        fprintf(stderr, "reply to %s failed.\n", inet_ntoa(cliaddr->sin_addr));
  4653	    }
  4654	
  4655	}
  4656	
  4657	void print_usage() 
  4658	{
  4659	
  4660	    printf("Usage:\nechoserver <port>\n\n");
  4661	
  4662	}
  4663	
  4664	int main(int argc, char *argv[]) {
  4665	
  4666	    uint16_t port = CEchoServer::cDefaultPort;
  4667	    if(argc > 1) {
  4668	        port = atoi(argv[1]);
  4669	    }
  4670	
  4671	    CEchoServer echoserver(port);
  4672	    printf("echo server started at port %u.\n\n", port);
  4673	    echoserver.run();
  4674	    return 0;
  4675	}
  4676	
  4677	/*
  4678	 * Echo client
  4679	 *
  4680	 * Accept user's input, send to server, then display the reply.
  4681	 *
  4682	 * date: Sat 11 Nov 2017 11:32:15 
  4683	 * */
  4684	#include <arpa/inet.h>
  4685	#include <netinet/ip.h>
  4686	#include <unistd.h>
  4687	#include <cstdio>
  4688	#include <cstdlib>
  4689	#include <cstring>
  4690	#include "echoapp.h"
  4691	
  4692	class CEchoClient
  4693	{
  4694	    private:
  4695	        struct sockaddr_in _svraddr, _cliaddr; 
  4696	        int _clisock;
  4697	        const char *_svraddrstr;
  4698	        int _svrport, _cliport;
  4699	
  4700	    public:
  4701	        CEchoClient() :
  4702	            _svraddrstr(cDefaultSvrAddr), _svrport(cDefaultSvrPort)
  4703	        {
  4704	            init();
  4705	        }
  4706	
  4707	        CEchoClient(const char *svraddr, uint16_t svrport) :
  4708	            _svraddrstr(svraddr), _svrport(svrport)
  4709	        {
  4710	            init();
  4711	        }
  4712	
  4713	        ~CEchoClient()
  4714	        {
  4715	            close(_clisock);
  4716	        }
  4717	
  4718	        void init();
  4719	        void run();
  4720	
  4721	        static uint16_t cDefaultSvrPort;
  4722	        static const char *const cDefaultSvrAddr;
  4723	};
  4724	
  4725	uint16_t CEchoClient::cDefaultSvrPort = 1314;
  4726	const char *const CEchoClient::cDefaultSvrAddr = "127.0.0.1";
  4727	
  4728	void CEchoClient::init()
  4729	{
  4730	
  4731	    //create client socket
  4732	    if ( (_clisock = socket(AF_INET, SOCK_DGRAM, 0)) == -1 ) {
  4733	        fprintf(stderr, "socket error.\n");
  4734	        exit(EXIT_FAILURE);
  4735	    }
  4736	
  4737	    //set server address
  4738	    _svraddr.sin_family = AF_INET;
  4739	    if ( inet_aton(_svraddrstr, &_svraddr.sin_addr) == 0 ) {
  4740	        fprintf(stderr, "Invalid address: %s\n", _svraddrstr);
  4741	        exit(EXIT_FAILURE);
  4742	    }
  4743	    _svraddr.sin_port = htons(_svrport);
  4744	
  4745	}
  4746	
  4747	void CEchoClient::run() 
  4748	{
  4749	
  4750	    char buf[cMaxBufSize];
  4751	    socklen_t svraddrlen = sizeof(_svraddr);
  4752	    while (true) {
  4753	        printf("> ");
  4754	        fgets(buf, cMaxBufSize, stdin);
  4755	
  4756	        int bytes_send = sendto(_clisock, buf, strlen(buf), 0,
  4757	                (const struct sockaddr*)&_svraddr, sizeof(_svraddr));
  4758	        if(bytes_send > 0) {
  4759	            // send successfully, read reply
  4760	            int bytes_recv = recvfrom(_clisock, buf, cMaxBufSize, 0,
  4761	                    (struct sockaddr*)&_svraddr, &svraddrlen);
  4762	            if(bytes_recv > 0) {
  4763	                buf[bytes_recv] = '\0';
  4764	                printf("< %s\n", buf);
  4765	            }
  4766	            else {
  4767	                fprintf(stderr, "< receive failed.\n");
  4768	            }
  4769	        }
  4770	    }
  4771	
  4772	}
  4773	
  4774	void print_usage() 
  4775	{
  4776	
  4777	    printf("Usage:\nechoclient <server_ip> <server_port>\n\n");
  4778	
  4779	}
  4780	
  4781	int main(int argc, char *argv[]) { 
  4782	
  4783	    const char *svraddr       = CEchoClient::cDefaultSvrAddr;
  4784	    uint16_t svrport    = CEchoClient::cDefaultSvrPort;
  4785	
  4786	    if(argc > 2) {
  4787	        svraddr = argv[1];
  4788	        svrport = atoi(argv[2]);
  4789	    }
  4790	    else if(argc > 1) {
  4791	        svraddr = argv[1];
  4792	    }
  4793	    else {
  4794	        fprintf(stdout, "Use default address and port.\n");
  4795	    }
  4796	
  4797	    printf("Server %s:%u\n", svraddr, svrport);
  4798	    printf("Enter message to echo.\n\n");
  4799	
  4800	    CEchoClient echoclient(svraddr, svrport);
  4801	    echoclient.run();
  4802	
  4803	    return 0;
  4804	}
  4805	
  4806	
  4807	
  4808	#ifndef ECHO_APP_H_
  4809	#define ECHO_APP_H_
  4810	
  4811	// 
  4812	const int cMaxBufSize   = 1024;
  4813	
  4814	
  4815	#endif 
  4816	
  4817	#include <pcap.h>
  4818	#include <cstring>
  4819	#include <cstdlib>
  4820	#include <cctype>
  4821	
  4822	#define MAXBYTES2CAPTURE 2048
  4823	
  4824	void processPacket(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet) {
  4825	    int i = 0, *counter = (int *)arg;
  4826	
  4827	    printf("Packet Count: %d\n", ++(*counter));
  4828	    printf("Received Packet Size: %d\n", pkthdr->len);
  4829	    printf("Payload:\n");
  4830	
  4831	    for(i = 0; i < pkthdr->len ; ++i) {
  4832	        if(isprint(packet[i])) 
  4833	            printf("%c ", packet[i]);
  4834	        else 
  4835	            printf(". ");
  4836	
  4837	        if( (i % 16 == 0 && i != 0) || i == pkthdr->len-1 )
  4838	            printf("\n");
  4839	    }
  4840	}
  4841	
  4842	int main(int argc, char * argv[]) {
  4843	    int i = 0, count = 0, dlt = 0;
  4844	    pcap_t *descr = NULL;
  4845	    char errbuf[PCAP_ERRBUF_SIZE], *device = NULL;
  4846	    memset(errbuf, 0, PCAP_ERRBUF_SIZE);
  4847	
  4848	    //Get the name of the first device suitable for capture
  4849	    device = pcap_lookupdev(errbuf);
  4850	
  4851	    printf("Opening device: %s\n", device);
  4852	
  4853	    //Open device in promiscuous mode
  4854	    descr = pcap_open_live(device, MAXBYTES2CAPTURE, 1, 512, errbuf);
  4855	
  4856	    // Check datalink type
  4857	    dlt = pcap_datalink(descr);
  4858	    printf("DLT: %s\n", (dlt == DLT_EN10MB ? "DLT_EN10MB" : "Unknown"));
  4859	
  4860	    //Loop forever & call processPacket() for every received packet
  4861	    pcap_loop(descr, -1, processPacket, (u_char *)&count);
  4862	
  4863	    return 0;
  4864	}
  4865	/*
  4866	 * sniffex.c
  4867	 *
  4868	 * Sniffer example of TCP/IP packet capture using libpcap.
  4869	 * 
  4870	 * Version 0.1.1 (2005-07-05)
  4871	 * Copyright (c) 2005 The Tcpdump Group
  4872	 *
  4873	 * This software is intended to be used as a practical example and 
  4874	 * demonstration of the libpcap library; available at:
  4875	 * http://www.tcpdump.org/
  4876	 *
  4877	 ****************************************************************************
  4878	 *
  4879	 * This software is a modification of Tim Carstens' "sniffer.c"
  4880	 * demonstration source code, released as follows:
  4881	 * 
  4882	 * sniffer.c
  4883	 * Copyright (c) 2002 Tim Carstens
  4884	 * 2002-01-07
  4885	 * Demonstration of using libpcap
  4886	 * timcarst -at- yahoo -dot- com
  4887	 * 
  4888	 * "sniffer.c" is distributed under these terms:
  4889	 * 
  4890	 * Redistribution and use in source and binary forms, with or without
  4891	 * modification, are permitted provided that the following conditions
  4892	 * are met:
  4893	 * 1. Redistributions of source code must retain the above copyright
  4894	 *    notice, this list of conditions and the following disclaimer.
  4895	 * 2. Redistributions in binary form must reproduce the above copyright
  4896	 *    notice, this list of conditions and the following disclaimer in the
  4897	 *    documentation and/or other materials provided with the distribution.
  4898	 * 4. The name "Tim Carstens" may not be used to endorse or promote
  4899	 *    products derived from this software without prior written permission
  4900	 *
  4901	 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  4902	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  4903	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  4904	 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  4905	 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  4906	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  4907	 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  4908	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  4909	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  4910	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  4911	 * SUCH DAMAGE.
  4912	 * <end of "sniffer.c" terms>
  4913	 *
  4914	 * This software, "sniffex.c", is a derivative work of "sniffer.c" and is
  4915	 * covered by the following terms:
  4916	 *
  4917	 * Redistribution and use in source and binary forms, with or without
  4918	 * modification, are permitted provided that the following conditions
  4919	 * are met:
  4920	 * 1. Because this is a derivative work, you must comply with the "sniffer.c"
  4921	 *    terms reproduced above.
  4922	 * 2. Redistributions of source code must retain the Tcpdump Group copyright
  4923	 *    notice at the top of this source file, this list of conditions and the
  4924	 *    following disclaimer.
  4925	 * 3. Redistributions in binary form must reproduce the above copyright
  4926	 *    notice, this list of conditions and the following disclaimer in the
  4927	 *    documentation and/or other materials provided with the distribution.
  4928	 * 4. The names "tcpdump" or "libpcap" may not be used to endorse or promote
  4929	 *    products derived from this software without prior written permission.
  4930	 *
  4931	 * THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.
  4932	 * BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  4933	 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
  4934	 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  4935	 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
  4936	 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  4937	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
  4938	 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
  4939	 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
  4940	 * REPAIR OR CORRECTION.
  4941	 * 
  4942	 * IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  4943	 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  4944	 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
  4945	 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
  4946	 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
  4947	 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
  4948	 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
  4949	 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
  4950	 * POSSIBILITY OF SUCH DAMAGES.
  4951	 * <end of "sniffex.c" terms>
  4952	 * 
  4953	 ****************************************************************************
  4954	 *
  4955	 * Below is an excerpt from an email from Guy Harris on the tcpdump-workers
  4956	 * mail list when someone asked, "How do I get the length of the TCP
  4957	 * payload?" Guy Harris' slightly snipped response (edited by him to
  4958	 * speak of the IPv4 header length and TCP data offset without referring
  4959	 * to bitfield structure members) is reproduced below:
  4960	 * 
  4961	 * The Ethernet size is always 14 bytes.
  4962	 * 
  4963	 * <snip>...</snip>
  4964	 *
  4965	 * In fact, you *MUST* assume the Ethernet header is 14 bytes, *and*, if 
  4966	 * you're using structures, you must use structures where the members 
  4967	 * always have the same size on all platforms, because the sizes of the 
  4968	 * fields in Ethernet - and IP, and TCP, and... - headers are defined by 
  4969	 * the protocol specification, not by the way a particular platform's C 
  4970	 * compiler works.)
  4971	 *
  4972	 * The IP header size, in bytes, is the value of the IP header length,
  4973	 * as extracted from the "ip_vhl" field of "struct sniff_ip" with
  4974	 * the "IP_HL()" macro, times 4 ("times 4" because it's in units of
  4975	 * 4-byte words).  If that value is less than 20 - i.e., if the value
  4976	 * extracted with "IP_HL()" is less than 5 - you have a malformed
  4977	 * IP datagram.
  4978	 *
  4979	 * The TCP header size, in bytes, is the value of the TCP data offset,
  4980	 * as extracted from the "th_offx2" field of "struct sniff_tcp" with
  4981	 * the "TH_OFF()" macro, times 4 (for the same reason - 4-byte words).
  4982	 * If that value is less than 20 - i.e., if the value extracted with
  4983	 * "TH_OFF()" is less than 5 - you have a malformed TCP segment.
  4984	 *
  4985	 * So, to find the IP header in an Ethernet packet, look 14 bytes after 
  4986	 * the beginning of the packet data.  To find the TCP header, look 
  4987	 * "IP_HL(ip)*4" bytes after the beginning of the IP header.  To find the
  4988	 * TCP payload, look "TH_OFF(tcp)*4" bytes after the beginning of the TCP
  4989	 * header.
  4990	 * 
  4991	 * To find out how much payload there is:
  4992	 *
  4993	 * Take the IP *total* length field - "ip_len" in "struct sniff_ip" 
  4994	 * - and, first, check whether it's less than "IP_HL(ip)*4" (after
  4995	 * you've checked whether "IP_HL(ip)" is >= 5).  If it is, you have
  4996	 * a malformed IP datagram.
  4997	 *
  4998	 * Otherwise, subtract "IP_HL(ip)*4" from it; that gives you the length
  4999	 * of the TCP segment, including the TCP header.  If that's less than
  5000	 * "TH_OFF(tcp)*4" (after you've checked whether "TH_OFF(tcp)" is >= 5),
  5001	 * you have a malformed TCP segment.
  5002	 *
  5003	 * Otherwise, subtract "TH_OFF(tcp)*4" from it; that gives you the
  5004	 * length of the TCP payload.
  5005	 *
  5006	 * Note that you also need to make sure that you don't go past the end 
  5007	 * of the captured data in the packet - you might, for example, have a 
  5008	 * 15-byte Ethernet packet that claims to contain an IP datagram, but if 
  5009	 * it's 15 bytes, it has only one byte of Ethernet payload, which is too 
  5010	 * small for an IP header.  The length of the captured data is given in 
  5011	 * the "caplen" field in the "struct pcap_pkthdr"; it might be less than 
  5012	 * the length of the packet, if you're capturing with a snapshot length 
  5013	 * other than a value >= the maximum packet size.
  5014	 * <end of response>
  5015	 * 
  5016	 ****************************************************************************
  5017	 * 
  5018	 * Example compiler command-line for GCC:
  5019	 *   gcc -Wall -o sniffex sniffex.c -lpcap
  5020	 * 
  5021	 ****************************************************************************
  5022	 *
  5023	 * Code Comments
  5024	 *
  5025	 * This section contains additional information and explanations regarding
  5026	 * comments in the source code. It serves as documentaion and rationale
  5027	 * for why the code is written as it is without hindering readability, as it
  5028	 * might if it were placed along with the actual code inline. References in
  5029	 * the code appear as footnote notation (e.g. [1]).
  5030	 *
  5031	 * 1. Ethernet headers are always exactly 14 bytes, so we define this
  5032	 * explicitly with "#define". Since some compilers might pad structures to a
  5033	 * multiple of 4 bytes - some versions of GCC for ARM may do this -
  5034	 * "sizeof (struct sniff_ethernet)" isn't used.
  5035	 * 
  5036	 * 2. Check the link-layer type of the device that's being opened to make
  5037	 * sure it's Ethernet, since that's all we handle in this example. Other
  5038	 * link-layer types may have different length headers (see [1]).
  5039	 *
  5040	 * 3. This is the filter expression that tells libpcap which packets we're
  5041	 * interested in (i.e. which packets to capture). Since this source example
  5042	 * focuses on IP and TCP, we use the expression "ip", so we know we'll only
  5043	 * encounter IP packets. The capture filter syntax, along with some
  5044	 * examples, is documented in the tcpdump man page under "expression."
  5045	 * Below are a few simple examples:
  5046	 *
  5047	 * Expression			Description
  5048	 * ----------			-----------
  5049	 * ip					Capture all IP packets.
  5050	 * tcp					Capture only TCP packets.
  5051	 * tcp port 80			Capture only TCP packets with a port equal to 80.
  5052	 * ip host 10.1.2.3		Capture all IP packets to or from host 10.1.2.3.
  5053	 *
  5054	 ****************************************************************************
  5055	 *
  5056	 */
  5057	
  5058	#define APP_NAME		"sniffex"
  5059	#define APP_DESC		"Sniffer example using libpcap"
  5060	#define APP_COPYRIGHT	"Copyright (c) 2005 The Tcpdump Group"
  5061	#define APP_DISCLAIMER	"THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM."
  5062	
  5063	#include <pcap.h>
  5064	#include <stdio.h>
  5065	#include <string.h>
  5066	#include <stdlib.h>
  5067	#include <ctype.h>
  5068	#include <errno.h>
  5069	#include <sys/types.h>
  5070	#include <sys/socket.h>
  5071	#include <netinet/in.h>
  5072	#include <netinet/ether.h>
  5073	#include <netinet/ip_icmp.h>
  5074	#include <arpa/inet.h>
  5075	
  5076	#include "ether.h"
  5077	#include "ip_arp.h"
  5078	#include "ip.h"
  5079	#include "tcp.h"
  5080	#include "udp.h"
  5081	#include "icmp.h"
  5082	#include "netsimul.h"
  5083	
  5084	const tok_t ethertype_values[] = {
  5085	    {ETHERTYPE_IP,          "IPv4"},
  5086	    {ETHERTYPE_ARP,         "ARP"},
  5087	    {ETHERTYPE_REVARP,      "RARP"},
  5088	    {ETHERTYPE_IPV6,        "IPv6"},
  5089	    {ETHERTYPE_LOOPBACK,    "Loopback"},
  5090	    {0, NULL}
  5091	};
  5092	
  5093	const tok_t icmptype_values[] = {
  5094	    {ICMP_ECHOREPLY          , "Echo Reply"},      
  5095	    {ICMP_DEST_UNREACH       , "Destination Unreachable"},      
  5096	    {ICMP_SOURCE_QUENCH      , "Source Quench"},      
  5097	    {ICMP_REDIRECT           , "Redirect (change route)"},      
  5098	    {ICMP_ECHO               , "Echo Request"},      
  5099	    {ICMP_TIME_EXCEEDED      , "Time Exceeded"},      
  5100	    {ICMP_PARAMETERPROB      , "Parameter Problem"},      
  5101	    {ICMP_TIMESTAMP          , "Timestamp Request"},      
  5102	    {ICMP_TIMESTAMPREPLY     , "Timestamp Reply"},      
  5103	    {ICMP_INFO_REQUEST       , "Information Request"},      
  5104	    {ICMP_INFO_REPLY         , "Information Reply"},      
  5105	    {ICMP_ADDRESS            , "Address Mask Request"},      
  5106	    {ICMP_ADDRESSREPLY       , "Address Mask Reply"},      
  5107	    {0, NULL}
  5108	};
  5109	
  5110	const tok_t icmpcode_values[] = {
  5111	    {0, NULL}
  5112	};
  5113	
  5114	void
  5115	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);
  5116	
  5117	void
  5118	print_payload(const u_char *payload, int len);
  5119	
  5120	void
  5121	print_hex_ascii_line(const u_char *payload, int len, int offset);
  5122	
  5123	void
  5124	print_app_banner(void);
  5125	
  5126	void
  5127	print_app_usage(void);
  5128	
  5129	void print_ether(const struct sniff_ethernet * ethernet);
  5130	
  5131	void print_arp(const struct sniff_arp * arp);
  5132	
  5133	const char * tok2str(const tok_t * tokp,
  5134	        const char * default_msg,
  5135	        int v)
  5136	{
  5137	
  5138	    static char buf[SIZE_TOK_BUF];
  5139	
  5140	    if(tokp != NULL) {
  5141	        while(tokp->s != NULL) {
  5142	            if(tokp->v == v)
  5143	                return tokp->s;
  5144	            else 
  5145	                ++tokp;
  5146	        }
  5147	    }
  5148	
  5149	    snprintf(buf, SIZE_TOK_BUF, "%s", default_msg);
  5150	    return (const char *)buf;
  5151	}
  5152	
  5153	/*
  5154	 * app name/banner
  5155	 */
  5156	void
  5157	print_app_banner(void)
  5158	{
  5159	
  5160		printf("%s - %s\n", APP_NAME, APP_DESC);
  5161		printf("%s\n", APP_COPYRIGHT);
  5162		printf("%s\n", APP_DISCLAIMER);
  5163		printf("\n");
  5164	
  5165	return;
  5166	}
  5167	
  5168	/*
  5169	 * print help text
  5170	 */
  5171	void
  5172	print_app_usage(void)
  5173	{
  5174	
  5175		printf("Usage: %s [interface]\n", APP_NAME);
  5176		printf("\n");
  5177		printf("Options:\n");
  5178		printf("    interface    Listen on <interface> for packets.\n");
  5179		printf("\n");
  5180	
  5181	return;
  5182	}
  5183	
  5184	/*
  5185	 * print data in rows of 16 bytes: offset   hex   ascii
  5186	 *
  5187	 * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
  5188	 */
  5189	void
  5190	print_hex_ascii_line(const u_char *payload, int len, int offset)
  5191	{
  5192	
  5193		int i;
  5194		int gap;
  5195		const u_char *ch;
  5196	
  5197		/* offset */
  5198		printf("%05d   ", offset);
  5199		
  5200		/* hex */
  5201		ch = payload;
  5202		for(i = 0; i < len; i++) {
  5203			printf("%02x ", *ch);
  5204			ch++;
  5205			/* print extra space after 8th byte for visual aid */
  5206			if (i == 7)
  5207				printf(" ");
  5208		}
  5209		/* print space to handle line less than 8 bytes */
  5210		if (len < 8)
  5211			printf(" ");
  5212		
  5213		/* fill hex gap with spaces if not full line */
  5214		if (len < 16) {
  5215			gap = 16 - len;
  5216			for (i = 0; i < gap; i++) {
  5217				printf("   ");
  5218			}
  5219		}
  5220		printf("   ");
  5221		
  5222		/* ascii (if printable) */
  5223		ch = payload;
  5224		for(i = 0; i < len; i++) {
  5225			if (isprint(*ch))
  5226				printf("%c", *ch);
  5227			else
  5228				printf(".");
  5229			ch++;
  5230		}
  5231	
  5232		printf("\n");
  5233	
  5234	return;
  5235	}
  5236	
  5237	/*
  5238	 * print packet payload data (avoid printing binary data)
  5239	 */
  5240	void
  5241	print_payload(const u_char *payload, int len)
  5242	{
  5243	
  5244		int len_rem = len;
  5245		int line_width = 16;			/* number of bytes per line */
  5246		int line_len;
  5247		int offset = 0;					/* zero-based offset counter */
  5248		const u_char *ch = payload;
  5249	
  5250		if (len <= 0)
  5251			return;
  5252	
  5253		/* data fits on one line */
  5254		if (len <= line_width) {
  5255			print_hex_ascii_line(ch, len, offset);
  5256			return;
  5257		}
  5258	
  5259		/* data spans multiple lines */
  5260		for ( ;; ) {
  5261			/* compute current line length */
  5262			line_len = line_width % len_rem;
  5263			/* print line */
  5264			print_hex_ascii_line(ch, line_len, offset);
  5265			/* compute total remaining */
  5266			len_rem = len_rem - line_len;
  5267			/* shift pointer to remaining bytes to print */
  5268			ch = ch + line_len;
  5269			/* add offset */
  5270			offset = offset + line_width;
  5271			/* check if we have line width chars or less */
  5272			if (len_rem <= line_width) {
  5273				/* print last line and get out */
  5274				print_hex_ascii_line(ch, len_rem, offset);
  5275				break;
  5276			}
  5277		}
  5278	
  5279	return;
  5280	}
  5281	
  5282	/*
  5283	 * Print ethernet structure informations
  5284	 *
  5285	 * Append by BDG, Wed 08 Nov 2017 10:56:22 
  5286	 * */
  5287	void print_ether(const struct sniff_ethernet * ethernet)
  5288	{
  5289	
  5290	    u_short ether_type = 0;                 // Ethertype value
  5291	
  5292	    const char * etherstr = NULL;           // Ethertype string
  5293	
  5294	    // Ether dst & src
  5295	    char dst[MAC_ASCII_LEN], src[MAC_ASCII_LEN], *tmp = NULL;          
  5296	    
  5297	    ether_type = ntohs(ethernet->ether_type);
  5298	    printf("Network Layer Protocol: %s (%4X)", tok2str(ethertype_values, "Unknown", ether_type),ether_type );
  5299	
  5300	    /*etherstr = get_ethertype_by_value(ether_type);*/
  5301	    /*if(etherstr != NULL) {*/
  5302	        /*printf("%s", etherstr);*/
  5303	    /*}*/
  5304	    /*else {*/
  5305	        /*printf("Unknown(%0004X)", ether_type);*/
  5306	    /*}*/
  5307	    /*
  5308	     * The ether_ntoa() function converts the Ethernet host address addr given in network byte order to a string
  5309	     * in standard hex-digits-and-colons notation, omitting leading zeros. The string is returned in a statically
  5310	     * allocated buffer, which subsequent calls will overwrite.
  5311	     * */
  5312	    tmp = ether_ntoa((const struct ether_addr*)&ethernet->ether_dhost);
  5313	    strncpy(dst, tmp, MAC_ASCII_LEN);
  5314	    tmp = ether_ntoa((const struct ether_addr*)&ethernet->ether_shost);
  5315	    strncpy(src, tmp, MAC_ASCII_LEN);
  5316	    printf("\n     Source: %s\nDestination: %s\n", src, dst);
  5317	
  5318	}
  5319	
  5320	/*
  5321	 * Print ARP header
  5322	 * */
  5323	void print_arp(const struct sniff_arp * arp)
  5324	{
  5325	
  5326	    int i;
  5327	
  5328	    printf("Hardware type: %s\n", ((ntohs(arp->htype) == 1) ? "Ethernet" : "Unknown"));
  5329	    printf("Protocol type: %s\n", ((ntohs(arp->ptype) == 0x0800) ? "IPv4" : "Unknown"));
  5330	    printf("Operation: %s\n", ((ntohs(arp->oper) == ARPOP_REQUEST) ? "ARP Request" : "ARP Reply"));
  5331	
  5332	    //If is Ethernet and IPv4, print packet contents
  5333	    if( ntohs(arp->htype) == 1 && ntohs(arp->ptype) == 0x0800) {
  5334	        printf("Sender MAC: ");
  5335	        for(i=0; i<6 ; ++i)
  5336	            printf("%02X:", arp->sha[i]);
  5337	        printf("\nSender IP: ");
  5338	        struct in_addr spa; 
  5339	        spa.s_addr = arp->spa;
  5340	        printf("%s", inet_ntoa(spa));
  5341	        /*for(i=0; i<4 ; ++i)*/
  5342	            /*printf("%d.", arp->spa[i]);*/
  5343	        printf("\nTarget MAC: ");
  5344	        for(i=0; i<6 ; ++i)
  5345	            printf("%02X:", arp->tha[i]);
  5346	        printf("\nTarget IP: ");
  5347	        struct in_addr tpa;
  5348	        tpa.s_addr = arp->tpa;
  5349	        printf("%s", inet_ntoa(tpa));
  5350	        /*for(i=0; i<4 ; ++i)*/
  5351	            /*printf("%d.", arp->tpa[i]);*/
  5352	        printf("\n");
  5353	    }
  5354	
  5355	}
  5356	
  5357	void print_tcp(const struct sniff_tcp * tcp, 
  5358	        const struct sniff_ip * ip,
  5359	        const u_char * packet)
  5360	{
  5361	
  5362	    const char *payload;                    /* Packet payload */
  5363	
  5364	    int size_ip = IP_HL(ip)*4;
  5365	    int size_tcp = TH_OFF(tcp)*4;
  5366	    int size_payload;
  5367	
  5368	    printf("   Src port: %d\n", ntohs(tcp->th_sport));
  5369	    printf("   Dst port: %d\n", ntohs(tcp->th_dport));
  5370	    
  5371	    /* define/compute tcp payload (segment) offset */
  5372	    //payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
  5373	    payload = (const char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
  5374	    
  5375	    /* compute tcp payload (segment) size */
  5376	    size_payload = ntohs(ip->ip_len) - (size_ip + size_tcp);
  5377	    
  5378	    /*
  5379	     * Print payload data; it might be binary, so don't just
  5380	     * treat it as a string.
  5381	     */
  5382	    printf("   Payload (%d bytes):\n", size_payload);
  5383	    if (size_payload > 0) {
  5384	            /*printf("   Payload (%d bytes):\n", size_payload);*/
  5385	            //print_payload(payload, size_payload);
  5386	    	print_payload((const unsigned char*)payload, size_payload);
  5387	    }
  5388	
  5389	}
  5390	
  5391	void print_udp(const struct sniff_udp * udp,
  5392	        const struct sniff_ip * ip,
  5393	        const u_char * packet)
  5394	{
  5395	
  5396	    const char * payload;
  5397	
  5398	    int size_ip = IP_HL(ip)*4;
  5399	    int size_udp = 8;
  5400	    int size_payload;
  5401	
  5402	    printf("    Src port: %d\n", ntohs(udp->uh_sport));
  5403	    printf("    Dst port: %d\n", ntohs(udp->uh_dport));
  5404	
  5405	    //payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_udp);
  5406	    payload = (const char *)(packet + SIZE_ETHERNET + size_ip + size_udp);
  5407	
  5408	    size_payload = ntohs(udp->uh_len) - size_udp;
  5409	
  5410	    printf("    Payload (%d bytes):\n", size_payload);
  5411	    if(size_payload > 0) {
  5412	        //print_payload(payload, size_payload);
  5413	        print_payload((const u_char*)payload, size_payload);
  5414	    }
  5415	
  5416	}
  5417	
  5418	void print_icmp(const struct sniff_icmp * icmp,
  5419	        const struct sniff_ip * ip,
  5420	        const u_char * packet)
  5421	{
  5422	
  5423	    uint8_t type;
  5424	    uint8_t code;
  5425	
  5426	    type = icmp->icmp_type;
  5427	    printf("Message Type: %s (%d)\n", tok2str(icmptype_values, "Unknown", type), type); 
  5428	
  5429	    code = icmp->icmp_code;
  5430	    printf("Message Code: %s (%d)\n", tok2str(icmpcode_values, "Unknown", code), code); 
  5431	
  5432	}
  5433	
  5434	/*
  5435	 * Handle ARP header
  5436	 * */
  5437	void handle_arp(const struct sniff_arp * arp)
  5438	{
  5439	
  5440	    print_arp(arp);
  5441	
  5442	}
  5443	
  5444	/*
  5445	 * Handle IP datagram
  5446	 * */
  5447	void handle_ip(const struct sniff_ip * ip,
  5448	        const struct pcap_pkthdr * header,
  5449	        const u_char * packet)
  5450	{
  5451	
  5452	    const struct sniff_tcp *tcp;            /* The TCP header */
  5453	    const struct sniff_udp *udp;            /* The UDP header */
  5454	    const struct sniff_icmp *icmp;          /* The ICMP header */
  5455	    const char *payload;                    /* Packet payload */
  5456	
  5457	    int size_ip = IP_HL(ip)*4;
  5458	    int size_tcp;
  5459	    int size_udp;
  5460	    int size_payload;
  5461	
  5462	    /* print source and destination IP addresses */
  5463	    printf("       From: %s\n", inet_ntoa(ip->ip_src));
  5464	    printf("         To: %s\n", inet_ntoa(ip->ip_dst));
  5465	    
  5466	    /* determine protocol */	
  5467	    switch(ip->ip_p) {
  5468	    	case IPPROTO_TCP:
  5469	    		printf("   Protocol: TCP\n");
  5470	                /* define/compute tcp header offset */
  5471	                tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
  5472	                size_tcp = TH_OFF(tcp)*4;
  5473	                if (size_tcp < 20) {
  5474	                    printf("   * Invalid TCP header length: %u bytes\n", size_tcp);
  5475	                }
  5476	                else {
  5477	                    print_tcp(tcp, ip, packet);
  5478	                }
  5479	    		break;
  5480	    	case IPPROTO_UDP:
  5481	    		printf("   Protocol: UDP\n");
  5482	                udp = (const udphdr_t*)(packet + SIZE_ETHERNET + size_ip);
  5483	                print_udp(udp, ip, packet);
  5484	    		return;
  5485	    	case IPPROTO_ICMP:
  5486	    		printf("   Protocol: ICMP\n");
  5487	                icmp = (const icmphdr_t *)(packet + SIZE_ETHERNET + size_ip);
  5488	                print_icmp(icmp, ip, packet);
  5489	    		break;
  5490	    	case IPPROTO_IP:
  5491	    		printf("   Protocol: IP\n");
  5492	    		return;
  5493	    	default:
  5494	    		printf("   Protocol: unknown\n");
  5495	    		return;
  5496	    }
  5497	    
  5498	}
  5499	
  5500	/* 
  5501	 * Handle ethernet packet
  5502	 * */
  5503	void handle_ether(const struct sniff_ethernet * ethernet,
  5504	        const struct pcap_pkthdr * header,
  5505	        const u_char * packet)
  5506	{
  5507	
  5508	    const struct sniff_arp *arp;            /* The ARP header */
  5509	    const struct sniff_ip *ip;              /* The IP header */
  5510	
  5511	    int size_ip;
  5512	
  5513	    u_short ether_type;
  5514		
  5515	    /* Print ethernet informations */
  5516	    print_ether(ethernet);
  5517	
  5518	    /* Handle packet according to ether_type */
  5519	    ether_type = ntohs(ethernet->ether_type);
  5520	    switch(ether_type) {
  5521	        case ETHERTYPE_ARP: {
  5522	                                arp = (const struct sniff_arp*)(packet + SIZE_ETHERNET);
  5523	                                handle_arp(arp);
  5524	                                break;
  5525	                            }
  5526	        case ETHERTYPE_REVARP: { break; }
  5527	        case ETHERTYPE_IP: {
  5528	                                /* define/compute ip header offset */
  5529	                                ip = (const struct sniff_ip*)(packet + SIZE_ETHERNET);
  5530	                                size_ip = IP_HL(ip)*4;
  5531	                                if (size_ip < 20) {
  5532	                                    printf("   * Invalid IP header length: %u bytes\n", size_ip);
  5533	                                }
  5534	                                else {
  5535	                                    handle_ip(ip, header, packet);
  5536	                                }
  5537	                                break;
  5538	                           }
  5539	        case ETHERTYPE_IPV6: { break; }
  5540	        case ETHERTYPE_LOOPBACK: { break; }
  5541	        default:
  5542	                                 break;
  5543	    }
  5544		
  5545	    /*ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);*/
  5546	    /*size_ip = IP_HL(ip)*4;*/
  5547	    /*if (size_ip < 20) {*/
  5548	            /*printf("   * Invalid IP header length: %u bytes\n", size_ip);*/
  5549	            /*return;*/
  5550	    /*}*/
  5551	
  5552	}
  5553	
  5554	/*
  5555	 * dissect/print packet
  5556	 */
  5557	void
  5558	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
  5559	{
  5560	
  5561		static int count = 1;                   /* packet counter */
  5562	
  5563		/* declare pointers to packet headers */
  5564		const struct sniff_ethernet *ethernet;  /* The ethernet header [1] */
  5565	
  5566		printf("\nPacket number %d:\n", count);
  5567		printf("Packet len: %d\n", header->len);
  5568		count++;
  5569		
  5570		/* define ethernet header */
  5571		ethernet = (struct sniff_ethernet*)(packet);
  5572	
  5573	        handle_ether(ethernet, header, packet);
  5574	
  5575	return;
  5576	}
  5577	
  5578	int main(int argc, char **argv)
  5579	{
  5580	
  5581		char *dev = NULL;			/* capture device name */
  5582		char errbuf[PCAP_ERRBUF_SIZE];		/* error buffer */
  5583		pcap_t *handle;				/* packet capture handle */
  5584	
  5585	        char filter_exp[] = "arp";		/* filter expression [3] */
  5586		/*char filter_exp[] = "";		[> filter expression [3] <]*/
  5587		struct bpf_program fp;			/* compiled filter program (expression) */
  5588		bpf_u_int32 mask;			/* subnet mask */
  5589		bpf_u_int32 net;			/* ip */
  5590		int num_packets = 10;			/* number of packets to capture */
  5591	
  5592		print_app_banner();
  5593	
  5594		/* check for capture device name on command-line */
  5595		if (argc == 2) {
  5596			dev = argv[1];
  5597		}
  5598		else if (argc > 2) {
  5599			fprintf(stderr, "error: unrecognized command-line options\n\n");
  5600			print_app_usage();
  5601			exit(EXIT_FAILURE);
  5602		}
  5603		else {
  5604			/* find a capture device if not specified on command-line */
  5605			dev = pcap_lookupdev(errbuf);
  5606			if (dev == NULL) {
  5607				fprintf(stderr, "Couldn't find default device: %s\n",
  5608				    errbuf);
  5609				exit(EXIT_FAILURE);
  5610			}
  5611		}
  5612		
  5613		/* get network number and mask associated with capture device */
  5614		if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
  5615			fprintf(stderr, "Couldn't get netmask for device %s: %s\n",
  5616			    dev, errbuf);
  5617			net = 0;
  5618			mask = 0;
  5619		}
  5620	
  5621		/* print capture info */
  5622		printf("Device: %s\n", dev);
  5623		printf("Number of packets: %d\n", num_packets);
  5624		printf("Filter expression: %s\n", filter_exp);
  5625	
  5626		/* open capture device */
  5627		handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
  5628		if (handle == NULL) {
  5629			fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
  5630			exit(EXIT_FAILURE);
  5631		}
  5632	
  5633		/* make sure we're capturing on an Ethernet device [2] */
  5634		if (pcap_datalink(handle) != DLT_EN10MB) {
  5635			fprintf(stderr, "%s is not an Ethernet\n", dev);
  5636			exit(EXIT_FAILURE);
  5637		}
  5638	
  5639		/* compile the filter expression */
  5640		if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
  5641			fprintf(stderr, "Couldn't parse filter %s: %s\n",
  5642			    filter_exp, pcap_geterr(handle));
  5643			exit(EXIT_FAILURE);
  5644		}
  5645	
  5646		/* apply the compiled filter */
  5647		if (pcap_setfilter(handle, &fp) == -1) {
  5648			fprintf(stderr, "Couldn't install filter %s: %s\n",
  5649			    filter_exp, pcap_geterr(handle));
  5650			exit(EXIT_FAILURE);
  5651		}
  5652	
  5653		/* now we can set our callback function */
  5654		pcap_loop(handle, num_packets, got_packet, NULL);
  5655	
  5656		/* cleanup */
  5657		pcap_freecode(&fp);
  5658		pcap_close(handle);
  5659	
  5660		printf("\nCapture complete.\n");
  5661	
  5662	return 0;
  5663	}
  5664	
  5665	/*
  5666	 * DemoTimeServer - UDP Demo
  5667	 *
  5668	 * Receive client message and reply current system time.
  5669	 * */
  5670	
  5671	#include "Socket.h"
  5672	#include <string>
  5673	#include <cstring>
  5674	#include <time.h>
  5675	
  5676	const int cPort = 1618;
  5677	const int cBufSize = 4096;
  5678	
  5679	int main(int argc, char* argv[])
  5680	{
  5681	    if (argc < 2) {
  5682	        printf("Usage: %s <ip> <port>.\n", argv[0]);
  5683	        return (0);
  5684	    }
  5685	
  5686	    int sockfd;
  5687	    struct sockaddr_in svrAddr;
  5688	    CSocket socket;
  5689	
  5690	    if ((sockfd = socket.socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
  5691	        printf("Failed socket().\n");
  5692	        return 0;
  5693	    }
  5694	
  5695	    svrAddr.sin_family = AF_INET;
  5696	    inet_aton(argv[1], &svrAddr.sin_addr);
  5697	
  5698	    if (argc > 2) {
  5699	        svrAddr.sin_port = htons(std::stoi(argv[2]));
  5700	    }
  5701	    else {
  5702	        svrAddr.sin_port = htons(cPort);
  5703	    }
  5704	
  5705	    if (socket.bind((struct sockaddr*)&svrAddr, sizeof(struct sockaddr)) == -1) {
  5706	        fprintf(stderr, "Failed bind().\n");
  5707	        return 0;
  5708	    }
  5709	    else {
  5710	        printf("%s run with %s:%d.\n\n", argv[0], argv[1], ntohs(svrAddr.sin_port));
  5711	    }
  5712	
  5713	    struct sockaddr_in client;
  5714	    unsigned int addrlen = sizeof(client);
  5715	
  5716	    char buf[cBufSize];
  5717	    while (true) {
  5718	        int bytesRecv = socket.recvfrom(buf, cBufSize, 0, (struct sockaddr*)&client, &addrlen);
  5719	        if (bytesRecv > 0) {
  5720	            // print received message
  5721	            buf[bytesRecv] = '\0';
  5722	            printf("Server received: %s.\n", buf);
  5723	
  5724	            // reply client
  5725	            time_t now = time(NULL);
  5726	            snprintf(buf, cBufSize, "%.24s\r\n", ctime(&now));
  5727	            socket.sendto(buf, strlen(buf), 0, (struct sockaddr*)&client, sizeof(struct sockaddr));
  5728	            printf("Replied current time.\n");
  5729	        }
  5730	        else {
  5731	            printf("Server receive error, bytesRecv = %d.\n", bytesRecv);
  5732	        }
  5733	    }
  5734	
  5735	    return 0;
  5736	
  5737	}
  5738	
  5739	#include "Socket.h"
  5740	#include <cstdio>
  5741	#include <cstdlib>
  5742	#include <cstring>
  5743	#include <unistd.h>
  5744	#include <errno.h>
  5745	#include <signal.h>
  5746	#include <sys/ipc.h> 
  5747	#include <sys/stat.h> 
  5748	#include <sys/shm.h> 
  5749	
  5750	#include "Util.h"
  5751	
  5752	#define TAG "<CSocket> "
  5753	
  5754	int sig;            // received signal
  5755	
  5756	void handler1(int signo)
  5757	{
  5758	    printf("Received signal SIGUSR1(%d).\n", signo);
  5759	    sig = signo;
  5760	}
  5761	
  5762	void handler2(int signo)
  5763	{
  5764	    sig = signo;
  5765	    printf("Received signal SIGUSR2(%d).\n", signo);
  5766	}
  5767	
  5768	int CSocket::waitForSuccess(int signo)
  5769	{
  5770	    pause();
  5771	
  5772	    int success;
  5773	    if (sig == signo) {
  5774	        success = *((int *)_pBlock->buf1);
  5775	    }
  5776	    else {
  5777	        success = -1;
  5778	    }
  5779	
  5780	    return success;
  5781	}
  5782	
  5783	
  5784	CSocket::CSocket()
  5785	{
  5786	    log(TAG "New socket created.\n");
  5787	    attachSharedMem();
  5788	}
  5789	
  5790	CSocket::~CSocket()
  5791	{
  5792	    close();
  5793	
  5794	    detachSharedMem();
  5795	    log(TAG "A socket destroied.\n");
  5796	}
  5797	
  5798	void CSocket::attachSharedMem()
  5799	{
  5800	    key_t key;          // shared memory key
  5801	    struct shmid_ds buf;
  5802	
  5803	    signal(SIGUSR1, handler1);          // SIGUSR1 for commands
  5804	    signal(SIGUSR2, handler2);          // SIGUSR2 for datas
  5805	
  5806	    // prepare a key 
  5807	    if ((key = ftok(cKeyPath, cKeyID)) == -1) {
  5808	        printf("Failed ftok().\n");
  5809	    }
  5810	
  5811	    // try attach Protocol process created shared memory
  5812	    if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | IPC_EXCL)) == -1) {
  5813	        if (errno == EEXIST) {
  5814	            if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | S_IRUSR | S_IWUSR)) == -1) {
  5815	                printf("Failed shmget(): %s.\n", strerror(errno));
  5816	                exit(EXIT_FAILURE);
  5817	            }
  5818	            else {
  5819	                printf("Success attach shared memory %d.\n", _shmid);
  5820	            }
  5821	        }
  5822	        else {
  5823	            // no shared memory exist, maybe Protocol not started, exit...
  5824	            fprintf(stderr, "Unable to attach shared memory.\n");
  5825	            exit(0);
  5826	        }
  5827	    }
  5828	    else {
  5829	        if (shmctl(_shmid, IPC_RMID, 0) == -1) {
  5830	            printf("Failed shmctl(): %s.\n", strerror(errno));
  5831	        }
  5832	        printf("Protocol not started, quit...\n");
  5833	        exit(0);
  5834	    }
  5835	
  5836	    // get shared memory address
  5837	    if ((_pBlock = (SharedBlock *)shmat(_shmid, 0, 0)) == (void *)-1) {
  5838	        printf("Failed shmat(): %s.\n", strerror(errno));
  5839	    }
  5840	    printf("pBlock: %p, pBlock->buf1: %p, pBlock->buf2: %p\n", _pBlock, _pBlock->buf1, _pBlock->buf2);
  5841	
  5842	    // get created process id
  5843	    if (shmctl(_shmid, IPC_STAT, &buf) == -1) {
  5844	        printf("Failed shmctl().\n");
  5845	    }
  5846	    else {
  5847	        printf("Protocol process: %d.\n", buf.shm_cpid);
  5848	        _protoPid = buf.shm_cpid;
  5849	    }
  5850	
  5851	    // do work here
  5852	    //printf("Shared: %s\n", _pBlock->buf1);
  5853	    //kill(buf.shm_cpid, SIGUSR1);
  5854	}
  5855	
  5856	void CSocket::detachSharedMem()
  5857	{
  5858	    if (shmdt(_pBlock) == -1) {
  5859	        printf("Failed shmdt(): %s.\n", strerror(errno));
  5860	    }
  5861	}
  5862	
  5863	int CSocket::init(int family, int type, int protocol)
  5864	{
  5865	    _sock.pid       = getpid();
  5866	    _sock.sockfd    = _sock.pid;
  5867	    _sock.family    = family;
  5868	    _sock.type      = type;
  5869	    _sock.protocol  = protocol;
  5870	
  5871	    _sock.addr.s_addr   = 0;
  5872	    _sock.port          = 0;
  5873	
  5874	    SockPacket sockPkt;
  5875	    sockPkt.type = SOCK_CREATE;
  5876	    memcpy(sockPkt.data, &_sock, sizeof(Sock));
  5877	
  5878	    // Copy to shared memory and notify this
  5879	    memcpy(_pBlock->buf2, &sockPkt, sizeof(Sock) + sizeof(SockPktType));
  5880	    kill(_protoPid, SIGUSR1);
  5881	    log(TAG "%s : kill signal SIGUSR1 to process %d.\n", __func__, _protoPid);
  5882	
  5883	    int result = waitForSuccess(SIGUSR1);
  5884	    printf("Created socket: %d\n", result);
  5885	
  5886	    return result;
  5887	
  5888	}
  5889	
  5890	int CSocket::socket(int family, int type, int protocol)
  5891	{
  5892	    return init(family, type, protocol);
  5893	
  5894	}
  5895	
  5896	int CSocket::bind(const struct sockaddr* addr, socklen_t len)
  5897	{
  5898	    struct sockaddr_in bindAddr = *((struct sockaddr_in *)addr);
  5899	
  5900	    _sock.addr = bindAddr.sin_addr;
  5901	    _sock.port = bindAddr.sin_port;
  5902	
  5903	    SockPacket sockPkt;
  5904	    sockPkt.type = SOCK_BIND;
  5905	
  5906	    memcpy(sockPkt.data, &_sock, sizeof(_sock));
  5907	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock));
  5908	
  5909	    kill(_protoPid, SIGUSR1);
  5910	
  5911	    pause();
  5912	
  5913	    if (sig == SIGUSR1) {
  5914	        int success = *((int *)_pBlock->buf1);
  5915	        if (success == 1) {
  5916	            return 0;
  5917	        }
  5918	        else {
  5919	            _sock.addr.s_addr = 0;
  5920	            _sock.port = 0;
  5921	            return -1;
  5922	        }
  5923	    }
  5924	    else {
  5925	        _sock.addr.s_addr = 0;
  5926	        _sock.port = 0;
  5927	        fprintf(stderr, "Not SIGUSR1 received\n");
  5928	        return -1;
  5929	    }
  5930	}
  5931	
  5932	int CSocket::sendto(const char* buf, size_t len, int flags,
  5933	        const struct sockaddr* dstAddr, socklen_t addrlen) 
  5934	{
  5935	    // todo: Send to ProtoSocket send message
  5936	    //   data format: ProtoSocket{type, {SockData, buf}}
  5937	    //              or: ProtoSocket{type, {left buf}}
  5938	    SockDataHdr sockDataHdr;
  5939	    sockDataHdr.sockfd  = _sock.sockfd;
  5940	    sockDataHdr.dstAddr = *((struct sockaddr_in *)dstAddr);
  5941	    sockDataHdr.flag    = flags;
  5942	    sockDataHdr.len     = len;
  5943	
  5944	    SockPacket sockPkt;
  5945	    sockPkt.type = SOCK_SENDTO;
  5946	
  5947	    char *pData = sockPkt.data;
  5948	
  5949	    memcpy(pData, &sockDataHdr, sizeof(SockDataHdr));
  5950	    pData += sizeof(SockDataHdr);
  5951	
  5952	    int bufLeft = cSHMDataSize - sizeof(SockDataHdr);
  5953	    int dataLeft = len;
  5954	    
  5955	    while (dataLeft > 0) {
  5956	        int dataLen;
  5957	
  5958	        if (bufLeft <= 0) {         // re-point to buffer start
  5959	            bufLeft = cSHMDataSize;
  5960	            pData = sockPkt.data;
  5961	        }
  5962	
  5963	        if (dataLeft <= bufLeft) {
  5964	            dataLen = dataLeft;
  5965	        }
  5966	        else {
  5967	            dataLen = bufLeft;
  5968	        }
  5969	
  5970	        memcpy(pData, buf, dataLen);
  5971	
  5972	        pData       += dataLen;
  5973	        dataLeft    -= dataLen;
  5974	        bufLeft     -= dataLen;
  5975	
  5976	        int bytes = pData - sockPkt.data + sizeof(SockPktType);
  5977	        printf("will copy %d bytes.\n", bytes);
  5978	        memcpy(_pBlock->buf2, &sockPkt, bytes);
  5979	        kill(_protoPid, SIGUSR2);
  5980	    }
  5981	
  5982	    int byteSend = waitForSuccess(SIGUSR2);
  5983	    printf("Send %d bytes.\n", byteSend);
  5984	
  5985	    return byteSend;
  5986	}
  5987	
  5988	int CSocket::recvfrom(char* buf, size_t len, int flags,
  5989	        struct sockaddr* srcAddr, socklen_t* addrlen)
  5990	{
  5991	    SockDataHdr dataHdr;
  5992	    dataHdr.sockfd  = _sock.sockfd;
  5993	    dataHdr.flag    = flags;
  5994	    dataHdr.len     = len;
  5995	
  5996	    SockPacket sockPkt;
  5997	    sockPkt.type    = SOCK_RECVFROM;
  5998	
  5999	    memcpy(sockPkt.data, &dataHdr, sizeof(dataHdr));
  6000	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(dataHdr));
  6001	    kill(_protoPid, SIGUSR1);
  6002	
  6003	    pause();
  6004	
  6005	    // read data from ProtoSocket and set value-result parameters
  6006	    char *pData = _pBlock->buf1;
  6007	    SockDataHdr* rcvDataHdr = (SockDataHdr *)pData;
  6008	
  6009	    struct sockaddr_in* fromAddr = &rcvDataHdr->srcAddr;
  6010	    *srcAddr = *((struct sockaddr*)&rcvDataHdr->srcAddr);
  6011	    *addrlen = sizeof(struct sockaddr);
  6012	    printf("Received data from %s:%d.\n", inet_ntoa(fromAddr->sin_addr), ntohs(fromAddr->sin_port));
  6013	
  6014	    pData += sizeof(SockDataHdr);
  6015	
  6016	    int dataLen = len;
  6017	    if (dataLen > rcvDataHdr->len) {
  6018	        dataLen = rcvDataHdr->len;
  6019	    }
  6020	    memcpy(buf, pData, dataLen);
  6021	
  6022	    return dataLen;
  6023	}
  6024	
  6025	int CSocket::close() 
  6026	{
  6027	    // there is no need to close an unconnected socket
  6028	    if (_sock.type == SOCK_STREAM && _sock.state == SS_UNCONNECTED) {
  6029	        log(TAG "%s(): stream socket not connected, there is no need to close\n", __func__);
  6030	        return 0;
  6031	    }
  6032	
  6033	    SockPacket sockPkt;
  6034	    sockPkt.type = SOCK_CLOSE;
  6035	
  6036	    memcpy(sockPkt.data, &_sock, sizeof(Sock));
  6037	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock));
  6038	    kill(_protoPid, SIGUSR1);
  6039	
  6040	    return waitForSuccess(SIGUSR1) - 1;
  6041	}
  6042	
  6043	int CSocket::connect(const struct sockaddr* addr, socklen_t len)
  6044	{
  6045	    SockPacket sockPkt;
  6046	    sockPkt.type = SOCK_CONNECT;
  6047	
  6048	    struct sockaddr_in * dstAddr = (struct sockaddr_in *)addr;
  6049	    _sock.peerAddr = dstAddr->sin_addr;
  6050	    _sock.peerPort = dstAddr->sin_port;
  6051	
  6052	    memcpy(sockPkt.data, &_sock, sizeof(_sock));
  6053	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(_sock));
  6054	    kill(_protoPid, SIGUSR1);
  6055	
  6056	    pause();
  6057	
  6058	    Sock *sock = (Sock *)_pBlock->buf1;
  6059	    if (sock->port > 0) {
  6060	        _sock.addr = sock->addr;
  6061	        _sock.port = sock->port;
  6062	        _sock.state = sock->state;
  6063	        return 0;
  6064	    }
  6065	    else {
  6066	        return -1;
  6067	    }
  6068	
  6069	}
  6070	
  6071	SockDataHdr CSocket::makeDataHeader(size_t len, int flag)
  6072	{
  6073	    SockDataHdr sockDataHdr;
  6074	    sockDataHdr.sockfd  = _sock.sockfd;
  6075	    sockDataHdr.flag    = flag;
  6076	    sockDataHdr.len     = len;
  6077	
  6078	    struct sockaddr_in srcAddr, dstAddr;
  6079	    srcAddr.sin_addr = _sock.addr;
  6080	    srcAddr.sin_port = _sock.port;
  6081	    dstAddr.sin_addr = _sock.peerAddr;
  6082	    dstAddr.sin_port = _sock.peerPort;
  6083	
  6084	    sockDataHdr.srcAddr = srcAddr;
  6085	    sockDataHdr.dstAddr = dstAddr;
  6086	
  6087	    return sockDataHdr;
  6088	}
  6089	
  6090	int CSocket::send(const char * buf, size_t len, int flag)
  6091	{
  6092	    log(TAG "%s(): \"%s\"\n", __func__, buf); 
  6093	    log(TAG "%s(): addr %s:%d\n", __func__, inet_ntoa(_sock.addr), ntohs(_sock.port));
  6094	    log(TAG "%s(): peer %s:%d\n", __func__, inet_ntoa(_sock.peerAddr), ntohs(_sock.peerPort));
  6095	    // todo: Send to ProtoSocket send message
  6096	    //   data format: ProtoSocket{type, {SockData, buf}}
  6097	    //              or: ProtoSocket{type, {left buf}}
  6098	    SockDataHdr sockDataHdr = makeDataHeader(len, flag);
  6099	
  6100	    SockPacket sockPkt;
  6101	    sockPkt.type = SOCK_SEND;
  6102	
  6103	    char *pData = sockPkt.data;
  6104	
  6105	    memcpy(pData, &sockDataHdr, sizeof(SockDataHdr));
  6106	    pData += sizeof(SockDataHdr);
  6107	
  6108	    int bufLeft = cSHMDataSize - sizeof(SockDataHdr);
  6109	    int dataLeft = len;
  6110	    
  6111	    while (dataLeft > 0) {
  6112	        int dataLen;
  6113	
  6114	        if (bufLeft <= 0) {         // re-point to buffer start
  6115	            bufLeft = cSHMDataSize;
  6116	            pData = sockPkt.data;
  6117	        }
  6118	
  6119	        if (dataLeft <= bufLeft) {
  6120	            dataLen = dataLeft;
  6121	        }
  6122	        else {
  6123	            dataLen = bufLeft;
  6124	        }
  6125	
  6126	        memcpy(pData, buf, dataLen);
  6127	
  6128	        pData       += dataLen;
  6129	        dataLeft    -= dataLen;
  6130	        bufLeft     -= dataLen;
  6131	
  6132	        int bytes = pData - sockPkt.data + sizeof(SockPktType);
  6133	        printf("will copy %d bytes.\n", bytes);
  6134	        memcpy(_pBlock->buf2, &sockPkt, bytes);
  6135	        kill(_protoPid, SIGUSR2);
  6136	    }
  6137	
  6138	    int byteSend = waitForSuccess(SIGUSR2);
  6139	    printf("Send %d bytes.\n", byteSend);
  6140	
  6141	    return byteSend;
  6142	}
  6143	
  6144	int CSocket::recv(char * buf, size_t len, int flag)
  6145	{
  6146	    log(TAG "%s(): addr %s:%d\n", __func__, inet_ntoa(_sock.addr), ntohs(_sock.port));
  6147	    log(TAG "%s(): peer %s:%d\n", __func__, inet_ntoa(_sock.peerAddr), ntohs(_sock.peerPort));
  6148	    // each recv() should return as soon as possible, if there is no data, -1 is returned
  6149	    SockDataHdr sockDataHdr = makeDataHeader(len, flag);
  6150	
  6151	    SockPacket sockPkt;
  6152	    sockPkt.type = SOCK_RECV;
  6153	    memcpy(sockPkt.data, &sockDataHdr, sizeof(SockDataHdr));
  6154	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(SockDataHdr));
  6155	    
  6156	    uint8_t leftChance = 3;
  6157	    kill(_protoPid, SIGUSR2);
  6158	
  6159	    pause();
  6160	
  6161	    // read data from ProtoSocket and set value-result parameters
  6162	    char *pData = _pBlock->buf1;
  6163	    SockDataHdr* rcvDataHdr = (SockDataHdr *)pData;
  6164	    //while (leftChance-- > 0) {
  6165	    while (true) {
  6166	        if (rcvDataHdr->len <= 0) {
  6167	            // try again if we still get chance
  6168	            //log(TAG "%s(): no data available, left try times=%d.\n", __func__, leftChance);
  6169	            log(TAG "%s(): try again\n", __func__);
  6170	            sleep(1);
  6171	            kill(_protoPid, SIGUSR2);
  6172	            pause();
  6173	        }
  6174	        else {
  6175	            break;
  6176	        }
  6177	    }
  6178	
  6179	    if (leftChance <= 0 && rcvDataHdr->len <= 0) {
  6180	        log(TAG "%s(): return without data\n", __func__);
  6181	        return -1;
  6182	    }
  6183	
  6184	    pData += sizeof(SockDataHdr);
  6185	
  6186	    int dataLen = len;
  6187	    if (dataLen > rcvDataHdr->len) {
  6188	        dataLen = rcvDataHdr->len;
  6189	    }
  6190	    memcpy(buf, pData, dataLen);
  6191	    return dataLen;
  6192	}
  6193	
  6194	int CSocket::listen(int backlog)
  6195	{
  6196	    SockPacket sockPkt;
  6197	    sockPkt.type = SOCK_LISTEN;
  6198	
  6199	    char *pData = sockPkt.data;
  6200	    memcpy(pData, &_sock, sizeof(_sock));
  6201	    pData += sizeof(_sock);
  6202	    memcpy(pData, &backlog, sizeof(int));
  6203	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(_sock) + sizeof(int));
  6204	    kill(_protoPid, SIGUSR1);
  6205	
  6206	    return waitForSuccess(SIGUSR1) - 1;
  6207	}
  6208	
  6209	std::unique_ptr<CSocket> CSocket::accept(struct sockaddr * sockaddr, socklen_t * addrlen)
  6210	{
  6211	    SockPacket sockPkt;
  6212	    sockPkt.type = SOCK_ACCEPT;
  6213	
  6214	    memcpy(sockPkt.data, &_sock, sizeof(_sock));
  6215	    memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock)); 
  6216	
  6217	    kill(_protoPid, SIGUSR1);
  6218	
  6219	    pause();
  6220	
  6221	    Sock *sock = (Sock *)_pBlock->buf1; 
  6222	
  6223	    std::unique_ptr<CSocket> pSock(new CSocket());
  6224	    pSock->_sock = *sock;
  6225	
  6226	    struct sockaddr_in *fromAddr = (struct sockaddr_in *)sockaddr;
  6227	    fromAddr->sin_addr = sock->peerAddr;
  6228	    fromAddr->sin_port = sock->peerPort;
  6229	    fromAddr->sin_family = sock->family;
  6230	    memset(fromAddr->sin_zero, 0, sizeof(fromAddr->sin_zero));
  6231	
  6232	    *addrlen = sizeof(struct sockaddr_in);
  6233	
  6234	    return pSock;
  6235	}
  6236	
  6237	#include "ProtoSocket.h"
  6238	#include <unistd.h>
  6239	#include <sys/stat.h>
  6240	#include <sys/ipc.h>
  6241	#include <sys/shm.h>
  6242	#include <cstdio>
  6243	#include <cstdlib>
  6244	#include <cstring>
  6245	#include <signal.h>
  6246	
  6247	#include <algorithm>
  6248	
  6249	#include "UDP.h"
  6250	#include "TCP.h"
  6251	#include "Network.h"
  6252	#include "Link.h"
  6253	#include "Hardware.h"
  6254	#include "Util.h"
  6255	
  6256	#define TAG "<CProtoSocket> "
  6257	
  6258	using std::string;
  6259	
  6260	int sig;            // signal received
  6261	
  6262	void handler0(int signo)
  6263	{
  6264	    sig = signo;
  6265	    printf("Received signal INT.\n");
  6266	}
  6267	
  6268	void handler1(int signo) 
  6269	{
  6270	    sig = signo;
  6271	    printf("Received signal USR1.\n");
  6272	}
  6273	
  6274	void handler2(int signo) 
  6275	{
  6276	    sig = signo;
  6277	    printf("Received signal USR2.\n");
  6278	}
  6279	
  6280	CProtoSocket::CProtoSocket()
  6281	{
  6282	    log(TAG "%s(): sizeof(SockPktType)=%d.\n", __func__, sizeof(SockPktType));
  6283	    createSharedMem();
  6284	}
  6285	
  6286	CProtoSocket::~CProtoSocket()
  6287	{
  6288	    destroySharedMem();
  6289	    printf("CProtoSocket destructed.\n");
  6290	}
  6291	
  6292	void CProtoSocket::createSharedMem()
  6293	{
  6294	    key_t key;
  6295	
  6296	    if ((key = ftok(cKeyPath, cKeyID)) == -1) {
  6297	        fprintf(stderr, "Failed ftok().\n");
  6298	    }
  6299	
  6300	    if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR |
  6301	                    S_IRGRP | S_IWGRP |
  6302	                    S_IROTH | S_IWOTH)) == -1) {
  6303	        fprintf(stderr, "Failed shmget().\n");
  6304	        exit(EXIT_FAILURE);
  6305	    }
  6306	    else {
  6307	        printf("Created shared memory %d.\n", _shmid);
  6308	    }
  6309	
  6310	    if ((_pBlock = (SharedBlock *)shmat(_shmid, 0, 0)) == (void *)-1) {
  6311	        fprintf(stderr, "Failed shmat().\n");
  6312	    }
  6313	    else {
  6314	        printf("pBlock: %p, pBlock->buf1: %p, pBlock->buf2: %p\n",
  6315	                _pBlock, _pBlock->buf1, _pBlock->buf2);
  6316	    }
  6317	}
  6318	
  6319	void CProtoSocket::destroySharedMem()
  6320	{
  6321	    if (shmdt(_pBlock) == -1) {
  6322	        fprintf(stderr, "Failed shmdt().\n");
  6323	    }
  6324	
  6325	    if (shmctl(_shmid, IPC_RMID, 0) == -1) {
  6326	        fprintf(stderr, "Failed shmctl().\n");
  6327	    }
  6328	}
  6329	
  6330	void CProtoSocket::run()
  6331	{
  6332	    // protocols init, must in order : top-to-down
  6333	    CTCP::instance()->init();
  6334	    CUDP::instance()->init();
  6335	    CNetwork::instance()->init();
  6336	    CLink::instance()->init();
  6337	    CHardware::instance()->init();
  6338	
  6339	    // catch signals
  6340	    signal(SIGUSR1, handler1);
  6341	    signal(SIGUSR2, handler2);
  6342	    signal(SIGINT, handler0);
  6343	
  6344	    printf("Protocol socket running...\n");
  6345	
  6346	    while (true) {
  6347	        pause();
  6348	
  6349	        if (sig == SIGUSR1 || sig == SIGUSR2) {
  6350	            handleSockRequest();
  6351	            // SIGUSR1 do command work,
  6352	            // SIGUSR2 do data work
  6353	        }
  6354	        else if (sig == SIGINT){
  6355	            break;
  6356	        }
  6357	        else {
  6358	            printf("Unknown signal: %d.\n", sig);
  6359	        }
  6360	
  6361	        sig = 0;
  6362	        printf("Protocols alive...\n");
  6363	    }
  6364	
  6365	    printf("Protocol socket exit...\n");
  6366	}
  6367	
  6368	void CProtoSocket::handleSockRequest()
  6369	{
  6370	    SockPacket *sockPkt;
  6371	
  6372	    sockPkt = (SockPacket *)_pBlock->buf2;
  6373	    switch (sockPkt->type) {
  6374	        case SOCK_CREATE: 
  6375	            {
  6376	                handleCreate(sockPkt); break;
  6377	            }
  6378	        case SOCK_BIND:
  6379	            {
  6380	                handleBind(sockPkt); break;
  6381	            }
  6382	        case SOCK_SENDTO:
  6383	            {
  6384	                handleSendTo(sockPkt); break;
  6385	            }
  6386	        case SOCK_SEND:
  6387	            {
  6388	                handleSend(sockPkt); break;
  6389	            }
  6390	        case SOCK_RECVFROM:
  6391	            {
  6392	                handleRecvFrom(sockPkt); break;
  6393	            }
  6394	        case SOCK_RECV:
  6395	            {
  6396	                handleRecv(sockPkt); break;
  6397	            }
  6398	        case SOCK_CONNECT:
  6399	            {
  6400	                handleConnect(sockPkt); break;
  6401	            }
  6402	        case SOCK_LISTEN:
  6403	            {
  6404	                handleListen(sockPkt); break;
  6405	            }
  6406	        case SOCK_ACCEPT:
  6407	            {
  6408	                handleAccept(sockPkt); break;
  6409	            }
  6410	        case SOCK_CLOSE:
  6411	            {
  6412	                handleClose(sockPkt); break;
  6413	            }
  6414	        default:
  6415	            fprintf(stderr, "Unkonwn socket packet type: %d.\n", sockPkt->type);
  6416	            break;
  6417	    }
  6418	
  6419	}
  6420	
  6421	void CProtoSocket::handleCreate(SockPacket *sockPkt)
  6422	{   
  6423	    Sock *sock;
  6424	    sock = (Sock *)sockPkt->data;
  6425	
  6426	    printf("pid: %d, family: %d, type: %d, protocol: %d\n",
  6427	            sock->pid, sock->family, sock->type, sock->protocol);
  6428	    sock->state = SS_UNCONNECTED;
  6429	    InetSock sk{
  6430	        ._sock = *sock,
  6431	        .sk_state = CLOSED 
  6432	    };
  6433	    // save to socket pool
  6434	    _sockPool.emplace(sock->sockfd, sk);
  6435	
  6436	    // write back sockfd
  6437	    memcpy(_pBlock->buf1, &sock->sockfd, sizeof(int));
  6438	
  6439	    afterHandle(sock->pid, SIGUSR1, __func__);
  6440	 
  6441	}
  6442	
  6443	void CProtoSocket::handleBind(SockPacket *sockPkt)
  6444	{
  6445	    Sock *sock = (Sock *)sockPkt->data;
  6446	    InetSock &cached = _sockPool.at(sock->sockfd);
  6447	    cached.sk_addr = sock->addr;
  6448	    cached.sk_port = sock->port;
  6449	
  6450	    int success = 1;
  6451	    memcpy(_pBlock->buf1, &success, sizeof(success));
  6452	
  6453	    afterHandle(cached.sk_pid, SIGUSR1, __func__);
  6454	    //kill(cached.pid, SIGUSR1);
  6455	    //log(TAG "%s : kill signal SIGUSR1 to process %d.\n", __func__, cached.pid);
  6456	}
  6457	
  6458	void CProtoSocket::handleSendTo(SockPacket *sockPkt)
  6459	{
  6460	    SockDataHdr *sockDataHdr;
  6461	    sockDataHdr = (SockDataHdr *)sockPkt->data;
  6462	
  6463	    struct sockaddr_in *dstAddr = (struct sockaddr_in *)&sockDataHdr->dstAddr;
  6464	    printf("socket: %d want to send %d bytes data to %s:%d.\n",
  6465	            sockDataHdr->sockfd, sockDataHdr->len,
  6466	            inet_ntoa(dstAddr->sin_addr), ntohs(dstAddr->sin_port));
  6467	
  6468	    // get data to send
  6469	    char *pData = sockPkt->data;
  6470	    pData += sizeof(SockDataHdr);
  6471	
  6472	    // ---- debug only
  6473	    char *buf = (char *)malloc(sockDataHdr->len + 1);
  6474	    memcpy(buf, pData, sockDataHdr->len);
  6475	    buf[sockDataHdr->len] = '\0';
  6476	    printf("Contents to send: %s.\n", buf);
  6477	    free(buf);
  6478	    // ---- /debug only
  6479	
  6480	    packet_t pkt;
  6481	    pkt.buf = (unsigned char*)pData;
  6482	    pkt.size = sockDataHdr->len;
  6483	    pkt.daddr = dstAddr->sin_addr;
  6484	    pkt.dport = dstAddr->sin_port;
  6485	
  6486	    // get this socket
  6487	    InetSock & sock = _sockPool.at(sockDataHdr->sockfd);
  6488	
  6489	    // set local address as needed
  6490	    setLocalAddr(&sock);
  6491	
  6492	    pkt.saddr = sock.sk_addr;
  6493	    pkt.sport = sock.sk_port;
  6494	
  6495	    // call UDP::send()
  6496	    CUDP::instance()->send(&pkt);
  6497	    // 
  6498	    // notice, this code assume data will not overflow the buffer size
  6499	    // to handle the overflow situation, modify this code
  6500	    
  6501	    // notify send bytes
  6502	    memcpy(_pBlock->buf1, &sockDataHdr->len, sizeof(int));
  6503	
  6504	    afterHandle(sock.sk_pid, SIGUSR2, __func__);
  6505	 
  6506	}
  6507	
  6508	void CProtoSocket::handleRecvFrom(SockPacket *sockPkt)
  6509	{
  6510	    SockDataHdr *dataHdr = (SockDataHdr *)sockPkt->data;
  6511	
  6512	    log(TAG "socket %d wanna recvfrom max %d bytes data.\n", dataHdr->sockfd, dataHdr->len);
  6513	
  6514	    // get this socket
  6515	    InetSock& sock = _sockPool.at(dataHdr->sockfd);
  6516	
  6517	    // add pending recvfrom socket
  6518	    //_pendingSocks.emplace(dataHdr->sockfd, sock.port);
  6519	    _pendingSocks.emplace(&sock);
  6520	 
  6521	    log(TAG "%s : add penging socket %d:%d.\n", __func__, sock.sk_sockfd, ntohs(sock.sk_port));
  6522	}
  6523	
  6524	void CProtoSocket::handleSend(SockPacket *sockPkt)
  6525	{
  6526	    SockDataHdr *sockDataHdr;
  6527	    sockDataHdr = (SockDataHdr *)sockPkt->data;
  6528	
  6529	    struct sockaddr_in *srcAddr = (struct sockaddr_in *)&sockDataHdr->srcAddr;
  6530	    struct sockaddr_in *dstAddr = (struct sockaddr_in *)&sockDataHdr->dstAddr;
  6531	
  6532	    string key = CTCP::instance()->keyOf(srcAddr->sin_addr, srcAddr->sin_port, dstAddr->sin_addr, dstAddr->sin_port);
  6533	
  6534	    // find connection first
  6535	    log(TAG "%s(): %s\n", __func__, key.c_str()); 
  6536	
  6537	    ConnPMap::iterator it = _connPPool.find(key);
  6538	    if (it != _connPPool.end()) {
  6539	        // get data to send
  6540	        char *pData = sockPkt->data;
  6541	        pData += sizeof(SockDataHdr);
  6542	
  6543	        // ---- debug only
  6544	        char *buf = (char *)malloc(sockDataHdr->len + 1);
  6545	        memcpy(buf, pData, sockDataHdr->len);
  6546	        buf[sockDataHdr->len] = '\0';
  6547	        log(TAG "%s() contents send: %s.\n", __func__, buf);
  6548	        free(buf);
  6549	        // ---- /debug only
  6550	
  6551	        packet_t pkt;
  6552	        pkt.buf = (unsigned char*)pData;
  6553	        pkt.size = sockDataHdr->len;
  6554	        pkt.saddr = srcAddr->sin_addr;
  6555	        pkt.sport = srcAddr->sin_port;
  6556	        pkt.daddr = dstAddr->sin_addr;
  6557	        pkt.dport = dstAddr->sin_port;
  6558	
  6559	        CTCP::instance()->send(&pkt);
  6560	        // notice, this code assume data will not overflow the buffer size
  6561	        // to handle the overflow situation, fix this code
  6562	        
  6563	        memcpy(_pBlock->buf1, &sockDataHdr->len, sizeof(int));
  6564	        afterHandle(it->second->ics_pid, SIGUSR2, __func__);
  6565	    }
  6566	    else {
  6567	        log(TAG "%s(): no connection found, report this error\n", __func__);
  6568	    }
  6569	
  6570	}
  6571	
  6572	void CProtoSocket::handleRecv(SockPacket *sockPkt)
  6573	{
  6574	    SockDataHdr *dataHdr = (SockDataHdr *)sockPkt->data;
  6575	    struct sockaddr_in *srcAddr = (struct sockaddr_in *)&dataHdr->srcAddr;
  6576	    struct sockaddr_in *dstAddr = (struct sockaddr_in *)&dataHdr->dstAddr;
  6577	
  6578	    string key = CTCP::instance()->keyOf(srcAddr->sin_addr, srcAddr->sin_port, dstAddr->sin_addr, dstAddr->sin_port);
  6579	
  6580	    // find connection first
  6581	    log(TAG "%s(): %s\n", __func__, key.c_str()); 
  6582	
  6583	    ConnPMap::iterator it = _connPPool.find(key);
  6584	
  6585	    if (it == _connPPool.end()) {
  6586	        log(TAG "%s(): no connection found, report this error\n", __func__);
  6587	        return ;
  6588	    }
  6589	
  6590	    SockDataHdr sdh = *dataHdr;
  6591	    sdh.srcAddr = dataHdr->dstAddr;
  6592	    sdh.dstAddr = dataHdr->srcAddr;
  6593	    sdh.flag = 0;
  6594	
  6595	    InetConnSock *ics = it->second; 
  6596	
  6597	    if (ics->recvQueue.empty()) {
  6598	        sdh.len = -1;
  6599	    }
  6600	    else {
  6601	        char *pData = _pBlock->buf1;
  6602	        pData += sizeof(SockDataHdr);
  6603	        // todo: copy recvQueue data to buffer
  6604	        int goalLen = dataHdr->len;
  6605	        int copiedLen = 0;
  6606	
  6607	        PacketQueue & recvQueue = ics->recvQueue;
  6608	
  6609	        while (copiedLen < goalLen) {
  6610	            std::shared_ptr<packet_t> &ppkt = recvQueue.front();
  6611	            int dataLen = ppkt->len;
  6612	            if (dataLen > goalLen - copiedLen) {
  6613	                dataLen = goalLen - copiedLen;
  6614	            }
  6615	
  6616	            memcpy(pData, ppkt->data, dataLen);
  6617	            pData += dataLen;
  6618	            copiedLen += dataLen;
  6619	
  6620	            ppkt->pull(dataLen);
  6621	            if (ppkt->empty()) {
  6622	                recvQueue.pop_front();
  6623	                
  6624	                if (recvQueue.empty()) 
  6625	                    break;
  6626	            }
  6627	        }
  6628	        sdh.len = copiedLen;
  6629	    }
  6630	    memcpy(_pBlock->buf1, &sdh, sizeof(SockDataHdr));
  6631	    afterHandle(ics->ics_pid, SIGUSR2, __func__);
  6632	
  6633	    // todo: notify TCP we received data 
  6634	}
  6635	
  6636	void CProtoSocket::handleClose(SockPacket *sockPkt)
  6637	{
  6638	    Sock *sock = (Sock *)sockPkt->data;
  6639	    log(TAG "%s() : close socket %d, port %d\n", __func__, sock->sockfd, ntohs(sock->port));
  6640	
  6641	    if (sock->type == SOCK_STREAM) {
  6642	        // need do 4wwh
  6643	        string name = CTCP::keyOf(sock->addr, sock->port, sock->peerAddr, sock->peerPort);
  6644	        ConnPMap::iterator it = _connPPool.find(name);
  6645	        if (it != _connPPool.end()) {
  6646	            if (it->second->_inetSock._sock.state == SS_DISCONNECTING) {
  6647	                log(TAG "%s(): connection is closing...\n", __func__);
  6648	            }
  6649	            else {
  6650	                it->second->_inetSock._sock.state = SS_DISCONNECTING;
  6651	                CTCP::instance()->close(name);
  6652	            }
  6653	        }
  6654	        else {
  6655	            log(TAG "%s(): no connection find '%s'\n", __func__, name.c_str());
  6656	            afterHandle(0, sock->pid, SIGUSR1, __func__);
  6657	        }
  6658	    }
  6659	    else if (sock->type == SOCK_DGRAM) {
  6660	        _sockPool.erase(sock->sockfd);
  6661	        afterHandle(1, sock->pid, SIGUSR1, __func__);
  6662	    }
  6663	    else {
  6664	        log (TAG "%s(): unsupport sock type: %d\n", __func__, sock->type);
  6665	        afterHandle(0, sock->pid, SIGUSR1, __func__);
  6666	    }
  6667	
  6668	}
  6669	
  6670	void CProtoSocket::handleListen(SockPacket *sockPkt)
  6671	{
  6672	    log(TAG "%s().\n", __func__);
  6673	    Sock *sock = (Sock *)sockPkt->data; 
  6674	    InetSock &cached = _sockPool.at(sock->sockfd);
  6675	
  6676	    char *pData = sockPkt->data;
  6677	    pData += sizeof(Sock);
  6678	
  6679	    int backlog = *(int *)pData;
  6680	    cached.backlog = backlog;
  6681	
  6682	    cached.sk_state = LISTEN;
  6683	    cached._sock.state = SS_CONNECTING; // optional 
  6684	
  6685	    CTCP::instance()->listen(&cached); 
  6686	
  6687	    afterHandle(1, cached.sk_pid, SIGUSR1, __func__); 
  6688	
  6689	}
  6690	
  6691	void CProtoSocket::handleConnect(SockPacket *sockPkt)
  6692	{
  6693	    Sock *sock = (Sock *)sockPkt->data;
  6694	
  6695	    InetSock &cached = _sockPool.at(sock->sockfd);
  6696	    cached.sk_peerAddr = sock->peerAddr;
  6697	    cached.sk_peerPort = sock->peerPort;
  6698	
  6699	    // set local address as needed
  6700	    setLocalAddr(&cached);
  6701	
  6702	    int result = cached._sock.state;
  6703	
  6704	    if (result == SS_UNCONNECTED) {
  6705	        cached._sock.state = SS_CONNECTING;
  6706	        CTCP::instance()->connect(&cached);
  6707	        // if connect successfully, connectFinished() is called
  6708	    }
  6709	    else {
  6710	        log(TAG "Not unconnected socket: %d.\n", result);
  6711	        memcpy(_pBlock->buf1, &result, sizeof(result));
  6712	        afterHandle(cached.sk_pid, SIGUSR1, __func__);
  6713	    }
  6714	
  6715	}
  6716	
  6717	void CProtoSocket::handleAccept(SockPacket *sockPkt)
  6718	{
  6719	    log(TAG "%s().\n", __func__);
  6720	    Sock *sock = (Sock *)sockPkt->data;
  6721	    // when there is a connected connection, return it, otherwise, record an accept request 
  6722	    //
  6723	    // find a connection without sockfd assigned
  6724	    //
  6725	    ConnPMap::iterator it = std::find_if(_connPPool.begin(), _connPPool.end(), [=](const ConnPMap::value_type &pair){
  6726	                InetConnSock *conn = pair.second;
  6727	                return conn->ics_sockfd == 0 && conn->ics_port == sock->port; 
  6728	            });
  6729	
  6730	    if (it != _connPPool.end()) {
  6731	        // find a connection, return it
  6732	        InetConnSock *ics = it->second;
  6733	        ics->ics_sockfd = selectFD();
  6734	
  6735	        Sock *newSock = (Sock *)ics;
  6736	        memcpy(_pBlock->buf1, newSock, sizeof(Sock));
  6737	        afterHandle(newSock->pid, SIGUSR1, __func__);
  6738	    }
  6739	    else {
  6740	        // no available connection yet
  6741	        _pendingAccept.insert(sock->port);
  6742	    }
  6743	
  6744	}
  6745	
  6746	void CProtoSocket::connectFinished(string name, InetConnSock *ics)
  6747	{
  6748	    log(TAG "%s(): %s.\n", __func__, name.c_str());
  6749	    ics->_inetSock._sock.state = SS_CONNECTED;
  6750	    _connPPool.emplace(name, ics); 
  6751	
  6752	    // here, no notify the connected address, a data structure must be returned instead of
  6753	    // a single flag show failed or success
  6754	    memcpy(_pBlock->buf1, ics, sizeof(Sock));
  6755	
  6756	    afterHandle(ics->ics_pid, SIGUSR1, __func__);
  6757	}
  6758	
  6759	void CProtoSocket::accepted(std::string name, InetConnSock *ics)
  6760	{
  6761	    log(TAG "%s(): %s.\n", __func__, name.c_str());
  6762	    ics->_inetSock._sock.state = SS_CONNECTED;
  6763	    auto pair = _connPPool.emplace(name, ics);
  6764	
  6765	    std::set<uint16_t>::iterator it = _pendingAccept.find(ics->ics_port);
  6766	    if (it != _pendingAccept.end()) {
  6767	        ics->ics_sockfd = selectFD(); 
  6768	        memcpy(_pBlock->buf1, ics, sizeof(Sock));
  6769	
  6770	        _pendingAccept.erase(ics->ics_port);
  6771	
  6772	        afterHandle(ics->ics_pid, SIGUSR1, __func__);
  6773	    }
  6774	    else {
  6775	        log (TAG "%s(): no accept request at port %d\n", __func__, ics->ics_port);
  6776	    }
  6777	}
  6778	
  6779	void CProtoSocket::closed(std::string name)
  6780	{
  6781	    log(TAG "%s(): %s\n", __func__, name.c_str());
  6782	    // remove connection
  6783	    ConnPMap::iterator it = _connPPool.find(name);
  6784	    int result;
  6785	    uint32_t pid = it->second->ics_pid;
  6786	    if (it != _connPPool.end()) {
  6787	        _connPPool.erase(it);
  6788	        log(TAG "%s(): now there is %d connection\n", __func__, _connPPool.size());
  6789	        result = 1;
  6790	    }
  6791	    else {
  6792	        result = 0;
  6793	        log(TAG "%s(): connection not found\n", __func__);
  6794	    }
  6795	
  6796	    log(TAG "%s(): now there is %d socket\n", __func__, _sockPool.size());
  6797	
  6798	    afterHandle(result, pid, SIGUSR1, __func__);
  6799	}
  6800	
  6801	uint16_t CProtoSocket::selectPort()
  6802	{
  6803	    return 1314;
  6804	}
  6805	
  6806	uint32_t CProtoSocket::selectFD()
  6807	{
  6808	    return 15110;
  6809	}
  6810	
  6811	
  6812	void CProtoSocket::setLocalAddr(InetSock * sock)
  6813	{
  6814	    // get source ip address if not bind yet, 
  6815	    // if has bound, port will not be 0
  6816	    if (sock->sk_port == 0) {           // not bind yet
  6817	        const Device *dev = CHardware::instance()->getDefaultDevice();
  6818	        sock->sk_addr = dev->ipAddr;
  6819	        sock->sk_port = htons(selectPort());
  6820	    } else {}
  6821	
  6822	}
  6823	
  6824	void CProtoSocket::bytesAvailable(InetConnSock *ics)
  6825	{
  6826	    log (TAG "%s()\n", __func__);
  6827	}
  6828	
  6829	void CProtoSocket::received(const packet_t *pkt)
  6830	{
  6831	    log (TAG "Received %d bytes data.\n", pkt->len);
  6832	    log (TAG "_pendSocks: \n");
  6833	    for_each (_pendingSocks.cbegin(), _pendingSocks.cend(), [=](const InetSock *sock){
  6834	        log("pid: %d, sockfd: %d, port: %d\n", sock->sk_pid, sock->sk_sockfd, ntohs(sock->sk_port));
  6835	    });
  6836	    // find pending socket
  6837	    auto p = std::find_if(_pendingSocks.cbegin(), _pendingSocks.cend(),
  6838	                [=](const InetSock* sock){
  6839	                    return (sock->sk_port == pkt->dport);
  6840	                });
  6841	    if (p != _pendingSocks.cend()) {
  6842	        const InetSock* sock = *p;
  6843	
  6844	        // todo: copy pkt data to shared memory
  6845	        SockDataHdr dataHdr;
  6846	        dataHdr.sockfd  = sock->sk_sockfd;
  6847	        dataHdr.len     = pkt->len;
  6848	
  6849	        struct sockaddr_in srcAddr;
  6850	        srcAddr.sin_addr = pkt->saddr;
  6851	        srcAddr.sin_port = pkt->sport;
  6852	        srcAddr.sin_family = AF_INET;
  6853	
  6854	        struct sockaddr_in dstAddr;
  6855	        dstAddr.sin_addr = pkt->daddr;
  6856	        dstAddr.sin_port = pkt->dport;
  6857	        dstAddr.sin_family = AF_INET;
  6858	
  6859	        dataHdr.srcAddr = srcAddr;
  6860	        dataHdr.dstAddr = dstAddr;
  6861	
  6862	        dataHdr.flag    = 0;
  6863	
  6864	        char *pData = _pBlock->buf1;
  6865	        memcpy(pData, &dataHdr, sizeof(dataHdr));
  6866	        pData += sizeof(dataHdr);
  6867	
  6868	        memcpy(pData, pkt->data, pkt->len);
  6869	        pData += pkt->len;
  6870	
  6871	        _pendingSocks.erase(p);
  6872	
  6873	        afterHandle(sock->sk_pid, SIGUSR2, __func__);
  6874	    }
  6875	    else {
  6876	        log(TAG "No pending socket port %d find.\n", ntohs(pkt->dport));
  6877	    }
  6878	
  6879	}
  6880	
  6881	void CProtoSocket::afterHandle(int success, int pid, int signo, const char * const funcName)
  6882	{
  6883	    memcpy(_pBlock->buf1, &success, sizeof(success));
  6884	    afterHandle(pid, signo, funcName);
  6885	}
  6886	
  6887	void CProtoSocket::afterHandle(int pid, int signo, const char *funcName)
  6888	{
  6889	    usleep(100);            // VIP: wait CSocket enter pause() statement
  6890	    kill(pid, signo);
  6891	    //log(TAG "%s() : kill signal %d to process %d.\n", funcName, signo, pid);
  6892	}
  6893	
  6894	#include "CheckSum.h"
  6895	
  6896	uint16_t cksum(const u_char *const buf, size_t size)
  6897	{
  6898	    uint32_t sum;
  6899	    uint16_t *p = (uint16_t *)buf;
  6900	
  6901	    sum = 0;
  6902	    while(size > 1) {
  6903	        sum += *p++;
  6904	        size -= 2;
  6905	    }
  6906	
  6907	    // padding as needed
  6908	    if(size == 1) {
  6909	        sum += *((u_char *)p);
  6910	    }
  6911	
  6912	    while(sum >> 16)
  6913	        sum = (sum & 0xFFFF) + (sum >> 16);
  6914	
  6915	    return (uint16_t)((~sum) & 0xFFFF);
  6916	}
