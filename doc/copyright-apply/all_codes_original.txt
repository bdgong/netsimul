  #include "ProtoSocket.h"
  
  #include <cstdio>
  
  int main()
  {
      printf("Protocol process starting...\n");
  
      CProtoSocket* protoSocket = CProtoSocket::instance();
      protoSocket->run();
  
      printf("Protocol process exiting...\n");
  
      return 0;
  }
  
  
  #ifndef ICMP_H_
  #define ICMP_H_
  
  typedef struct sniff_icmp {
      uint8_t icmp_type;          // type of message
      uint8_t icmp_code;          // type sub code
      uint16_t icmp_sum;          // one complement check sum of struct 
      union {
          uint8_t ih_pptr;        // parameter problem pointer
          struct in_addr ih_gwaddr;   // Gateway Internet Address
          struct ih_idseque {
              uint16_t icd_id;    // identifier
              uint16_t icd_seq;   // sequence number
          } ih_idseque ;
          uint32_t ih_void;
      } icmp_hun ;
  #define icmp_pptr_t           icmp_hun.ih_pptr
  #define icmp_gwaddr_t         icmp_hun.ih_gwaddr
  #define icmp_id_t             icmp_hun.ih_idseque.icd_id
  #define icmp_seq_t            icmp_hun.ih_idseque.icd_seq
  #define icmp_void_t           icmp_hun.ih_void
      union {
          struct id_ts {
              uint32_t its_otime; // Originate timestamp
              uint32_t its_rtime; // Receive timestamp
              uint32_t its_ttime; // Transmit timestamp
          } id_ts;
          struct id_ip {          
              struct sniff_ip idi_ip;
              /*options and then 64bits of data*/
          } id_ip;
          uint32_t id_mask;
          uint8_t id_data[1];
      } icmp_dun ;
  #define icmp_otime_t          icmp_dun.id_ts.its_otime
  #define icmp_rtime_t          icmp_dun.id_ts.its_rtime
  #define icmp_ttime_t          icmp_dun.id_ts.its_ttime
  #define icmp_ip_t             icmp_dun.id_ip.idi_ip
  #define icmp_mask_t           icmp_dun.id_mask
  #define icmp_data_t           icmp_dun.id_data
  } icmphdr_t ;
  
  #endif  // ICMP_H_
  
  #pragma once 
  
  #include "SharedBlock.h"
  #include "InetSocket.h"
  #include "packet.h"
  
  #include <map>
  #include <set>
  #include <string>
  
  typedef std::map<std::string, InetConnSock*> ConnPMap; // connections, <localAddr.localPort-peerAddr.peerPort, InetConnSock*>
                                                      // actually, value is a pointer to TCP member _connPool's element
  
  class CProtoSocket
  {
      public:
          static CProtoSocket* instance()
          {
              static CProtoSocket inst;
              return &inst;
          }
          ~CProtoSocket();
  
          void run();
  
          /*
           * Received packet from protocol
           * */
          void received(const packet_t *pkt);
  
          /*
           * Called by TCP when a new connection @ics is arrived
           *
           * @name Connection name
           * @ics The connection 
           *
           * To be honest, this method can be avoided
           * */
          void connectFinished(std::string name, InetConnSock *ics);
  
          uint32_t selectFD();
  
          /*
           * Accepted an established connection from TCP
           *
           * @name Connection name
           * @ics The connection 
           * */
          void accepted(std::string name, InetConnSock *ics);
  
          void bytesAvailable(InetConnSock *ics);
  
          void closed(std::string name);
           
      private:
          // 
          CProtoSocket();
          CProtoSocket(const CProtoSocket&);
          CProtoSocket & operator=(const CProtoSocket&);
  
          /*
           * Create and detach shared memory
           * */
          void createSharedMem();
          void destroySharedMem();
  
          void handleSockRequest();
  
          void handleCreate(SockPacket *sockPkt);
          void handleBind(SockPacket *sockPkt);
          void handleSendTo(SockPacket *sockPkt);
          void handleRecvFrom(SockPacket *sockPkt);
          void handleSend(SockPacket *sockPkt);
          void handleRecv(SockPacket *sockPkt);
          void handleClose(SockPacket *sockPkt);
          void handleListen(SockPacket *sockPkt);
          void handleConnect(SockPacket *sockPkt);
          void handleAccept(SockPacket *sockPkt);
  
          /*
           * Random select an unused port
           * */
          uint16_t selectPort();
  
          void setLocalAddr(InetSock * sk);
  
          /*
           * Notify socket a given signal
           *
           * @success An int value when 1 for success, 0 for failed
           * @pid The process id
           * @signo The signal number
           * @funcName The calling function name
           * */
          void afterHandle(int success, int pid, int signo, const char * const funcName);
          void afterHandle(int pid, int signo, const char * const funcName);
  
          std::set<uint16_t> _pendingAccept;
          ConnPMap _connPPool; // connection pointers map
          std::map<int, InetSock> _sockPool;        // created sockets, <sockfd, InetSock>
          std::set<InetSock *> _pendingSocks;       // pending recvfrom sockets
  
          int _shmid;          // shared memory identifier
          SharedBlock *_pBlock;// shared block
  };
  
  #pragma once
  
  #include "tcp.h"
  #include "ProtoSocket.h"
  #include "InetSocket.h"
  #include "Network.h"
  #include "BaseIO.h"
  #include <map>
  #include <string>
  
  typedef std::map<std::string, InetConnSock> ConnMap; // connections, <localAddr.localPort-peerAddr.peerPort, InetConnSock>
  typedef std::map<uint16_t, InetSock*> InetSockMap;  // listen sockets, <port, InetSock*>
                                                      // actually, value is a pointer to CProtoSocket member _sockPool's
                                                      // element
  
  class CNetwork;
  class CProtoSocket;
  
  class CTCP : public CBaseIO
  {
      public:
          static CTCP * instance()
          {
              static CTCP inst;
              return &inst;
          }
  
          ~CTCP();
  
          void init();
          int send(packet_t *pkt);
          int received(packet_t *pkt);
  
          void connect(InetSock *sk);
          void listen(InetSock *sk);
  
          /*
           * Close a connection
           *
           * @name The connection name, can be contructed by keyOf()
           * */
          void close(std::string name);
  
          /*
           * Return the key(or name) of a connection.
           * */
          static std::string keyOf(InetConnSock *ics);
          static std::string keyOf(struct in_addr localAddr, uint16_t localPort, struct in_addr peerAddr, uint16_t peerPort);
  
      private:
          CTCP(const CTCP&);
          CTCP & operator=(const CTCP&);
  
          CTCP() { }
  
          InetConnSock * newConnection(InetConnSock *ics);
          void doSend(InetConnSock *ics);
          void __doSend(packet_t *packet, InetConnSock *ics, uint8_t flags, uint8_t *buf, uint32_t size);
  
          /*
           * Send a tcp segment without payload
           *
           * @packet The allocated packet
           * @ics The connection
           * @flags The tcp header flags
           * */
          void sendNoData(packet_t *packet, InetConnSock *ics, uint8_t flags);
  
          void recvEstablished(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr);
          void recvStateProcess(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr);
          void recvListen(InetSock *ics, packet_t *packet, tcphdr_t *tcphdr);
  
          InetSockMap _listenPool;
          ConnMap _connPool; 
          CProtoSocket *_protoSock;
          CNetwork *_network;
  };
  
  #pragma once
  
  #include <arpa/inet.h>
  #include <netinet/ip.h>
  #include <memory>
  #include "SharedBlock.h"
  
  class CSocket
  {
      public:
          CSocket();
          ~CSocket();
  
          int socket(int family, int type, int protocol);
          
          /*
           * Bind socket with address @sockaddr
           * */
          int bind(const struct sockaddr *sockaddr, socklen_t addrlen);
  
          /*
           * Connect to address @sockaddr
           * */ 
          int connect(const struct sockaddr *sockaddr, socklen_t addrlen);
  
          /*
           * Send to connected peer address
           *
           * @buf The data to send
           * @len The data length in bytes to send
           * */
          int send(const char * buf, size_t len, int flags);
  
          /*
           * Receive data from connected peer address, default timeout is 3 seconds.
           *
           * @buf The buffer used to stored received data 
           * @len Maximum bytes to receive
           * */
          int recv(char * buf, size_t len, int flags);
  
          /*
           * @return The number of bytes sent.  On error, -1 is returned
           * */
          int sendto(const char* buf, size_t len, int flags,
                  const struct sockaddr* dstAddr, socklen_t addrlen);
  
          /*
           * @return The  number  of bytes received, or -1 if an error occurred.
           * */
          int recvfrom(char* buf, size_t len, int flags,
                  struct sockaddr* srcAddr, socklen_t* addrlen);
  
          /*
           * Set this socket to listen mode
           *
           * @backlog The maximum client might in queue 
           * @return On success, zero is returned.  On error, -1 is returned
           * */
          int listen(int backlog);
  
          std::unique_ptr<CSocket> accept(struct sockaddr * sockaddr, socklen_t * addrlen);
  
          int shutdown();
  
          int close();
  
          /*
           * Return file descriptor of this socket
           * */
          int getFD()
          {
              return _sock.sockfd;
          }
          // 
      private:
          // 
          CSocket(const CSocket&);            // prevent copy
          CSocket & operator= (const CSocket&);// prevent assign
  
          /*
           * Do socket create
           * */
          int init(int family, int type, int protocol);
  
          /*
           * Attach and detach shared memory
           * */
          void attachSharedMem();
          void detachSharedMem();
  
          /*
           * Wait protocols stack reply
           *
           * @return Theorically, on success, 1 is returned, otherwise return 0 !!!
           * */
          int waitForSuccess(int signo);
  
          SockDataHdr makeDataHeader(size_t len, int flag);
  
          int _shmid;          // shared memory identifier
          SharedBlock *_pBlock;// shared block
          int _protoPid;          // protocol process id
  
          Sock _sock;
          //int _socketId;          // might use process id
          //int _family;
          //int _type;
          //int _protocol;
  };
  
  #ifndef TCP_H_
  #define TCP_H_
  
  #include <sys/types.h>
  
  #define SIZE_TCP 20
  
  /*
   * TCP Maximum Segment Size (MTU - SIZE_TCP - SIZE_IP)
   * */
  const int cTCPMSS = 1456;
  
  /* TCP header */
  typedef u_int tcp_seq;
  
  typedef struct sniff_tcp {
          u_short th_sport;               /* source port */
          u_short th_dport;               /* destination port */
          tcp_seq th_seq;                 /* sequence number */
          tcp_seq th_ack;                 /* acknowledgement number */
          u_char  th_offx2;               /* data offset, rsvd */
  #define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
          u_char  th_flags;
          #define TH_FIN  0x01
          #define TH_SYN  0x02
          #define TH_RST  0x04
          #define TH_PUSH 0x08
          #define TH_ACK  0x10
          #define TH_URG  0x20
          #define TH_ECE  0x40
          #define TH_CWR  0x80
          #define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
          u_short th_win;                 /* window */
          u_short th_sum;                 /* checksum */
          u_short th_urp;                 /* urgent pointer */
  } tcphdr_t ;
  
  /*
   * TCP control buffer
   * */
  typedef struct tagTCPCB {
      // ...
      u_int seq;          // start sequence of buffer 
      u_int endSeq;       // end sequence of buffer
      u_int ack;          // acked number
  } TCPCB;
  
  #define TCP_PKT_CB(__packet) ((TCPCB *)&(__packet)->cb[0])
  
  #endif  // TCP_H_
  
  
  #ifndef ETHER_H_
  #define ETHER_H_
  
  #include <netinet/ether.h>
  
  /* ethernet headers are always exactly 14 bytes [1] */
  #define SIZE_ETHERNET 14
  
  #define SIZE_ETHER_SUM 4
  
  /* Ethernet addresses are 6 bytes */
  #ifndef ETHER_ADDR_LEN
  #define ETHER_ADDR_LEN	6
  #endif
  
  /*MAC address in ASCII format length*/
  #define MAC_ASCII_LEN 18
  
  /*
   * Ethernet Type Defines, see /usr/include/net/ethernet.h
   * */
  
  /*#define ETHER_T_IPv4    0x0800      // Internet Protocol Version 4*/
  /*#define ETHER_T_IPv6    0x86DD      // Internet Protocol Version 6*/
  /*#define ETHER_T_ARP     0x0806      // Address Resolution Protocol */
  /*#define ETHER_T_RARP    0x8035      // Reverse Address Resolution Protocol */
  /*#define ETHER_T_ETHERTALK   0x809B  // AppleTalk over Ethernet*/
  /*#define ETHER_T_PPP     0x880B      // Point-to-Point Protocol*/
  /*#define ETHER_T_PPPoEDS     0x8863  // PPPoE Discovery Stage*/
  /*#define ETHER_T_PPPoESS     0x8864  // PPPoE Session Stage*/
  /*#define ETHER_T_SNMP    0x814C      // Simple Network Management Protocol*/
  
  /* Ethernet header */
  typedef struct sniff_ethernet {
          u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
          u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
          u_short ether_type;                     /* IP? ARP? RARP? etc */
  } ethernethdr_t ;
  
  #endif  // ETHER_H_
  
  #pragma once
  
  #include "udp.h"
  #include "BaseIO.h"
  
  class CUDP : public CBaseIO
  {
  public:
      static CUDP * instance()
      {
          static CUDP inst;
          return &inst;
      }
      //
      void init();
  
      /*
       * Send pkt out.
       *
       * @pkt The packet to send
       * */
      int send(packet_t *pkt);
  
      /*
       * Receive a packet pkt.
       *
       * @pkt The packet received
       * */
      int received(packet_t *pkt);
  private:
      CUDP()
      {
      }
  
      CUDP(const CUDP&);
      CUDP & operator= (const CUDP&);
  };
  #ifndef IP_H_
  #define IP_H_
  
  #include <netinet/in.h>
  #include <netinet/ip.h>
  
  /* to remove option, just set to 0 */
  #define SIZE_OPTION 4
  #define SIZE_IP (SIZE_OPTION+20)
  #define SIZE_IP_HL (SIZE_IP/4)
  
  const int cIPOptionValue = 0xFF020000; 
  
  /* IP header */
  struct sniff_ip {
          u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
          u_char  ip_tos;                 /* type of service */
          u_short ip_len;                 /* total length */
          u_short ip_id;                  /* identification */
          u_short ip_off;                 /* fragment offset field */
          #define IP_RF 0x8000            /* reserved fragment flag */
          #define IP_DF 0x4000            /* dont fragment flag */
          #define IP_MF 0x2000            /* more fragments flag */
          #define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
          u_char  ip_ttl;                 /* time to live */
          u_char  ip_p;                   /* protocol */
          u_short ip_sum;                 /* checksum */
          struct  in_addr ip_src,
                          ip_dst;         /* source and dest address */ 
          u_int   ip_opt;                 /* option value */
  
          bool isFragment() {
              return (ip_off & htons(IP_MF | IP_OFFMASK)) != 0;
          }
  
  };
  
  typedef struct sniff_ip iphdr_t;
  
  #define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
  #define IP_V(ip)                (((ip)->ip_vhl) >> 4)
  
  #endif  // IP_H_
  
  #pragma once
  //#ifndef NEIGHBOR_H_
  //#define NEIGHBOR_H_
  
  #include "Link.h"
  #include "arp.h"
  #include "packet.h"
  
  class CARP;
  class CLink;
  
  /*
   * CNeighbor - neighbor subsystem 
   * */
  class CNeighbor
  {
  public:
      // 
      static CNeighbor * instance()
      {
          static CNeighbor inst;
          return &inst;
      }
  
      void init();
  
      void send(packet_t *packet);
  
      void received(packet_t *packet);
  
  private:
      bool _isInited;
  
      CLink *_link;
      CARP *_arp;
  
      CNeighbor() : _isInited(false), _arp(nullptr)
      {
      }
  
      CNeighbor(const CNeighbor &);
      CNeighbor & operator= (const CNeighbor &);
  
  };
  
  //#endif // NEIGHBOR_H_
  #pragma once
  
  #include <arpa/inet.h>
  
  const char * const cKeyPath = "/home/bdg/.netsimul";   // this file must exist
  const int cKeyID = 17;
  
  const unsigned int cSHMSize = 8192;
  const unsigned int cSHMBufSize = 4096;
  const unsigned int cSHMDataSize = 4092;
  
  /*
   * struct sharedblock - a data structure between ProtocolSocket and AppSocket 
   *
   * @buf1 - ProtocolSocket buffer
   * @buf2 - AppSocket buffer
   * */
  typedef struct sharedblock {
      char buf1[cSHMBufSize];         // address is &sharedblock
      char buf2[cSHMBufSize];         // address is buf1 + 4096
  } SharedBlock;
  
  typedef enum sockpktype {
      SOCK_CREATE = 1,
      SOCK_BIND,
      SOCK_LISTEN,
      SOCK_CONNECT,
      SOCK_ACCEPT,
      SOCK_SEND,
      SOCK_SENDTO,
      SOCK_RECV,
      SOCK_RECVFROM,
      SOCK_CLOSE,
  } SockPktType;
  
  typedef enum socketstate {
      SS_FREE = 0,
      SS_UNCONNECTED,
      SS_CONNECTED,
      SS_CONNECTING,
      SS_DISCONNECTING
  } SocketState;
  
  /*
   * struct sockpacket - this data structure will save to buf1 or buf2 after conversion
   * */
  typedef struct sockpacket {
      SockPktType type;                  // this field must be the first member
      char data[cSHMBufSize - 4];
  } SockPacket;
  
  /////////////// start of sockpacket.data structures ///////////////
  
  typedef struct tagSock {
      int sockfd;         // socket file descriptor
      int pid;            // process id
      int family;
      int type;
      int protocol;
      struct in_addr addr;// socket bind address
      uint16_t port;      // socket bind port
      struct in_addr peerAddr;// peer socket address
      uint16_t peerPort;      // peer socket port
      SocketState state;  // connection state
  
      tagSock() 
      {
          sockfd = pid = family = type = protocol = 0;
          port = peerPort = 0;
          addr.s_addr = peerAddr.s_addr = 0;
          state = SS_UNCONNECTED;
      }
  
  } Sock;
  
  typedef struct tagSockDataHdr {
      int sockfd;
      struct sockaddr_in srcAddr;            // source address
      struct sockaddr_in dstAddr;            // destination address
      int flag;           // flag 
      int len;            // data length
  } SockDataHdr;
  
  /////////////// end of sockpacket.data structures   ///////////////
  
  #pragma once
  //#ifndef PACKET_H_
  //#define PACKET_H_
  
  #include <arpa/inet.h>
  #include <netinet/ether.h>
  #include <cstring>
  #include <cstdio>           // use printf to see how many copy used
  
  #include "ip_arp.h"
  
  struct packet_cb {
      // ... 
      uint16_t offset;
  };
  
  typedef packet_cb packet_cb_t;
  typedef packet_cb PacketCB;
  
  /*
   * Core structure used for networking, referece to Linux struct sk_buff design.
   * */
  struct inject_packet {
      u_char                  *buf;   // packet data send buffer
      size_t                  size;   // size of data bufer
      struct in_addr          saddr,  // source ip address
                              daddr;  // destination ip address
      struct ether_addr       sha,    // source hardware address
                              dha;    // destination hardware address
      uint16_t                sport,  // source port
                              dport;  // destination port
      u_char                  oper;   // operation code
      unsigned char           proto;  // protocol
  #define INJECT_OP_TCP(p) (p->oper == 't' || p->oper == 'T')
  #define INJECT_OP_UDP(p) (p->oper == 'u' || p->oper == 'U')
      uint16_t                ept;    // ethernet packet type
      //ARPHdr                  arphdr; // arp header 
      //const u_char            *rcvbuf;// packet data receive buffer
  
      char                    cb[48]; // control buffer for every process handler
      bool                    allocated;// True if this struct allocated by heap memory
      unsigned int            len;    // Length of the actual data
  
      unsigned char           *tail;  // Data tail
      unsigned char           *end;   // Buffer end
      unsigned char           *head,  // Buffer head
                              *data;  // Data pointer
  
      inject_packet() : size(0), len(0), allocated(false)
      {
          buf = head = tail = data = tail = nullptr;
          //rcvbuf = nullptr;
      }
  
      inject_packet(unsigned int size) : size(size), len(0), allocated(true)
      {
          buf = new unsigned char[size]{0};
  
          head = data = tail = buf;
          end = buf + size;
      }
  
      /*
       * Copy constructor.
       *
       * So, remember to use reference& in any where you can.
       * */
      inject_packet (const inject_packet &cp)
      {
  
          buf = new unsigned char[cp.size]{0};
  
          head = data = tail = buf;
          end = buf + cp.size;
  
          data = head + (cp.data - cp.head);
          tail = head + (cp.tail - cp.head);
  
          len     = cp.len;
          size    = cp.size;
          saddr   = cp.saddr;
          daddr   = cp.daddr;
          sha     = cp.sha;
          dha     = cp.dha;
          sport   = cp.sport;
          dport   = cp.dport;
          oper    = cp.oper;
          proto   = cp.proto;
          ept     = cp.ept;
          //arphdr  = cp.arphdr;
  
          allocated = true;
  
          memmove(buf, cp.buf, cp.size);
  
          printf("**Copied packet**\n");
  
      }
  
      void copyMetadata(const inject_packet &cp)
      {
          saddr   = cp.saddr;
          daddr   = cp.daddr;
          sha     = cp.sha;
          dha     = cp.dha;
          sport   = cp.sport;
          dport   = cp.dport;
          oper    = cp.oper;
          proto   = cp.proto;
          ept     = cp.ept;
  
      }
  
      ~inject_packet()
      {
          if (allocated && buf != nullptr) {
              delete [] buf;
              buf = nullptr;
              head = data = tail = end = buf;
              size = len = 0;
          }
  
      }
  
      /*
       * Reserve space of headroom.
       *
       * Increase the headroom of an empty &sk_buff by reducing the tail
       * room. This is only allowed for an empty buffer.
       * */
      void reserve(unsigned int length)
      {
          data += length;
          tail += length;
      }
  
      /*
       * Add data length to a buffer.
       *
       * Extends the used data area of the buffer.
       * */
      void put(unsigned int length)
      {
          tail += length;
          len += length;
      }
  
      /*
       * Add data to the start of a buffer.
       *
       * Extends the used data area of the buffer at the buffer start.
       * */
      void push(unsigned int length)
      {
          data -= length;
          len += length;
      }
  
      /*
       * Remove data from the start of a buffer.
       *
       * */
      void pull(unsigned int length)
      {
          data += length;
          len -= length;
      }
  
      /*
       * Trim data from the end of this buffer, Fri 23 Mar 2018 19:28:04 
       * */
      void trim(unsigned int length)
      {
          tail -= length;
          len -= length;
      }
  
      /*
       * Reset data pointer to head, and recalculate length.
       * */
      void resetData()
      {
          data = head;
          len  = tail - data;
      }
  
      /*
       * @return The packet control buffer pointer
       * */
      packet_cb_t * getPacketCB() const 
      {
          return (packet_cb_t *)cb;
      }
  
      bool isFull() const
      {
          return len == size;
      }
  
      bool empty() const 
      {
          return len == 0;
      }
  
  };
  
  typedef struct inject_packet packet_t;
  typedef struct inject_packet Packet;
  
  //#endif // PACKET_H_
  #pragma once
  
  #include "SharedBlock.h"
  #include "packet.h"
  #include <string>
  #include <list>
  #include <memory>
  
  /*
   * enum use capital, remember this rule
   * */
  typedef enum inetsockstate {
      CLOSED = 0,
      SYN_SENT,
      ESTABLISHED,
      FIN_WAIT_1,
      FIN_WAIT_2,
      TIME_WAIT,
      LISTEN,
      SYN_RCVD,
      CLOSE_WAIT,
      LAST_ACK,
  } InetSockState;
  
  /*
   * struct InetSock - Internet socket
   * */
  typedef struct tagInetSock
  {
      Sock _sock;
  #define sk_sockfd _sock.sockfd
  #define sk_pid _sock.pid
  #define sk_family _sock.family
  #define sk_type _sock.type
  #define sk_protocol _sock.protocol
  #define sk_addr _sock.addr
  #define sk_port _sock.port
  #define sk_peerAddr _sock.peerAddr
  #define sk_peerPort _sock.peerPort
      InetSockState sk_state;
      int backlog;
  } InetSock;
  
  typedef std::list<std::shared_ptr<packet_t>> PacketQueue;
  
  typedef struct tagICSWindow 
  {
      uint16_t size;          // window size
      uint32_t lastSeq;
      uint32_t lastAck;
      uint32_t nextSeq;
      uint32_t nextAck;
      uint32_t lower;         // window lower bound
      uint32_t upper;         // window upper bound
  } ICSWindow;
  
  /*
   * struct InetConnSock - Internet connection based socket
   * */
  typedef struct tagInetConnSock
  {
      InetSock _inetSock;
  #define ics_sockfd _inetSock.sk_sockfd
  #define ics_pid _inetSock.sk_pid
  #define ics_family _inetSock.sk_family
  #define ics_type _inetSock.sk_type
  #define ics_protocol _inetSock.sk_protocol
  #define ics_addr _inetSock.sk_addr
  #define ics_port _inetSock.sk_port
  #define ics_peerAddr _inetSock.sk_peerAddr
  #define ics_peerPort _inetSock.sk_peerPort
  #define ics_state _inetSock.sk_state
      ICSWindow sendWin,
                recvWin;
      PacketQueue sendQueue,
                  recvQueue;
  
      tagInetConnSock() 
      {
          memset(&sendWin, 0 , sizeof(ICSWindow));
          memset(&recvWin, 0 , sizeof(ICSWindow));
      }
  
  } InetConnSock;
  
  
  #ifndef NETSIMUL_H_
  #define NETSIMUL_H_
  
  char __ch;
  #define CLEAR() \
      while((__ch = getchar()) != '\n' && __ch != EOF)
  
  /* default snap length (maximum bytes per packet to capture) */
  #define SNAP_LEN 1518
  
  #define SIZE_TOK_BUF 256
  
  typedef struct tok {
      int v;              // value
      const char * s;     // string
  } tok_t ;
  
  #endif  // NETSIMUL_H_
  
  #pragma once
  //#ifndef ARP_H_
  //#define ARP_H_
  
  #include "packet.h"
  #include "Link.h"
  
  #include <sys/types.h>
  #include <map>
  #include <list>
  #include <string>
  
  using std::map;
  using std::list;
  
  const uint16_t cARPMaxTTL = 500;
  
  /*
   * ARPPacket - ARP packet 
   * */
  typedef struct arp_packet {
      ether_header etherhdr;
      ARPHdr arp;
  } ARPPacket;
  
  /*
   * struct ARPTableItem - Cache avaliable neighbors
   * */
  typedef struct arp_table_item { 
      in_addr_t ip;
      struct ether_addr mac;
      u_int16_t ttl;
  } ARPTableItem; 
  
  typedef std::map<in_addr_t, ARPTableItem> ARPTable; 
  
  /*
   * struct ARPQueueItem - Cache pending datagrams
   * */
  typedef struct arp_queue_item { 
      packet_t *packet;
  } ARPQueueItem;
  
  typedef std::map<in_addr_t, std::list<ARPQueueItem> > ARPQueue;
  
  class CLink;
  
  class CARP 
  {
  public:
      static CARP * instance() 
      {
          static CARP inst;
          return &inst;
      }
  
      void init();
  
      ~CARP();
  
      /*
       * Send out network layer datagram 
       * */
      void sendDatagram(packet_t *packet);
  
      /*
       * Send out ARP packet
       * */
      void sendARP(const struct in_addr &addr, packet_t *packet);
  
      /*
       * Received ARP packet
       * */
      void recvARP(packet_t *packet);
  
  private:
      bool _isInited;
  
      ARPTable _arpTable;          // arp table cache - Neighbors
      ARPQueue _arpQueue;          // arp queue - Pending datagrams wait for ARP resolve
  
      CLink *_link;
  
      /*
       * Cache packet to queue with key.  
       *
       * @return The item number has been cached with key.
       * */
      int cache(const struct in_addr &key, packet_t *packet);
  
      /*
       * Cache ARP item to table.
       * */
      void cache(const ARPHdr *arphdr);
  
      /*
       * Process cached datagrams when arp reply received
       *
       * @addr The address resolved
       * */
      void processPendingDatagrams(in_addr_t addr, const struct ether_addr * mac);
  
      void replyARP(const ARPHdr *arphdr);
  
      CARP() : _isInited(false), _link(nullptr)
      {
      }
  
  };
  
  //#endif  // ARP_H_
  #pragma once
  
  #include "Neighbor.h"
  #include "packet.h"
  #include "ip.h"
  #include <map>
  #include <list>
  #include "BaseIO.h"
  
  typedef struct frag_list {
      struct in_addr          saddr,      // fragment source ip address
                              daddr;      // fragment destinatin ip address
      uint8_t                 proto;      // upper protocol used
      uint16_t                id;         // ip header identifier
      uint32_t                len;        // total length of original datagram
      uint32_t                meat;       // received length
      std::list<packet_t*> fragments;     // fragment lists(Notice: the pointed block must be deleted correctly)
  } IPFragList;
  
  class CNeighbor;
  
  class CNetwork : public CBaseIO
  {
  public:
      //
      static CNetwork * instance()
      {
          static CNetwork inst;
          return &inst;
      }
  
      ~CNetwork();
  
      void init();
  
      /*
       * Add ip header, then transport this packet
       *
       * @pkt The packet to send out from local.
       * */
      int send(packet_t *pkt);
  
      /*
       * Forward a packet.  The ip header already in the packet.
       *
       * @pkt The packet to be forwarded
       * */
      void forward(packet_t *pkt);
  
      /*
       * Deliver received packet to right protocol handler.
       *
       * @pkt The packet to deliver.
       * */
      void deliver(packet_t *pkt);
  
      /*
       * Received a packet from L2
       *
       * @pkt The received packet
       * */
      int received(packet_t *pkt);
  
      /*
       * Do defragmentation
       *
       * @iphdr The ip header
       * @pkt The packet to defragment
       * */
      void defragment(iphdr_t *iphdr, packet_t *pkt);
  
      /*
       * Calculate fragment hash code by fragment ip header
       *
       * @iphdr The ip header
       * */
      uint32_t fragmentHashCode(iphdr_t *iphdr);
  
      /*
       * Do fragmentation
       *
       * @pkt The packet to fragment
       * @mtu The maximum data length of each fragment
       * */
      void fragment(packet_t *pkt, uint16_t mtu);
  
  private:
      /*
       * Return an id and increase it
       *
       * @return An Identifier used by ip header
       * */
      unsigned short getAndIncID(packet_t *pkt);
  
      /*
       * Reassemble a datagram when all fragments available.
       *
       * @pFrags Fragment list pointer
       * */
      void reasm(IPFragList *pFrags);
  
      /*
       * Clear fragment cache.
       *
       * @pFrags Target fragment list pointer
       * */
      void clear(IPFragList *pFrags);
  
      CNetwork() : _neigh(nullptr)
      {
      }
  
      CNetwork(const CNetwork&);
      CNetwork & operator= (const CNetwork&);
  
      CNeighbor *_neigh;
      CBaseIO *_tcp;
      CBaseIO *_udp;
  
      /*key: destination ip address, value: id for ip header*/
      std::map<in_addr_t, unsigned short> _idMap;
  
      /*key: fragment hash code, value: list for datagram fragments*/
      std::map<uint32_t, IPFragList> _fragsMap;
  
  };
  
  #pragma once
  //#ifndef HARDWARE_H_
  //#define HARDWARE_H_
  
  #include "Device.h"
  #include "packet.h"
  #include "Link.h"
  
  #include <pcap/pcap.h>
  
  #include <list>
  
  /* default snap length (maximum bytes per packet to capture) */
  #define SNAP_LEN 1518
  #define PKT_BUFF_TIME 2000
  
  class CLink;
  
  class CHardware
  {
  public:
      // 
      static CHardware * instance()
      {
          static CHardware hardware;
          return &hardware;
      }
  
      ~CHardware() 
      {
          if (_defaultDev != nullptr && _defaultDev->handler != nullptr) {
              pcap_close(_defaultDev->handler);
          }
          pcap_freealldevs(_foundDevs); 
      }
  
      void init();
      void up();
      void down();
      void transmit(const u_char*, size_t size);
      void received();
  
      const Device * getDefaultDevice() const 
      {
          return _defaultDev;
      }
  
  private:
      bool _isInited;
  
      pcap_if_t *_foundDevs;          // found pcap devices
  
      std::list<Device> _devs;        // avaliable device list
      Device *_defaultDev;            // default device
  
      CLink *_link;
  
      int detectDevices(char *errbuf);
  
      static void getPacket(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes);
  
      CHardware() : _isInited(false), _defaultDev(nullptr), _link(nullptr)
      {
      }
  
      CHardware(const CHardware&);
      CHardware& operator= (const CHardware&);
  };
  
  //#endif // HARDWARE_H_
  #pragma once
  
  #include "packet.h"
  
  /*
   * BaseIO - Basic input and output interface
   * */
  class CBaseIO
  {
      public:
          CBaseIO() : _isInited(false)
          {
          }
          virtual ~CBaseIO()
          {
          }
  
          virtual void init() = 0;
          virtual int send(packet_t *pkt) = 0;
          virtual int received(packet_t *pkt) = 0;
      protected:
          bool _isInited; 
  };
  
  #pragma once
  //#ifndef LINK_H_
  //#define LINK_H_
  
  #include "Hardware.h"
  #include "Neighbor.h"
  #include "Network.h"
  #include "packet.h"
  
  #include <memory>
  
  class CNeighbor;
  class CHardware;
  class CNetwork;
  
  /*
   * CLink - link layer interface 
   *
   * Call neighbor subsystem when send a network datagram.
   * Call hardware when transmit a packet.
   * */
  class CLink
  {
  public:
      static CLink * instance()
      {
          static CLink inst;
          return &inst;
      }
  
      ~CLink() 
      {
      }
  
      void init();
      /*
       * transmit a packet
       * */
      void transmit(packet_t *);
  
      /*
       * send a network datagram
       * */
      void send(packet_t *packet);
  
      /*
       * Receive packet from device
       * */
      void received(const u_char *, size_t);
  
      /*
       * The default device used to send and receive packet
       * */
      const Device * getDefaultDevice() const;
  
  private:
      bool _isInited;
      CNetwork *_network;
      CNeighbor *_neigh;
      CHardware *_hardware;
  
      CLink() : _isInited(false), _hardware(nullptr), _neigh(nullptr)
      {
          // do not call init() here, will cause '__gnu_cxx::recursive_init_error'
      }
  
      CLink(const CLink&);
      CLink & operator= (const CLink&);
  };
  
  //#endif  // LINK_H_
  
  #ifndef UDP_H_
  #define UDP_H_
  
  #include <netinet/ip.h>
  
  #define SIZE_UDP 8
  
  #define SIZE_PSEUDO_UDP 12
  
  // udp header
  typedef struct sniff_udp {
      uint16_t uh_sport;          // source port
      uint16_t uh_dport;          // destination port
      uint16_t uh_len;            // udp length
      uint16_t uh_sum;            // udp checksum
  } udphdr_t ;
  
  //pseudo udp header for calculation of check sum
  typedef struct pseudo_udp {
      struct in_addr saddr;       // source address
      struct in_addr daddr;       // destination address
      uint8_t zero;               // zero
      uint8_t protocol;           // protocol
      uint16_t len;               // UDP length
  } pseudo_udp_t ;
  
  #endif  // UDP_H_
  
  #pragma once
  //#ifndef IP_ARP_H_
  //#define IP_ARP_H_
  
  #include <sys/types.h>
  
  const u_int8_t cARPHeaderLen = 28;
  
  /*
   * ARP header - 
   *
   * attribute packed is needed to align one byte.
   * */
  struct sniff_arp {
      u_int16_t htype;        // Hardware Type
      u_int16_t ptype;        // Protocol Type
      u_int8_t hlen;          // Hardware Address Length
      u_int8_t plen;          // Protocol Address Length
      u_int16_t oper;         // Operation Code
      u_int8_t sha[6];        // Sender hardware address
      u_int32_t spa;          // Sender IP address
      u_int8_t tha[6];        // Target hardware address
      u_int32_t tpa;          // Target IP address
  } __attribute__((packed));
  
  typedef struct sniff_arp ARPHdr;
  
  //#endif  // IP_ARP_H_
  #pragma once
  
  #include <arpa/inet.h>
  
  extern uint16_t cksum(const u_char *const buf, size_t size);
  
  #ifndef DEVICE_H_
  #define DEVICE_H_
  
  #include <arpa/inet.h>
  #include <netinet/ether.h>
  
  #include <pcap/pcap.h>
  
  #include <iostream>
  #include <sstream>
  
  typedef struct device {
      u_int16_t           id;
      u_int16_t           type;
      u_int16_t           mtu;        // maximum transmission unit
      char                *name;
      struct in_addr      ipAddr;     // ip
      struct ether_addr   hAddr;      // mac
  
      pcap_t              *handler;   // pcap packet handler
  
      device ()
      {
          id = type = 0;
          name = nullptr;
          handler = nullptr;
      }
  
      void show() const
      {
          std::cout << toString() << std::endl;
      }
  
      std::string toString() const
      {
          std::ostringstream oss;
          oss << "Device ["
              << "id=" << id
              << ", type=" << type
              << ", mtu=" << mtu
              << ", name=" << name
              << ", ip=" << inet_ntoa(ipAddr)
              << ", mac=" << ether_ntoa(&hAddr)
              << "]";
          return oss.str();
      }
  
  } Device; 
  
  #endif  // DEVICE_H_
  #ifndef UTIL_H_
  #define UTIL_H_
  
  #include <cstdio>
  
  #define DBG_PREFIX 1
  #define DBG_NEWLINE (1 << 1)
  #define DBG_DEFAULT (DBG_PREFIX | DBG_NEWLINE)
  #define DBG_NONE 0
  
  #define DEBUG 1
  
  extern void log(const char *format,  ...);
  extern void debug(const char *format,  ...);
  extern void debug(int flag, const char *format,  ...);
  extern void error(const char *format,  ...);
  
  #define SIZE_TOK_BUF 256
  
  typedef struct tok {
      int v;              // value
      const char * s;     // string
  } tok_t ;
  
  extern const char * tok2str(const tok_t * tokp,
          const char * default_msg,
          int v);
  
  class File 
  {
      public:
          File(const char *filename) : file(NULL)
          {
              if ((file = fopen(filename, "w")) == NULL) {
                  fprintf(stderr, "Cannot open file: %s, use standard output instead.\n", filename);
                  file = stdout;
              }
              else {
                  fprintf(stdout, "Open file: %s\n", filename);
              }
          }
  
          ~File() 
          {
              if (file != NULL)
                  fclose(file);
          }
  
          FILE *get() const 
          {
              return file;
          }
  
      private:
          FILE *file;
  };
  
  #endif // UTIL_H_
  #include "Neighbor.h"
  
  #include "Util.h"
  
  #define TAG "<Neighbor> "
  
  void CNeighbor::init()
  {
      if (_isInited)
          return;
  
      _arp        = CARP::instance();
      _arp->init();
  
      _link       = CLink::instance();
      _link->init();
  
      _isInited   = true;
      debug(DBG_DEFAULT, TAG "initied.");
  }
  
  void CNeighbor::send(packet_t *packet)
  {
      _arp->sendDatagram(packet);
  }
  
  void CNeighbor::received(packet_t *packet)
  {
      _arp->recvARP(packet);
  
  }
  #include "Network.h"
  
  #include "ip.h"
  #include "CheckSum.h"
  #include "Util.h"
  #include "TCP.h"
  #include "UDP.h"
  
  #include <cstring>
  #include <algorithm>
  
  #define TAG "<Network> "
  
  const tok_t ipproto_values[] = {
      {IPPROTO_TCP, "TCP"},
      {IPPROTO_UDP, "UDP"},
      {IPPROTO_ICMP, "ICMP"},
      {IPPROTO_IP, "IP"},
      {0, NULL}
  };
  
  /*
   * A simple implementation of `ip_select_fb_ident()`
   * */
  uint16_t CNetwork::getAndIncID(packet_t *pkt)
  {
      in_addr_t daddr = pkt->daddr.s_addr;
  
      uint16_t id;
      if (_idMap.count(daddr) == 1) {
          // find it
          id = _idMap.at(daddr) + 1;
      }
      else {
          // not found, create one
          srand((unsigned int)time(NULL));
          id = rand() % 0xFFFF;
      }
      _idMap[daddr] = id;         // update cache
      return id;
  
  }
  
  int CNetwork::send(packet_t *pkt)
  {
      log (TAG "%s.\n", __func__);
      if (pkt->len > 0xFFFF) {
          debug(DBG_DEFAULT, "Too big packet to send.");
          return 0;
      }
  
      pkt->ept     = ETH_P_IP;
  
      const Device *dev = CLink::instance()->getDefaultDevice();
      uint16_t mtu = dev->mtu;
  
      if (SIZE_IP + pkt->len > mtu) {
          fragment(pkt, mtu);
      }
      else {
          // prepare IP header
          iphdr_t ip;
          size_t size_new = SIZE_IP + pkt->len; 
  
          ip.ip_vhl   = 0x40 | SIZE_IP_HL;
          ip.ip_tos   = 0;
          ip.ip_len   = htons(size_new);
          ip.ip_id    = htons(getAndIncID(pkt));
          ip.ip_off   = htons(IP_DF);     // don't fragment
          ip.ip_ttl   = IPDEFTTL;         // default TTL
          ip.ip_p     = pkt->proto;
          ip.ip_sum   = 0;
          ip.ip_src   = pkt->saddr;
          ip.ip_dst   = pkt->daddr;
          ip.ip_opt   = htonl(cIPOptionValue);
  
          ip.ip_sum   = cksum((u_char *)&ip, SIZE_IP);
  
          // push IP header space
          pkt->push(SIZE_IP);
          // copy IP header
          memcpy(pkt->data, &ip, SIZE_IP);
  
          char *srcIP = inet_ntoa(ip.ip_src);
          char *dstIP = inet_ntoa(ip.ip_dst);
          log (TAG "%s() : from source    %s\n", __func__, inet_ntoa(ip.ip_src));
          log (TAG "%s() : to destination %s\n", __func__, inet_ntoa(ip.ip_dst));
          _neigh->send(pkt);
      }
      return 0;
  
  }
  
  void CNetwork::fragment(packet_t *pkt, uint16_t mtu)
  {
      debug(DBG_DEFAULT, TAG "Do fragment.");
      iphdr_t ip;
  
      ip.ip_vhl   = 0x40 | SIZE_IP_HL;
      ip.ip_tos   = 0;
      ip.ip_id    = htons(getAndIncID(pkt));
      ip.ip_ttl   = IPDEFTTL;         // default TTL
      ip.ip_p     = pkt->proto;
      ip.ip_sum   = 0;
      ip.ip_src   = pkt->saddr;
      ip.ip_dst   = pkt->daddr;
      ip.ip_opt   = htonl(cIPOptionValue);
  
      unsigned int left   = pkt->len; // total length
      unsigned int len    = 0;        // current fragment length
      unsigned char *ptr  = pkt->data;// fragment start position
      uint16_t offset     = 0;
  
  
      while (left > 0) {
          len = left;
  
          if (len + SIZE_IP > mtu) {
              len = mtu - SIZE_IP;
          }
  
          if (len < left) {
              len &= ~7;          // align eight byte 
          }
  
          debug(DBG_DEFAULT, TAG "data left length=%d, now length=%d.", left, len);
  
          left -= len;
  
          // allocate fragment packet 
          packet_t pkt2(ETH_HLEN + SIZE_IP + len); 
          pkt2.copyMetadata(*pkt);
          pkt2.reserve(ETH_HLEN + SIZE_IP);
          pkt2.put(len);
          memcpy(pkt2.data, ptr, len);
  
          // set ip header
          iphdr_t iphdr = ip;
  
          iphdr.ip_len    = htons(SIZE_IP + len);
          iphdr.ip_off    = htons(offset >> 3);
  
          if (left > 0) {
              iphdr.ip_off |= htons(IP_MF);
          }
  
          iphdr.ip_sum    = cksum((u_char *)&iphdr, SIZE_IP);
  
          pkt2.push(SIZE_IP);
          memcpy(pkt2.data, &iphdr, SIZE_IP);
  
          offset += len;
          ptr += len;
  
          debug(DBG_DEFAULT, "<Network> send out fragment: %d bytes.", len);
          _neigh->send(&pkt2);
  
      } // while
  
  }
  
  void CNetwork::forward(packet_t *pkt)
  {
      debug(DBG_DEFAULT, TAG "forward to be implemented.");
  }
  
  void CNetwork::deliver(packet_t *pkt)
  {
      //pkt->pull(SIZE_IP);
  
      switch (pkt->proto) {
          case IPPROTO_TCP:
              {
                  _tcp->received(pkt);
                  break;
              }
          case IPPROTO_UDP:
              {
                  _udp->received(pkt);
                  break;
              }
          case IPPROTO_ICMP:
              {
                  break;
              }
          case IPPROTO_IP:
              {
                  break;
              }
          default:
              break;
      }
  
  }
  
  uint32_t CNetwork::fragmentHashCode(iphdr_t *iphdr)
  {
      uint32_t sAddrVal   = iphdr->ip_src.s_addr;
      uint32_t dAddrVal   = iphdr->ip_dst.s_addr;
      uint32_t protocol   = iphdr->ip_p;
      uint32_t id         = iphdr->ip_id;
  
      //return sAddrVal * 3 + dAddrVal * 5 + protocol * 17 + id * 31;
      return ((sAddrVal << 1) + sAddrVal)
          + ((dAddrVal << 2) + dAddrVal)
          + ((protocol << 4) + protocol)
          + ((id << 5) - id);
  
  }
  
  void CNetwork::defragment(iphdr_t *iphdr, packet_t *pkt)
  {
      // assume no overlap 
      debug(DBG_DEFAULT,  "defragment.");
  
      // find fragment list it belongs to in fragment map
      uint32_t keyFrag = fragmentHashCode(iphdr);
  
      IPFragList *pThisFrags = nullptr;
      if (_fragsMap.count(keyFrag) == 1) {
          pThisFrags = &_fragsMap.at(keyFrag);    // found and return the address
      }
      else {
          pThisFrags = &_fragsMap[keyFrag];       // not found, create one and return the address
  
          pThisFrags->saddr   = iphdr->ip_src;
          pThisFrags->daddr   = iphdr->ip_dst;
          pThisFrags->proto   = iphdr->ip_p;
          pThisFrags->id      = iphdr->ip_id;
          pThisFrags->len     = 0;
          pThisFrags->meat    = 0;
      }
  
      // calculate offset 
      uint16_t offset = ntohs(iphdr->ip_off);
      uint16_t flags = offset & ~IP_OFFMASK;
      offset &= IP_OFFMASK;
      offset <<= 3;
  
      uint16_t end = offset + pkt->len - SIZE_IP;
  
      if (offset == 0) {
          // first fragment
      }
  
      if ((flags & IP_MF) == 0) {
          // last fragment
          pThisFrags->len = end;
      }
  
      // copy and insert this fragment to framgent list
      pkt->pull(SIZE_IP);
  
      packet_t *pkt2 = new packet_t(*pkt);
      pkt2->copyMetadata(*pkt);
      pkt2->getPacketCB()->offset = offset;
  
      std::list<packet_t *> &frags = pThisFrags->fragments;
      const auto it = std::find_if(frags.cbegin(), frags.cend(), [=](const packet_t *pkt) {
                  return pkt->getPacketCB()->offset >= offset;
              });
      frags.insert(it, pkt2);
  
      debug(DBG_DEFAULT, TAG "fragment length=%d.", pkt2->len);
      pThisFrags->meat += pkt2->len;
      if (pThisFrags->meat == pThisFrags->len) {
          // completed, do reassemble work
          reasm(pThisFrags);
  
          // clear cache
          clear(pThisFrags);
          // remove item from map
          _fragsMap.erase(keyFrag);
      }
      
  }
  
  void CNetwork::reasm(IPFragList *pFrags)
  {
      debug(DBG_DEFAULT, TAG "reassemble fragments of datagram id=%d.", pFrags->id);
      packet_t pkt(pFrags->len);
      pkt.saddr = pFrags->saddr;
      pkt.daddr = pFrags->daddr;
      pkt.proto = pFrags->proto;
      
      std::list<packet_t *> &frags = pFrags->fragments;
      for (packet_t *fragment : frags) {
          pkt.put(fragment->len);
  
          memcpy(pkt.data, fragment->data, fragment->len);
  
          pkt.pull(fragment->len);
      }
  
      pkt.resetData();
      deliver(&pkt);
  }
  
  void CNetwork::clear(IPFragList *pFrags)
  {
      debug(DBG_DEFAULT, TAG "clear fragments of datagram id=%d.", pFrags->id);
      std::list<packet_t *> &frags = pFrags->fragments;
      auto it = frags.begin();
      while ( it != frags.end() ) {
          packet_t *pkt = *it;
          delete pkt;
          it = frags.erase(it);
      }
  
  }
  
  int CNetwork::received(packet_t *pkt)
  {
      debug(DBG_DEFAULT, "<Network> received.");
      iphdr_t *iphdr = (iphdr_t *)pkt->data;
  
      uint32_t sizeIPHdr = IP_HL(iphdr)*4;
      uint16_t len = ntohs(iphdr->ip_len);
      if (sizeIPHdr < SIZE_IP) {
          error("IP header size=%d, ignore\n", sizeIPHdr);
          return 0;
      }
      else {
          log(TAG "IP header size=%d, datagram len=%d\n", sizeIPHdr, len);
      }
  
      if (len < pkt->len) {
          log(TAG "%s(): there is %d bytes padding data, trim it\n", __func__, pkt->len - len);
          pkt->trim(pkt->len - len);
      }
  
      pkt->saddr = iphdr->ip_src;
      pkt->daddr = iphdr->ip_dst;
      pkt->proto = iphdr->ip_p;
  
      /* print source and destination IP addresses */
      debug("       From: %s\n", inet_ntoa(pkt->saddr));
      debug("         To: %s\n", inet_ntoa(pkt->daddr));
      debug("   Protocol: %s (%03d)\n",
              tok2str(ipproto_values, "Unknown", pkt->proto), pkt->proto);
  
      // check for local deliver or forward by compare destination address
      const Device *dev = CLink::instance()->getDefaultDevice();
      if (dev->ipAddr.s_addr != pkt->daddr.s_addr ) {
          forward(pkt);
      }
      else {
          if (iphdr->isFragment()) {
              defragment(iphdr, pkt);
          }
          else {
              pkt->pull(SIZE_IP);
              deliver(pkt);
          }
      }
      return 0;
      
  }
  
  CNetwork::~CNetwork() 
  {
      // delete still hold cache if needed
      for (auto pair : _fragsMap) {
          IPFragList *pFrags = &pair.second;
  
          clear(pFrags);
      }
      _fragsMap.clear();
  
  }
  
  void CNetwork::init()
  {
      if (_isInited)
          return;
  
      _neigh = CNeighbor::instance();
      _neigh->init();
  
      _tcp = CTCP::instance();
      _udp = CUDP::instance();
  
      _isInited = true;
      debug(DBG_DEFAULT, "<Network> inited.");
  
  }
  
  #include "arp.h"
  #include "ether.h"
  
  #include "Util.h"
  
  #include <cstring>
  #include <utility>
  #include <algorithm>
  
  #define TAG "<ARP> "
  
  void CARP::init()
  {
      if (_isInited)
          return;
  
      _link       = CLink::instance();
      // Since the init() is called up to down order, ARP no need to call link's init() any more
      //_link->init();
  
      _isInited   = true;
      debug(DBG_DEFAULT, TAG "initied.");
  
  }
  
  CARP::~CARP()
  {
      // delete allocated space if there is pending packet
      for (auto &pair : _arpQueue) {
          auto & list = pair.second;
          for (auto &item : list) {
              delete item.packet;         // delete [1]
              item.packet = nullptr;
          }
      }
  
  }
  
  void CARP::sendDatagram(packet_t *packet)
  {
      log (TAG "%s.\n", __func__);
      const Device *dev = _link->getDefaultDevice();
      if (dev == nullptr) {
          error("<ARP> Cannot get avaliable device.");
          return;
      }
  
      const struct in_addr & daddr = packet->daddr;
  
      packet->sha = dev->hAddr;       // set local hardware address
  
      if (_arpTable.count(daddr.s_addr) == 1) {   // check cache: find
          debug("Hit cache for: %s\n", inet_ntoa(daddr));
  
          const ARPTableItem & cache = _arpTable.at(daddr.s_addr);
          packet->dha = cache.mac;
  
          _link->transmit(packet);    // call link layer transmit
      }
      else {                                      // need send ARP packet
          debug("No cache for: %s, send ARP.\n", inet_ntoa(daddr));
  
          int cachedBefore = cache(daddr, packet);    // cache packet for later transmisson
          
          if (cachedBefore == 0) {                    // address resolve if no previous request send
              memcpy(&packet->dha, ether_aton("FF:FF:FF:FF:FF:FF"), ETH_ALEN);
          
              sendARP(daddr, packet);
          } else {}
      }
  
  }
  
  int CARP::cache(const struct in_addr &key, packet_t *packet)
  {
      //packet_t copy(*packet);
      //copy.buf = new u_char[packet->size];
      //memmove(copy.buf, packet->buf, packet->size);   // in case overlap, use memmove instead
  
      std::list<ARPQueueItem> & kList = _arpQueue[key.s_addr];
      ARPQueueItem item;
      item.packet = new packet_t(*packet);            // new [1]
      kList.push_back(item);
  
      return kList.size() - 1;
  
  }
  
  void CARP::sendARP(const struct in_addr &addr, packet_t *packet)
  {
      ARPHdr arp;
      arp.htype   = htons(ARPHRD_ETHER);          // linux/if_arp.h
      arp.ptype   = htons(ETH_P_IP);              // linux/if_ether.h
      arp.hlen    = ETH_ALEN;
      arp.plen    = 4;
      arp.oper    = htons(ARPOP_REQUEST);
      memcpy(&arp.sha, &packet->sha, ETH_ALEN);
      arp.spa     = packet->saddr.s_addr;
      memset(&arp.tha, 0, ETH_ALEN);
      arp.tpa     = addr.s_addr;
  
      packet_t pkt(SIZE_ETHERNET + cARPHeaderLen);
      pkt.sha     = packet->sha;
      pkt.dha     = packet->dha;
  
      pkt.reserve(SIZE_ETHERNET);
      pkt.put( cARPHeaderLen );
      memcpy(pkt.data, &arp, cARPHeaderLen);
  
      //packet_t &pkt = *packet;
      //pkt.arphdr  = arp;
      pkt.ept     = ETH_P_ARP;
  
      _link->transmit(&pkt);
  
  }
  
  void CARP::cache(const ARPHdr *arphdr)
  {
      ARPTableItem item;          
      item.ip     = arphdr->spa;
      memcpy(&item.mac, &arphdr->sha, ETH_ALEN);
      item.ttl    = cARPMaxTTL;
  
      _arpTable.emplace(item.ip, item);           // cache to arp table
  
  }
  
  void CARP::recvARP(packet_t *packet)
  {
      debug("<ARP> received.\n");
      ARPHdr *arphdr = (ARPHdr *)packet->data;
  
      if (ntohs(arphdr->htype) == ARPHRD_ETHER && ntohs(arphdr->ptype) == ETH_P_IP) {
          u_int16_t oper = ntohs(arphdr->oper);
  
          struct in_addr spa, tpa;
          spa.s_addr = arphdr->spa;
          tpa.s_addr = arphdr->tpa;
          debug("Sender      IP: %s, MAC: %s\n", inet_ntoa(spa), ether_ntoa((struct ether_addr *)arphdr->sha));
          debug("Destination IP: %s, MAC: %s\n", inet_ntoa(tpa), ether_ntoa((struct ether_addr *)arphdr->tha));
  
          const Device *dev = _link->getDefaultDevice();
          in_addr_t thisDevAddr = dev->ipAddr.s_addr;
  
          if (arphdr->tpa != thisDevAddr) {
              debug(DBG_DEFAULT, "ARP not to this device, ignore.");
              return;
          }
  
          if (oper == ARPOP_REPLY) {
              debug(DBG_DEFAULT, "arp reply.  cache and process.");
              cache(arphdr);
  
              processPendingDatagrams(arphdr->spa,
                      (struct ether_addr*)arphdr->sha);   // notify for pending ip datagram
          }
          else if(oper == ARPOP_REQUEST)  {
              debug(DBG_DEFAULT, "arp request, cache and reply.");
              cache(arphdr);
  
              replyARP(arphdr);
          }
          else {
              debug("Unknown arp operation code: %d\n", oper);
          }
      }
      else {
          error("Invalid ARP packet.\n");
      }
  
  }
  
  void CARP::processPendingDatagrams(in_addr_t addr, const struct ether_addr * mac)
  {
      ARPQueue::iterator it = _arpQueue.find(addr);
      if (it != _arpQueue.end()) {
          auto &itemList = it->second;
  
          for (auto &item : itemList) {
              packet_t *pkt = item.packet;
              pkt->dha = *mac;
              debug(DBG_DEFAULT, "<ARP> process pending datagrams for %s...", inet_ntoa(*(struct in_addr*)&addr));
              log("<ARP> process pending datagrams for %s...\n", inet_ntoa(*(struct in_addr*)&addr));
              _link->transmit(item.packet);
              delete item.packet;         // delete [1]
              item.packet = nullptr;
          }
  
          _arpQueue.erase(it);
      }
  
  }
  
  void CARP::replyARP(const ARPHdr *arphdr)
  {
      packet_t packet(ETH_HLEN + cARPHeaderLen); 
      ARPHdr arp; 
  
      arp = *arphdr;
      arp.oper    = htons(ARPOP_REPLY);
  
      const Device *dev = _link->getDefaultDevice();
      memcpy(&arp.sha, &dev->hAddr, ETH_ALEN);
      arp.spa     = dev->ipAddr.s_addr;
      memcpy(&arp.tha, &arphdr->sha, ETH_ALEN);
      arp.tpa     = arphdr->spa;
  
      memcpy(&packet.dha, &arphdr->sha, ETH_ALEN);
      memcpy(&packet.sha, &arp.sha, ETH_ALEN);
      packet.ept  = ETH_P_ARP;
  
      packet.reserve(ETH_HLEN);
      packet.put(cARPHeaderLen);
      memcpy(packet.data, &arp, cARPHeaderLen);
  
      struct in_addr tpa {.s_addr = arp.tpa };
      debug(DBG_DEFAULT, "<ARP> reply to %s.", inet_ntoa(tpa));
      log("<ARP> reply to %s.\n", inet_ntoa(tpa));
      _link->transmit(&packet);
  
  }
  #include "Device.h"
  
  
  #include "Link.h"
  #include "Util.h"
  #include <cstring>
  #include <netinet/ether.h>
  
  #define TAG "<Link> "
  
  const tok_t ethertype_values[] = {
      {ETH_P_IP,          "IPv4"},
      {ETH_P_ARP,         "ARP"},
      {ETH_P_IPV6,        "IPv6"},
      {ETH_P_LOOPBACK,    "Loopback"},
      {0, NULL}
  };
  
  void CLink::send(packet_t *packet)
  {
      _neigh->send(packet);
  }
  
  void CLink::transmit(packet_t *packet)
  {
      log(TAG "%s.\n", __func__);
      if ( !(packet->ept == ETH_P_ARP || packet->ept == ETH_P_IP) ) {
          error("Unsupported ethernet packet.\n");
          return ;
      }
  
      ether_header etherhdr;
      memcpy(&etherhdr.ether_shost, &packet->sha, ETH_ALEN);
      memcpy(&etherhdr.ether_dhost, &packet->dha, ETH_ALEN);
      etherhdr.ether_type     = htons(packet->ept); 
  
      log (TAG "%s(): From %s.\n", __func__, ether_ntoa((ether_addr*)&etherhdr.ether_shost));
      log (TAG "%s(): To   %s.\n", __func__, ether_ntoa((ether_addr*)&etherhdr.ether_dhost));
  
      packet->push(ETH_HLEN);
      memcpy(packet->data, &etherhdr, ETH_HLEN);
      _hardware->transmit(packet->data, packet->len);
  
  }
  
  void CLink::received(const u_char *bytes, size_t size)
  {
      //debug("<Link> received:\n");
      packet_t packet(size);
      packet.put(size);
      memcpy(packet.data, bytes, size);
  
      struct ether_header *etherhdr = (struct ether_header *)packet.data;
      memcpy(&packet.dha, &etherhdr->ether_dhost, ETH_ALEN);
      memcpy(&packet.sha, &etherhdr->ether_shost, ETH_ALEN);
      packet.ept  = ntohs(etherhdr->ether_type);
  
      debug("Network Layer Protocol: %s (%04X)\n",
              tok2str(ethertype_values, "Unknown", packet.ept), packet.ept);
      debug("Destination MAC: %s\n", ether_ntoa(&packet.dha));
      debug("Sender      MAC: %s\n", ether_ntoa(&packet.sha));
  
      packet.pull(ETH_HLEN);
      switch (packet.ept) {
          case ETH_P_ARP:
              _neigh->received(&packet);
              break;
          case ETH_P_IP:
              _network->received(&packet);
              break;
          default:
              return ;
      }
  
  }
  
  const Device * CLink::getDefaultDevice() const 
  {
      return _hardware->getDefaultDevice();
  }
  
  void CLink::init()
  {
      if (_isInited)
          return;
  
      _hardware   = CHardware::instance();
      _hardware->init();
      _neigh      = CNeighbor::instance();
      // Since this init() is called by CNeighbor's init(), it must be initialized
      //   there is no need to call
      //_neigh->init();
      _network = CNetwork::instance();
  
      _isInited   = true;
      debug(DBG_DEFAULT, TAG "initied.");
  
  }
  #include "Hardware.h"
  
  /*network*/
  #include <arpa/inet.h>
  #include <linux/netdevice.h>
  
  #include <cstring>
  #include <sstream>
  #include <algorithm>
  
  #include <thread>
  
  #include "Util.h"
  
  #define TAG "<Hardware> "
  /*
   * MTU - Maximum ethernet data size
   *
   * Maximum ethernet frame size is MTU+ETH_HLEN+ETH_FCS = 1500+14+4 = 1518
   *
   * For some device, MTU is 576.
   * */
  const u_int16_t cDefaultMTU = 1500;
  
  
  void CHardware::transmit(const u_char *bytes, size_t size)
  {
      if(_defaultDev == nullptr || _defaultDev->handler == nullptr) {
          error("Default device not avaliable.");
          return ;
      }
  
      int byteSend = pcap_inject(_defaultDev->handler, bytes, size);
      if(byteSend == -1) {
          error("Send packet failed.");
      }
      else {
          debug(DBG_DEFAULT, "Transmited packet to network (%d bytes).", byteSend);
          log("Transmited packet to network (%d bytes).\n", byteSend);
      }
      
  }
  
  void CHardware::getPacket(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)
  {
      debug("\n<Hardware> received packet (%d bytes).\n", h->len);
      CHardware *inst = CHardware::instance();
  
      inst->_link->received(bytes, h->len);
  }
  
  void CHardware::up()
  {
      if (_defaultDev != nullptr) {
          pcap_loop(_defaultDev->handler, -1, &CHardware::getPacket, nullptr);
      }
      else {
      }
  }
  
  void CHardware::down()
  {
      if (_defaultDev != nullptr) {
          pcap_breakloop(_defaultDev->handler);
      }
      else {
      }
  }
  
  int CHardware::detectDevices(char *errbuf)
  {
      if (pcap_findalldevs(&_foundDevs, errbuf) == -1) {          // cal pcap findalldevs
          error("Couldn't find any device: %s\n", errbuf);
          return -1;
      }
  
      std::ostringstream oss;
      oss << "Detected devices:";
      int count = 0;
  
      pcap_if_t *pDev = _foundDevs;
      while (pDev != NULL) {
          bpf_u_int32 flag = pDev->flags;
  
          if ((flag & PCAP_IF_RUNNING) && !(flag & PCAP_IF_LOOPBACK)) {   // find running and not loopback device
              Device dev;
              dev.name = pDev->name; 
  
              int progress = 0;
  
              pcap_addr_t *paddr = pDev->addresses;   // get address
              while (paddr != NULL) {
                  struct sockaddr *sa = paddr->addr;
                  
                  if (sa->sa_family == AF_PACKET) {           // find hardware address
                      struct sockaddr_ll *sall = (struct sockaddr_ll *) sa;
                      memcpy(&(dev.hAddr), &(sall->sll_addr), ETH_ALEN); 
                      progress |= 0x01;
                  }
                  else if (sa->sa_family == AF_INET) {        // find ip address
                      struct sockaddr_in *sai = (struct sockaddr_in *) sa;
                      memcpy(&(dev.ipAddr), &(sai->sin_addr), sizeof(struct in_addr));
                      progress |= 0x10;
                  }
                  else {}
  
                  if( (progress & 0x01) && (progress & 0x10) )// we only find mac & ip address
                      break;
  
                  paddr = paddr->next;
              }
  
              dev.mtu     = cDefaultMTU;
              _devs.push_back(dev);                   // save to cache
          }
          else {}
  
          oss << "\n" << ++count << "." << pDev->name;
          pDev = pDev->next;
      }
  
      log("%s\n", oss.str().c_str());
      debug(DBG_DEFAULT, oss.str().c_str());
  
      return _devs.size();
  
  }
  
  void CHardware::init()
  {
      if(_isInited) 
          return;
  
      char errbuf[PCAP_ERRBUF_SIZE];
  
      int nDevice = detectDevices(errbuf);            // detect avaliable devices
      if (nDevice <= 0) {                             // make sure we get at least one device
          error("No suitable device found.\n");
          return ;
      }
  
      _defaultDev = &_devs.front();                   // open the first device as default handler
      _defaultDev->handler = pcap_open_live (_defaultDev->name, SNAP_LEN, 0, PKT_BUFF_TIME, errbuf);
      if (_defaultDev->handler == NULL) {
          error("Couldn't open device %s : %s\n", _defaultDev->name, errbuf); 
          return ;
      }
  
      if (pcap_datalink(_defaultDev->handler) != DLT_EN10MB) { // make sure we're capturing on an Ethernet device
          error("%s is not an Ethernet device\n", _devs.front().name);
          return ;
      }
  
      std::thread listenThread(std::bind(&CHardware::up, this));
      listenThread.detach();                          // start listen 
      //pcap_dispatch(_defaultDev->handler, -1, &CHardware::getPacket, nullptr);  // only dispatch once
                                                      
      debug(DBG_DEFAULT, TAG "inited, suitable device list:");
      log(TAG "inited, suitable device list:\n");
      for (const Device& dev : _devs) {
          if(dev.name == _defaultDev->name) {         // use == because we use pointer for default device
              debug(DBG_DEFAULT, "%s *(default)", dev.toString().c_str());
              log("%s *(default)\n", dev.toString().c_str());
          }
          else {
              debug(DBG_DEFAULT, dev.toString().c_str());
              log("%s.\n", dev.toString().c_str());
          }
      }
  
      _link = CLink::instance();
      _isInited = true;
  
  
  }
  #include "UDP.h"
  #include "Network.h"
  #include "Util.h"
  #include "CheckSum.h"
  #include "ProtoSocket.h"
  #include "ether.h"
  #include <string>
  
  #define TAG "<CUDP> "
  
  const unsigned int cMaxBufferSize = 4096;
  
  uint16_t cksum_udp(const udphdr_t *const udp, const packet_t *const packet)
  {
  
      uint16_t sum;
      u_char *buf;
      size_t size;
  
      pseudo_udp_t pseudo_udp;
  
      pseudo_udp.saddr    = packet->saddr;
      pseudo_udp.daddr    = packet->daddr;
      pseudo_udp.zero     = 0;
      pseudo_udp.protocol = IPPROTO_UDP;
      pseudo_udp.len      = udp->uh_len;
  
      size = SIZE_PSEUDO_UDP + SIZE_UDP + packet->size;
      buf = (u_char *)malloc(size);
      memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
      memcpy(buf+SIZE_PSEUDO_UDP, udp, SIZE_UDP);
      memcpy(buf+SIZE_PSEUDO_UDP+SIZE_UDP, packet->buf, packet->size);
  
      sum = cksum(buf, size);
  
      free(buf);
  
      return sum;
  
  }
  
  void CUDP::init()
  {
      if (_isInited)
          return ;
  
      CNetwork::instance()->init();
      _isInited = true;
      debug(DBG_DEFAULT, "<UDP> inited.");
  }
  
  int CUDP::send(packet_t *packet)
  {
      log (TAG "%s\n", __func__);
      // make a copy of original data
      int sizeHdr = SIZE_UDP + SIZE_IP + SIZE_ETHERNET;
  
      // allocate more space include header
      packet_t pkt(sizeHdr + packet->size);
      pkt.copyMetadata(*packet);
  
      pkt.proto = IPPROTO_UDP;
  
      // reserve space for header
      pkt.reserve(sizeHdr);
  
      // copy payload
      pkt.put(packet->size);
      memcpy(pkt.data, packet->buf, packet->size);
  
      // prepare UDP header
      udphdr_t udp; 
      size_t size_new = SIZE_UDP + packet->size;
  
      //udp.uh_sport    = htons(packet->sport);
      //udp.uh_dport    = htons(packet->dport);
      udp.uh_sport    = packet->sport;
      udp.uh_dport    = packet->dport;
      udp.uh_len      = htons(size_new);
      udp.uh_sum      = 0;
  
      udp.uh_sum      = cksum_udp(&udp, packet);
  
      // push UDP header space
      pkt.push(SIZE_UDP);
  
      // copy UDP header
      memcpy(pkt.data, &udp, SIZE_UDP);
  
      log (TAG "%s() : from %d to %d.\n", __func__, ntohs(udp.uh_sport), ntohs(udp.uh_dport));
      // call network to do next work
      CNetwork *network = CNetwork::instance();
      network->send(&pkt);
  
      return 0;
  
  }
  
  int CUDP::received(packet_t *pkt)
  {
      debug(DBG_DEFAULT, "<UDP> received.");
      udphdr_t *udphdr = (udphdr_t *)pkt->data;
      uint16_t dataLen = ntohs( udphdr->uh_len ) - SIZE_UDP;
  
      pkt->sport  = udphdr->uh_sport;
      pkt->dport  = udphdr->uh_dport;
  
      pkt->pull(SIZE_UDP);
      //std::string msg((const char*)pkt->data, dataLen);
  
      //debug(DBG_DEFAULT, "Received data length=%d : \n%s", dataLen, msg.c_str());
      CProtoSocket::instance()->received(pkt);
      return 0;
  
  }
  
  #include "TCP.h"
  #include "Util.h"
  #include "CheckSum.h"
  
  #include "udp.h"
  #include "ip.h"
  #include "ether.h"
  
  #include <algorithm>
  
  #define TAG "<CTCP> "
  
  using std::string;
  using std::set;
  using std::map;
  
  const uint32_t cMaxHeaderLen = SIZE_ETHERNET + SIZE_IP + SIZE_TCP;
  const uint32_t cBlockSize = 4096;
  
  uint16_t cksum_tcp(const tcphdr_t *const tcp, const packet_t *const packet)
  {
      uint16_t sum;
      u_char *buf;
      size_t size;
      size_t dataLen;
      pseudo_udp_t pseudo_udp;
  
      dataLen = (packet->allocated ? packet->len : packet->size); 
  
      pseudo_udp.saddr    = packet->saddr;
      pseudo_udp.daddr    = packet->daddr;
      pseudo_udp.zero     = 0;
      pseudo_udp.protocol = IPPROTO_TCP;
      pseudo_udp.len      = htons(SIZE_TCP + dataLen);
  
      size = SIZE_PSEUDO_UDP + SIZE_TCP + dataLen;
      buf = (u_char *)malloc(size);
      memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
      memcpy(buf + SIZE_PSEUDO_UDP, tcp, SIZE_TCP);
      memcpy(buf + SIZE_PSEUDO_UDP + SIZE_TCP, (packet->allocated ? packet->data : packet->buf), dataLen);
  
      sum = cksum(buf, size);
  
      free(buf);
  
      return sum;
  
  }
  
  void CTCP::init()
  {
      if (_isInited)
          return;
  
      _protoSock = CProtoSocket::instance();
      _network = CNetwork::instance();
      _network->init();
  
      _isInited = true;
      debug(DBG_DEFAULT, TAG "inited.");
  }
  
  CTCP::~CTCP()
  {
      log(TAG "desconstructed.\n");
  }
  
  int CTCP::send(packet_t *packet)
  {
      log(TAG "%s().\n", __func__);
      string key = keyOf(packet->saddr, packet->sport, packet->daddr, packet->dport);
      ConnMap::iterator it = _connPool.find(key);
  
      if (it == _connPool.end()) {
          error (TAG "%s(): no connection %s found.\n", __func__, key.c_str());
          return 0;
      }
  
      // put to queue and return
  
      // get connection send queue
      InetConnSock & sk = it->second;
      PacketQueue & sendQueue = sk.sendQueue;
  
      u_char *pBuf = packet->buf;
      int dataLeft = packet->size;
  
      while (dataLeft > 0) {
          // split it
          int dataLen = dataLeft;
  
          if (sendQueue.empty()) {
              // should allocate a new packet_t
              if (dataLen > cTCPMSS) {
                  dataLen = cTCPMSS;
              }
              dataLeft -= dataLen;
  
              // always allocate fixed size, if there is space left, filled by next time
              std::shared_ptr<packet_t> ppkt(new packet_t(cTCPMSS));
              ppkt->copyMetadata(*packet);
              ppkt->put(dataLen);
              memcpy(ppkt->data, pBuf, dataLen);
              pBuf += dataLen;
  
              TCP_PKT_CB(ppkt)->seq = sk.sendWin.nextSeq;
              uint32_t endSeq = sk.sendWin.nextSeq + dataLen - 1;
              TCP_PKT_CB(ppkt)->endSeq = endSeq;
              sk.sendWin.nextSeq = endSeq + 1;
  
              ppkt->proto = IPPROTO_TCP;
  
              sendQueue.emplace_back(ppkt);
          }
          else {
              log(TAG "%s(): none empty send queue not handled yet!.\n", __func__);
              std::shared_ptr<packet_t> &tail = sendQueue.back();
              if (tail->len == tail->size) {
                  // should allocate a new packet_t
              }
              else if (tail->size < cTCPMSS) {
                  // can copy some data here
              }
              else {
                  // should not happen
              }
          }
  
      }
  
      doSend(&sk);
  
      // actually, the copied bytes number should be returned
      return packet->size;
  
  }
  
  void CTCP::doSend(InetConnSock *ics)
  {
      log(TAG "%s().\n", __func__);
      PacketQueue & sendQueue = ics->sendQueue; 
  
      PacketQueue::iterator it = std::find_if(sendQueue.begin(), sendQueue.end(), [=](const PacketQueue::value_type &ppkt){
          return TCP_PKT_CB(ppkt)->seq == ics->sendWin.lastSeq;
      });
  
      if (it == sendQueue.end()) {
          log(TAG "%s(): no match sequence packet found.\n", __func__);
          return ;
      }
  
      // should check send & receive window first 
  
      std::shared_ptr<packet_t> &ppkt = *it;
  
      packet_t pkt(ppkt->len + cMaxHeaderLen); 
      pkt.copyMetadata(*ppkt);
  
      ics->sendWin.nextAck = TCP_PKT_CB(ppkt)->seq + ppkt->len;
  
      __doSend(&pkt, ics, 0, ppkt->buf, ppkt->len);
  
  }
  
  void CTCP::__doSend(packet_t *packet, InetConnSock *ics, uint8_t flags, uint8_t *buf, uint32_t size)
  {
      packet->reserve(cMaxHeaderLen);
  
      // copy payload
      packet->put(size);
      memcpy(packet->data, buf, size); 
  
      tcphdr_t tcphdr;
      tcphdr.th_sport = ics->ics_port;
      tcphdr.th_dport = ics->ics_peerPort;
      tcphdr.th_seq = htonl(ics->sendWin.lastSeq); 
      tcphdr.th_ack = htonl(ics->recvWin.lastAck);
      tcphdr.th_offx2 = 0x50;
      tcphdr.th_flags = flags;
      tcphdr.th_win = htons(ics->recvWin.size);
      tcphdr.th_sum = 0;
      tcphdr.th_urp = 0;
  
      tcphdr.th_sum = cksum_tcp(&tcphdr, packet);
  
      packet->push(SIZE_TCP);
      memcpy(packet->data, &tcphdr, sizeof(tcphdr));
  
      log(TAG "%s send seq=%d,ack=%d.\n", keyOf(ics).c_str(), ics->sendWin.lastSeq, ics->recvWin.lastAck);
      _network->send(packet);
  
  }
  
  void CTCP::sendNoData(packet_t *packet, InetConnSock *ics, uint8_t flags)
  {
      packet->saddr = ics->ics_addr;
      packet->sport = ics->ics_port;
      packet->daddr = ics->ics_peerAddr;
      packet->dport = ics->ics_peerPort;
  
      packet->proto = IPPROTO_TCP; 
      packet->reserve(cMaxHeaderLen); 
  
      tcphdr_t thdr;
      thdr.th_sport = ics->ics_port;
      thdr.th_dport = ics->ics_peerPort;
      thdr.th_seq = htonl(ics->sendWin.lastSeq);
      thdr.th_ack = htonl(ics->recvWin.lastAck);
      thdr.th_offx2 = 0x50;
      thdr.th_flags = flags;
      thdr.th_win = ics->recvWin.size;
      thdr.th_sum = 0;
      thdr.th_urp = 0;
  
      packet_t emptyPkt;
      emptyPkt.copyMetadata(*packet);
      thdr.th_sum = cksum_tcp(&thdr, &emptyPkt);
  
      packet->push(SIZE_TCP);
      memcpy(packet->data, &thdr, sizeof(tcphdr_t));
  
      log(TAG "%s send seq=%d,ack=%d.\n", keyOf(ics).c_str(), ics->sendWin.lastSeq, ics->recvWin.lastAck);
      _network->send(packet);
  
  }
  
  int CTCP::received(packet_t *pkt)
  {
      log(TAG "%s().\n", __func__);
  
      tcphdr_t *tcphdr = (tcphdr_t *)pkt->data;
      pkt->sport = tcphdr->th_sport;
      pkt->dport = tcphdr->th_dport;
  
      log(TAG "%s(): before pull TCP header, pkt->size = %d, pkt->len = %d.\n", __func__, pkt->size, pkt->len);
      int sizeTCPHdr = TH_OFF(tcphdr) * 4;
      pkt->pull(sizeTCPHdr);
      log(TAG "%s(): after pull TCP header, pkt->size = %d, pkt->len = %d.\n", __func__, pkt->size, pkt->len);
  
      uint32_t seq = ntohl(tcphdr->th_seq);
      uint32_t ack = ntohl(tcphdr->th_ack);
  
      // check existing connection
      string key = keyOf(pkt->daddr, pkt->dport, pkt->saddr, pkt->sport);
      ConnMap::iterator it = _connPool.find(key); 
      if (it != _connPool.end()) {
          // check current connection state 
          InetConnSock *conn = &it->second;
          if (conn->ics_state == ESTABLISHED) {
              recvEstablished(conn, pkt, tcphdr);
          }
          else {
              recvStateProcess(conn, pkt, tcphdr);
          }
      }
      else {
          // try listening socket
          InetSockMap::iterator iter = _listenPool.find(pkt->dport);
          if (iter != _listenPool.end() && iter->second->sk_state == LISTEN) {
              log(TAG "find listen socket\n");
              recvListen(iter->second, pkt, tcphdr);
          }
          else {
              log(TAG "no connection or listen socket found, should send RST\n");
              // todo: reply RST
          }
      }
  
      return 0;
  
  }
  
  void CTCP::recvEstablished(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr)
  {
      log(TAG "%s().\n", __func__);
  
      uint32_t seq = ntohl(tcphdr->th_seq);
      uint32_t ack = ntohl(tcphdr->th_ack);
      if (tcphdr->th_flags & TH_RST) {
          log(TAG "%s(): RST received\n", __func__);
      }
      else if (tcphdr->th_flags & TH_FIN) {
          log(TAG "%s(): FIN received, send ACK\n", __func__);
          ics->sendWin.lastSeq = ack;
          ics->recvWin.lastAck = seq + 1;
          ics->ics_state = CLOSE_WAIT;
          ics->_inetSock._sock.state = SS_DISCONNECTING;
          log(TAG "%s(): change to state CLOSE_WAIT\n", __func__);
          packet_t pkt(cMaxHeaderLen);
          sendNoData(&pkt, ics, TH_ACK);
  
          // should wait all data transfered, do send FIN
          
          ics->ics_state = LAST_ACK;
          log(TAG "%s(): change to state LAST_ACK\n", __func__);
          packet_t pkt2(cMaxHeaderLen);
          sendNoData(&pkt2, ics, TH_FIN);
      }
      else {
          if(tcphdr->th_flags & TH_ACK){
              ics->recvWin.lastAck = ack;
              log(TAG "%s(): ack=%d\n", __func__, ack);
          }
          else {
          }
  
          uint32_t dataLen = packet->len;
  
          if (dataLen <= 0) {
              // it's a pure header, no more process is needed, just return 
              return ;
          }
  
          // if checksum right
          PacketQueue &recvQueue = ics->recvQueue;
          if (recvQueue.empty()) {
              // allocate a new packet_t and copy data
              // (don't worry the new buffer size less than received bytes, it won't happed)
              std::shared_ptr<packet_t> ppkt(new packet_t(cBlockSize));
              
              ppkt->put(dataLen);
              memcpy(ppkt->data, packet->data, dataLen);
              // if you append data to it, remember move data pointer to the end of previous first, then move back 
  
              recvQueue.emplace_back(ppkt); 
              _protoSock->bytesAvailable(ics);
  
              // send ack
              ics->recvWin.lastAck = seq + dataLen;
              packet_t pkt(cMaxHeaderLen);
              sendNoData(&pkt, ics, TH_ACK);
          }
          else {
              log(TAG "%s(): none empty receive queue not handled.\n", __func__);
              std::shared_ptr<packet_t> &back = recvQueue.back(); 
              if (back->isFull()) {
                  // allocate a new packet_t and copy data
              }
              else {
                  // append data to this packet_t, if not enough, allocate a new one
              }
          }
      }
  }
  
  void CTCP::recvStateProcess(InetConnSock *ics, packet_t *packet, tcphdr_t *tcphdr)
  {
      log(TAG "%s().\n", __func__);
  
      uint32_t seq = ntohl(tcphdr->th_seq);
      uint32_t ack = ntohl(tcphdr->th_ack);
      log(TAG "%s(): seq=%d, ack=%d.\n", __func__, seq, ack);
  
      switch (tcphdr->th_flags) {
          default:
              log(TAG "%s(): unknown flag: %d.\n", __func__, tcphdr->th_flags);
              break;
          case TH_FIN:
              {
                  if (ics->ics_state == FIN_WAIT_1 || ics->ics_state == FIN_WAIT_2) {
                      if (ics->ics_state == FIN_WAIT_1) {
                          log(TAG "%s(): both closing\n", __func__);
                      }
                      log(TAG "%s(): close side received FIN, send ACK\n", __func__);
                      ics->ics_state = TIME_WAIT; 
                      log(TAG "%s(): change to state TIME_WAIT\n", __func__);
  
                      ics->sendWin.lastSeq = ack;
                      ics->recvWin.lastAck = seq + 1;
                      packet_t pkt(cMaxHeaderLen);
                      sendNoData(&pkt, ics, TH_ACK);
  
                      // should start TIME_WAIT timer here
                      log(TAG "%s(): change to state CLOSED\n", __func__);
                      ics->ics_state = CLOSED;
                      string name = keyOf(ics);
                      _connPool.erase(name);
  
                      _protoSock->closed(name);
                  }
                  else {
                      log (TAG "%s(): received FIN but not FIN_WAIT_1 nor FIN_WAIT_2 state\n", __func__);
                  }
                  break;
              }
          case TH_SYN:
              {
                  log(TAG "%s(): SYN.\n", __func__);
                  break;
              }
          case TH_SYN | TH_ACK:
              {
                  log(TAG "%s(): SYN and ACK.\n", __func__); 
                  if (ics->ics_state == SYN_SENT) {
                      // todo: send ACK, connect() finish 
                      if (ics->sendWin.lastSeq + 1 != ack) {
                          log(TAG "%s(): TH_SYN | TH_ACK ack not match, lastSeq=%d, ack=%d!\n", __func__, ics->sendWin.lastSeq, ack);
                      }
                      ics->sendWin.lastSeq = ack;
                      ics->sendWin.nextSeq = ack;
                      ics->recvWin.lastAck = seq + 1;
  
                      packet_t pack(cMaxHeaderLen);
                      sendNoData(&pack, ics, TH_ACK);
  
                      // we established a connection at client side
                      ics->ics_state = ESTABLISHED;
                      _protoSock->connectFinished(keyOf(ics), ics); 
                  }
                  else {
                      // what's this?
                      log(TAG "%s(): get SYN and ACK but connection state is not SYN_SENT, just ignore...\n", __func__); 
                  }
                  break;
              }
          case TH_RST:
          case TH_ACK | TH_RST:
              {
                  log(TAG "%s(): RST(or ACK|RST).\n", __func__);
                  break;
              }
          case TH_PUSH:
              {
                  log(TAG "%s(): PUSH.\n", __func__);
                  break;
              }
          case TH_ACK:
              {
                  log(TAG "%s(): ACK.\n", __func__);
                  if (ics->ics_state == SYN_RCVD) {
                      // we established a connection at server side
                      ics->sendWin.lastSeq = ack;
                      ics->sendWin.nextSeq = ack;
                      ics->ics_state = ESTABLISHED;
                      _protoSock->accepted(keyOf(ics), ics);
                  }
                  else if (ics->ics_state == FIN_WAIT_1){
                      log(TAG "%s(): FIN_WAIT_1 received ACK\n", __func__);
                      ics->sendWin.lastSeq = ack;
                      ics->recvWin.lastAck = seq + 1;
                      ics->ics_state = FIN_WAIT_2;
                      log(TAG "%s(): change to state FIN_WAIT_2\n", __func__);
                  }
                  else if(ics->ics_state == LAST_ACK) {
                      ics->ics_state = CLOSED;
                      log(TAG "%s(): change to state CLOSED\n", __func__);
  
                      string name = keyOf(ics);
                      _connPool.erase(name);
  
                      _protoSock->closed(name);
                  }
                  else {
                      log(TAG "%s(): a connection received ACK but state neither SYN_RCVD nor ESTABLISHED, state=%d.\n", __func__, ics->ics_state);
                  }
                  break;
              }
          case TH_URG:
              {
                  log(TAG "%s(): URG.\n", __func__);
                  break;
              }
      }
  }
  
  void CTCP::recvListen(InetSock *sock, packet_t *packet, tcphdr_t *tcphdr)
  {
      uint32_t seq = ntohl(tcphdr->th_seq);
      uint32_t ack = ntohl(tcphdr->th_ack);
      log(TAG "%s(): seq=%d,ack=%d\n", __func__, seq, ack);
  
      // the listen socket only recognize SYN
      if (tcphdr->th_flags == TH_SYN) {
          // create a new socket and let:
          //
          // sk_state = SYN_RCVD
          // CTL = SYN, ACK
          log(TAG "%s(): listened SYN.\n", __func__);
          InetConnSock ics;
          ics._inetSock = *sock;
  
          ics.ics_peerAddr = packet->saddr;
          ics.ics_peerPort = packet->sport;
          ics.ics_state = SYN_RCVD;
  
          InetConnSock *conn = newConnection(&ics);
  
          // send CTL, Wed 14 Mar 2018 18:38:51 
          conn->sendWin.lastSeq = ack;
          conn->recvWin.lastAck = seq + 1;
          conn->recvWin.size = 0xffff;
          conn->sendWin.size = conn->recvWin.size >> 1;
  
          packet_t pack(cMaxHeaderLen);
          sendNoData(&pack, conn, TH_SYN | TH_ACK);
          log(TAG "%s(): replied ACK|SYN\n" ,__func__);
      }
      else {
          log(TAG "listen socket received flags not SYN.\n");
          // todo: reply RST
      }
  }
  
  void CTCP::connect(InetSock *sk)
  {
      log(TAG "%s()\n", __func__);
      // save to connection pool
      InetConnSock ics;
      ics._inetSock = *sk;
      ics.sendWin.lastSeq = 2018;
      ics.recvWin.lastAck = 0;
      ics.recvWin.size = 0xffff;
      ics.sendWin.size = ics.recvWin.size >> 1;
      ics.ics_state = SYN_SENT;
  
      string key = keyOf(&ics);
      _connPool.emplace(key, ics);
  
      // send SYN
      packet_t pkt(cMaxHeaderLen);
      sendNoData(&pkt, &ics, TH_SYN);
  
  }
  
  void CTCP::close(std::string name)
  {
      log(TAG "%s(): %s\n", __func__, name.c_str());
      ConnMap::iterator it = _connPool.find(name);
      if (it == _connPool.end()) {
          log (TAG "%s(): connection not found\n", __func__);
          return ;
      }
  
      InetConnSock * ics = &it->second;
      ics->ics_state = FIN_WAIT_1;
      log(TAG "%s(): change to state FIN_WAIT_1\n", __func__);
  
      // send FIN
      packet_t pkt(cMaxHeaderLen);
      sendNoData(&pkt, ics, TH_FIN);
  }
  
  string CTCP::keyOf(InetConnSock *ics)
  {
      return keyOf(ics->ics_addr, ics->ics_port, ics->ics_peerAddr, ics->ics_peerPort);
  }
  
  string CTCP::keyOf(struct in_addr localAddr, uint16_t localPort,
          struct in_addr peerAddr, uint16_t peerPort)
  {
      //return string(std::to_string(localAddr.s_addr) + "." + std::to_string(localPort) + ","
              //+ std::to_string(peerAddr.s_addr) + "." + std::to_string(peerPort));
      string key = string(inet_ntoa(localAddr)) + "." + std::to_string(ntohs(localPort)) + ","
          + string(inet_ntoa(peerAddr)) + "." + std::to_string(ntohs(peerPort));
      //log(TAG "%s(): %s.\n", __func__, key.c_str());
      return key;
  }
  
  InetConnSock * CTCP::newConnection(InetConnSock *ics)
  {
      ics->ics_sockfd = 0;            // 0 for unaccepted connection
  
      string key = keyOf(ics);
      auto pair = _connPool.emplace(key, *ics);// std::pair<map<string,InetConnSock>::iterator,bool>
      if (pair.second == true) {
          log (TAG "%s(): created new connection.\n", __func__);
      }
  
      return &pair.first->second;
  
  }
  
  void CTCP::listen(InetSock *sk) 
  {
      _listenPool.emplace(sk->sk_port, sk);
  }
  
  /* This source file must have a .cpp extension so that all C++ compilers
     recognize the extension without flags.  Borland does not know .cxx for
     example.  */
  #ifndef __cplusplus
  # error "A C compiler has been selected for C++."
  #endif
  
  /* Version number components: V=Version, R=Revision, P=Patch
     Version date components:   YYYY=Year, MM=Month,   DD=Day  */
  
  #if defined(__COMO__)
  # define COMPILER_ID "Comeau"
    /* __COMO_VERSION__ = VRR */
  # define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
  # define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)
  
  #elif defined(__INTEL_COMPILER) || defined(__ICC)
  # define COMPILER_ID "Intel"
    /* __INTEL_COMPILER = VRP */
  # define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
  # define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
  # if defined(__INTEL_COMPILER_UPDATE)
  #  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
  # else
  #  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
  # endif
  # if defined(__INTEL_COMPILER_BUILD_DATE)
    /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
  #  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
  # endif
  # if defined(_MSC_VER)
  #  define SIMULATE_ID "MSVC"
     /* _MSC_VER = VVRR */
  #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
  #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
  # endif
  
  #elif defined(__PATHCC__)
  # define COMPILER_ID "PathScale"
  # define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
  # define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
  # if defined(__PATHCC_PATCHLEVEL__)
  #  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
  # endif
  
  #elif defined(__clang__)
  # if defined(__apple_build_version__)
  #  define COMPILER_ID "AppleClang"
  #  define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
  # else
  #  define COMPILER_ID "Clang"
  # endif
  # define COMPILER_VERSION_MAJOR DEC(__clang_major__)
  # define COMPILER_VERSION_MINOR DEC(__clang_minor__)
  # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
  # if defined(_MSC_VER)
  #  define SIMULATE_ID "MSVC"
     /* _MSC_VER = VVRR */
  #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
  #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
  # endif
  
  #elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
  # define COMPILER_ID "Embarcadero"
  # define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
  # define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
  # define COMPILER_VERSION_PATCH HEX(__CODEGEARC_VERSION__     & 0xFFFF)
  
  #elif defined(__BORLANDC__)
  # define COMPILER_ID "Borland"
    /* __BORLANDC__ = 0xVRR */
  # define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
  # define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
  
  #elif defined(__WATCOMC__)
  # define COMPILER_ID "Watcom"
    /* __WATCOMC__ = VVRR */
  # define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
  # define COMPILER_VERSION_MINOR DEC(__WATCOMC__ % 100)
  
  #elif defined(__SUNPRO_CC)
  # define COMPILER_ID "SunPro"
  # if __SUNPRO_CC >= 0x5100
     /* __SUNPRO_CC = 0xVRRP */
  #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
  #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
  #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
  # else
     /* __SUNPRO_CC = 0xVRP */
  #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
  #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
  #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
  # endif
  
  #elif defined(__HP_aCC)
  # define COMPILER_ID "HP"
    /* __HP_aCC = VVRRPP */
  # define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
  # define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
  # define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)
  
  #elif defined(__DECCXX)
  # define COMPILER_ID "Compaq"
    /* __DECCXX_VER = VVRRTPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
  # define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
  # define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)
  
  #elif defined(__IBMCPP__)
  # if defined(__COMPILER_VER__)
  #  define COMPILER_ID "zOS"
  # else
  #  if __IBMCPP__ >= 800
  #   define COMPILER_ID "XL"
  #  else
  #   define COMPILER_ID "VisualAge"
  #  endif
     /* __IBMCPP__ = VRP */
  #  define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
  #  define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
  #  define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
  # endif
  
  #elif defined(__PGI)
  # define COMPILER_ID "PGI"
  # define COMPILER_VERSION_MAJOR DEC(__PGIC__)
  # define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
  # if defined(__PGIC_PATCHLEVEL__)
  #  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
  # endif
  
  #elif defined(_CRAYC)
  # define COMPILER_ID "Cray"
  # define COMPILER_VERSION_MAJOR DEC(_RELEASE)
  # define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
  
  #elif defined(__TI_COMPILER_VERSION__)
  # define COMPILER_ID "TI"
    /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
  # define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
  # define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
  # define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
  
  #elif defined(__SCO_VERSION__)
  # define COMPILER_ID "SCO"
  
  #elif defined(__GNUC__)
  # define COMPILER_ID "GNU"
  # define COMPILER_VERSION_MAJOR DEC(__GNUC__)
  # define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
  # if defined(__GNUC_PATCHLEVEL__)
  #  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
  # endif
  
  #elif defined(_MSC_VER)
  # define COMPILER_ID "MSVC"
    /* _MSC_VER = VVRR */
  # define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
  # define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
  # if defined(_MSC_FULL_VER)
  #  if _MSC_VER >= 1400
      /* _MSC_FULL_VER = VVRRPPPPP */
  #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
  #  else
      /* _MSC_FULL_VER = VVRRPPPP */
  #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
  #  endif
  # endif
  # if defined(_MSC_BUILD)
  #  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
  # endif
  
  /* Analog VisualDSP++ >= 4.5.6 */
  #elif defined(__VISUALDSPVERSION__)
  # define COMPILER_ID "ADSP"
    /* __VISUALDSPVERSION__ = 0xVVRRPP00 */
  # define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)
  # define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)
  # define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)
  
  /* Analog VisualDSP++ < 4.5.6 */
  #elif defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
  # define COMPILER_ID "ADSP"
  
  /* IAR Systems compiler for embedded systems.
     http://www.iar.com */
  #elif defined(__IAR_SYSTEMS_ICC__ ) || defined(__IAR_SYSTEMS_ICC)
  # define COMPILER_ID "IAR"
  
  #elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)
  # define COMPILER_ID "MIPSpro"
  # if defined(_SGI_COMPILER_VERSION)
    /* _SGI_COMPILER_VERSION = VRP */
  #  define COMPILER_VERSION_MAJOR DEC(_SGI_COMPILER_VERSION/100)
  #  define COMPILER_VERSION_MINOR DEC(_SGI_COMPILER_VERSION/10 % 10)
  #  define COMPILER_VERSION_PATCH DEC(_SGI_COMPILER_VERSION    % 10)
  # else
    /* _COMPILER_VERSION = VRP */
  #  define COMPILER_VERSION_MAJOR DEC(_COMPILER_VERSION/100)
  #  define COMPILER_VERSION_MINOR DEC(_COMPILER_VERSION/10 % 10)
  #  define COMPILER_VERSION_PATCH DEC(_COMPILER_VERSION    % 10)
  # endif
  
  /* This compiler is either not known or is too old to define an
     identification macro.  Try to identify the platform and guess that
     it is the native compiler.  */
  #elif defined(__sgi)
  # define COMPILER_ID "MIPSpro"
  
  #elif defined(__hpux) || defined(__hpua)
  # define COMPILER_ID "HP"
  
  #else /* unknown compiler */
  # define COMPILER_ID ""
  
  #endif
  
  /* Construct the string literal in pieces to prevent the source from
     getting matched.  Store it in a pointer rather than an array
     because some compilers will just produce instructions to fill the
     array rather than assigning a pointer to a static array.  */
  char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
  #ifdef SIMULATE_ID
  char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
  #endif
  
  #ifdef __QNXNTO__
  char const* qnxnto = "INFO" ":" "qnxnto";
  #endif
  
  /* Identify known platforms by name.  */
  #if defined(__linux) || defined(__linux__) || defined(linux)
  # define PLATFORM_ID "Linux"
  
  #elif defined(__CYGWIN__)
  # define PLATFORM_ID "Cygwin"
  
  #elif defined(__MINGW32__)
  # define PLATFORM_ID "MinGW"
  
  #elif defined(__APPLE__)
  # define PLATFORM_ID "Darwin"
  
  #elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
  # define PLATFORM_ID "Windows"
  
  #elif defined(__FreeBSD__) || defined(__FreeBSD)
  # define PLATFORM_ID "FreeBSD"
  
  #elif defined(__NetBSD__) || defined(__NetBSD)
  # define PLATFORM_ID "NetBSD"
  
  #elif defined(__OpenBSD__) || defined(__OPENBSD)
  # define PLATFORM_ID "OpenBSD"
  
  #elif defined(__sun) || defined(sun)
  # define PLATFORM_ID "SunOS"
  
  #elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
  # define PLATFORM_ID "AIX"
  
  #elif defined(__sgi) || defined(__sgi__) || defined(_SGI)
  # define PLATFORM_ID "IRIX"
  
  #elif defined(__hpux) || defined(__hpux__)
  # define PLATFORM_ID "HP-UX"
  
  #elif defined(__HAIKU__)
  # define PLATFORM_ID "Haiku"
  
  #elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
  # define PLATFORM_ID "BeOS"
  
  #elif defined(__QNX__) || defined(__QNXNTO__)
  # define PLATFORM_ID "QNX"
  
  #elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
  # define PLATFORM_ID "Tru64"
  
  #elif defined(__riscos) || defined(__riscos__)
  # define PLATFORM_ID "RISCos"
  
  #elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
  # define PLATFORM_ID "SINIX"
  
  #elif defined(__UNIX_SV__)
  # define PLATFORM_ID "UNIX_SV"
  
  #elif defined(__bsdos__)
  # define PLATFORM_ID "BSDOS"
  
  #elif defined(_MPRAS) || defined(MPRAS)
  # define PLATFORM_ID "MP-RAS"
  
  #elif defined(__osf) || defined(__osf__)
  # define PLATFORM_ID "OSF1"
  
  #elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
  # define PLATFORM_ID "SCO_SV"
  
  #elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
  # define PLATFORM_ID "ULTRIX"
  
  #elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
  # define PLATFORM_ID "Xenix"
  
  #else /* unknown platform */
  # define PLATFORM_ID ""
  
  #endif
  
  /* For windows compilers MSVC and Intel we can determine
     the architecture of the compiler being used.  This is because
     the compilers do not have flags that can change the architecture,
     but rather depend on which compiler is being used
  */
  #if defined(_WIN32) && defined(_MSC_VER)
  # if defined(_M_IA64)
  #  define ARCHITECTURE_ID "IA64"
  
  # elif defined(_M_X64) || defined(_M_AMD64)
  #  define ARCHITECTURE_ID "x64"
  
  # elif defined(_M_IX86)
  #  define ARCHITECTURE_ID "X86"
  
  # elif defined(_M_ARM)
  #  define ARCHITECTURE_ID "ARM"
  
  # elif defined(_M_MIPS)
  #  define ARCHITECTURE_ID "MIPS"
  
  # elif defined(_M_SH)
  #  define ARCHITECTURE_ID "SHx"
  
  # else /* unknown architecture */
  #  define ARCHITECTURE_ID ""
  # endif
  
  #else
  #  define ARCHITECTURE_ID ""
  #endif
  
  /* Convert integer to decimal digit literals.  */
  #define DEC(n)                   \
    ('0' + (((n) / 10000000)%10)), \
    ('0' + (((n) / 1000000)%10)),  \
    ('0' + (((n) / 100000)%10)),   \
    ('0' + (((n) / 10000)%10)),    \
    ('0' + (((n) / 1000)%10)),     \
    ('0' + (((n) / 100)%10)),      \
    ('0' + (((n) / 10)%10)),       \
    ('0' +  ((n) % 10))
  
  /* Convert integer to hex digit literals.  */
  #define HEX(n)             \
    ('0' + ((n)>>28 & 0xF)), \
    ('0' + ((n)>>24 & 0xF)), \
    ('0' + ((n)>>20 & 0xF)), \
    ('0' + ((n)>>16 & 0xF)), \
    ('0' + ((n)>>12 & 0xF)), \
    ('0' + ((n)>>8  & 0xF)), \
    ('0' + ((n)>>4  & 0xF)), \
    ('0' + ((n)     & 0xF))
  
  /* Construct a string literal encoding the version number components. */
  #ifdef COMPILER_VERSION_MAJOR
  char const info_version[] = {
    'I', 'N', 'F', 'O', ':',
    'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
    COMPILER_VERSION_MAJOR,
  # ifdef COMPILER_VERSION_MINOR
    '.', COMPILER_VERSION_MINOR,
  #  ifdef COMPILER_VERSION_PATCH
     '.', COMPILER_VERSION_PATCH,
  #   ifdef COMPILER_VERSION_TWEAK
      '.', COMPILER_VERSION_TWEAK,
  #   endif
  #  endif
  # endif
    ']','\0'};
  #endif
  
  /* Construct a string literal encoding the version number components. */
  #ifdef SIMULATE_VERSION_MAJOR
  char const info_simulate_version[] = {
    'I', 'N', 'F', 'O', ':',
    's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
    SIMULATE_VERSION_MAJOR,
  # ifdef SIMULATE_VERSION_MINOR
    '.', SIMULATE_VERSION_MINOR,
  #  ifdef SIMULATE_VERSION_PATCH
     '.', SIMULATE_VERSION_PATCH,
  #   ifdef SIMULATE_VERSION_TWEAK
      '.', SIMULATE_VERSION_TWEAK,
  #   endif
  #  endif
  # endif
    ']','\0'};
  #endif
  
  /* Construct the string literal in pieces to prevent the source from
     getting matched.  Store it in a pointer rather than an array
     because some compilers will just produce instructions to fill the
     array rather than assigning a pointer to a static array.  */
  char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
  char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";
  
  
  
  
  /*--------------------------------------------------------------------------*/
  
  int main(int argc, char* argv[])
  {
    int require = 0;
    require += info_compiler[argc];
    require += info_platform[argc];
  #ifdef COMPILER_VERSION_MAJOR
    require += info_version[argc];
  #endif
  #ifdef SIMULATE_ID
    require += info_simulate[argc];
  #endif
  #ifdef SIMULATE_VERSION_MAJOR
    require += info_simulate_version[argc];
  #endif
    (void)argv;
    return require;
  }
  #include "Util.h"
  #include <cstdarg>
  
  File fileDebug("debug.txt");
  FILE *debugOut = fileDebug.get();
  
  void log(const char *fmt, ...)
  {
      va_list va;
      va_start(va, fmt);
      vfprintf(stdout, fmt, va);
      va_end(va);
  }
  
  void debug(const char *fmt, ...) 
  {
  #ifdef DEBUG
      va_list va;
      va_start(va, fmt);
      vfprintf(debugOut, fmt, va); 
      va_end(va);
      fflush(debugOut);
  #endif 
  }
  
  void debug(int flag, const char *fmt, ...) 
  {
  #ifdef DEBUG
      if (flag & DBG_PREFIX) 
          fprintf(debugOut, "DEBUG: ");
      va_list va;
      va_start(va, fmt);
      vfprintf(debugOut, fmt, va); 
      va_end(va);
      if (flag & DBG_NEWLINE) 
          fprintf(debugOut, "\n");
      fflush(debugOut);
  #endif 
  }
  
  void error(const char *fmt, ...)
  {
      fprintf(stderr, "ERROR: ");
      va_list va;
      va_start(va, fmt);
      vfprintf(stderr, fmt, va);
      va_end(va);
  }
  
  const char * tok2str(const tok_t * tokp,
          const char * default_msg,
          int v)
  {
  
      static char buf[SIZE_TOK_BUF];
  
      if(tokp != NULL) {
          while(tokp->s != NULL) {
              if(tokp->v == v)
                  return tokp->s;
              else 
                  ++tokp;
          }
      }
  
      snprintf(buf, SIZE_TOK_BUF, "%s", default_msg);
      return (const char *)buf;
  }
  
  /*
   * DemoTimeClient - UDP Demo
   *
   * Send "time" to time server, print the feedback.
   * */
  #include <cstdio>
  #include <cstring>
  #include <string>
  #include "Socket.h"
  
  const char * const cDstAddrStr  = "211.67.27.254";
  const unsigned short cDstPort   = 1618;
  
  void usage(const char *appName) 
  {
      printf("Default address use %s:%d\n", cDstAddrStr, cDstPort);
      printf("To change it use addtional parameters:\n\t%s <ip> <port>\n", appName);
      printf("\n----------\n\n");
  }
  
  int main(int argc, char *argv[])
  {
      usage(argv[0]);
  
      // create a socket
      CSocket socket;
      int sockfd;
      if ( (sockfd = socket.socket(AF_INET, SOCK_DGRAM, 0)) <= 0) {
          fprintf(stderr, "Failed socket().\n");
          return -1;
      }
  
      // set target address
      struct sockaddr_in dstAddr;
      dstAddr.sin_family = AF_INET;
  
      char dstAddrStr[20];
      unsigned short dstPort;
  
      strncpy(dstAddrStr, cDstAddrStr, strlen(cDstAddrStr) + 1);
      dstPort = cDstPort;
      if (argc > 1) {
          strncpy(dstAddrStr, argv[1], strlen(argv[1]) + 1);
      }
      if (argc > 2) {
          dstPort = std::stoi(argv[2]);
      }
  
      if (inet_aton(dstAddrStr, &dstAddr.sin_addr) <= 0) {
          fprintf(stderr, "Invalid address: %s\n", dstAddrStr);
          return -1;
      }
      dstAddr.sin_port = htons(dstPort);
  
      printf("Target %s:%d.\n", dstAddrStr, dstPort);
  
      // send
      const char *text = "time";
      int len = strlen(text);
      int byteSend = socket.sendto(text, len, 0, (const sockaddr*)&dstAddr, sizeof(dstAddr));
  
      char buf[1024 + 1];
      socklen_t socklen = sizeof(dstAddr);
      if (byteSend > 0) {
          int byteRecv = socket.recvfrom(buf, 1024, 0, (struct sockaddr *)&dstAddr, &socklen);
  
          if (byteRecv > 0) {
              buf[byteRecv] = '\0';
              printf("> %s\n", buf);
          }
          else {
              fprintf(stderr, "Failed receive.\n");
          }
      }
      else {
          fprintf(stderr, "Failed sendto().\n");
      }
  
      return 0;
  }
  
  
  /*
   * The injector take user input as a datagram inject to network.
   * */
  
  #define APP_NAME		"injector"
  #define APP_DESC		"Injector example using libpcap"
  #define APP_COPYRIGHT	"Copyright (c) 2017 BiDong Gong (Antonio)"
  #define APP_DISCLAIMER	"THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM."
  
  #include <unistd.h>
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include <pcap.h>
  #include <arpa/inet.h>
  #include <linux/netdevice.h>
  #include "ether.h"
  #include "arp.h"
  #include "ip.h"
  #include "tcp.h"
  #include "udp.h"
  #include "netsimul.h"
  
  #include "Network.h"
  #include "Link.h"
  //#include "Hardware.h"
  
  #define SIZE_SEND_BUFFER 4096
  #define SIZE_IP_ADDR_STR 16
  #define SIZE_PORT_STR 5
  
  #define FRAGMENT_TEST 1
  
  const char poem[] = {
          "The farthest distance in the world\n"\
          "Is not the distance between life and death\n"\
          "But you don't know I love you when I stand in front of you\n"\
          "The farthest distance in the world\n"\
          "Is not you don't know I love when I stand in front of you\n"\
          "But I cannot say I love you when I love you so madly\n"\
          "The farthest distance in the world\n"\
          "Is not I cannot say I love you when I love you so madly\n"\
          "But I can only bury it in my heart dispite the unbearable yearing\n"\
          "The farthest distance in the world\n"\
          "Is not I can only bury it in my heart dispite the unbearable yearning\n"\
          "But we cannot be together when we love each other\n"\
          "The farthest distance in the world\n"\
          "Is not we cannot be together when we love each other\n"\
          "But we pretend caring nothing even we know love is unconquerable\n"\
          "The farthest distance in the world\n"\
          "Is not the distance between two trees\n"\
          "But the branches cannot depend on each other in wind even they grow from the same root\n"\
          "The farthest distance in the world\n"\
          "Is not the branches cannot depend on each other\n"\
          "But two stars cannot meet even they watch each other\n"\
          "The farthest distance in the world\n"\
          "Is not the track between two stars\n"\
          "But nowhere to search in a tick after two tracks join\n"\
          "The farthest distance in the world\n"\
          "Is not nowhere to search in a tick\n"\
          "But doomed not to be together before they meet\n"\
          "The farthest distance in the world\n"\
          "Is the distance between fish and bird\n"\
          "One is in the sky, another is in the sea\n"\
          "\n"\
          "The farthest distance in the world\n"\
          "Is the distance between fish and bird\n"\
          "One is in the sky, another is in the sea\n"\
          "\n"\
          "The farthest distance in the world\n"\
          "Is the distance between fish and bird\n"\
          "One is in the sky, another is in the sea\n"
  };
  
  void handle_user_input(pcap_t * handler);
  
  void handle_inject(pcap_t *handler, packet_t *packet);
  
  void encap_tcp(pcap_t *handler, packet_t *packet);
  
  void encap_udp(pcap_t *handler, packet_t *packet);
  
  void encap_ip(pcap_t *handler, packet_t *packet);
  
  void encap_ether(pcap_t *handler, packet_t *packet);
  
  int send_packet(pcap_t *handler, const u_char *buf, size_t size);
  
  /*
   * app name/banner
   */
  void print_app_banner()
  {
  
  	printf("%s - %s\n", APP_NAME, APP_DESC);
  	printf("%s\n", APP_COPYRIGHT);
  	printf("%s\n", APP_DISCLAIMER);
  	printf("\n");
  
  }
  
  /*
   * Send out packet to network
   *
   * @handler     A pcap_t handler use to inject packet to network
   * @buf         The packet to send
   * @size        The packet size
   * */
  int send_packet(pcap_t *handler, const u_char *buf, size_t size)
  {
  
      int bytes_send;
  
      bytes_send = pcap_inject(handler, buf, size);
      if(bytes_send == -1) {
          fprintf(stderr, "Send packet failed.");
      }
      else {
          printf("Injected packet to network (%d bytes).\n", bytes_send);
      }
  
      return bytes_send;
  
  }
  
  void encap_tcp(pcap_t *handler, packet_t *packet)
  {
  
      send_packet(handler, packet->buf, packet->size);
      /*int bytes_send;                                                  */
  
      /*bytes_send = send_packet(handler, packet->buf, packet->size);    */
      /*if(bytes_send == -1) {                                           */
      /*    fprintf(stderr, "Send packet failed");                       */
      /*}                                                                */
      /*else {                                                           */
      /*    printf("Injected packet to network (%d bytes).", bytes_send);*/
      /*}                                                                */
  
  }
  
  uint16_t cksum(const u_char *const buf, size_t size)
  {
      uint32_t sum;
      uint16_t *p = (uint16_t *)buf;
  
      sum = 0;
      while(size > 1) {
          sum += *p++;
          size -= 2;
      }
  
      // padding as needed
      if(size == 1) {
          sum += *((u_char *)p);
      }
  
      while(sum >> 16)
          sum = (sum & 0xFFFF) + (sum >> 16);
  
      return (uint16_t)((~sum) & 0xFFFF);
  }
  
  uint16_t cksum_udp(const udphdr_t *const udp, const packet_t *const packet)
  {
  
      uint16_t sum;
      u_char *buf;
      size_t size;
  
      pseudo_udp_t pseudo_udp;
  
      pseudo_udp.saddr    = packet->saddr;
      pseudo_udp.daddr    = packet->daddr;
      pseudo_udp.zero     = 0;
      pseudo_udp.protocol = IPPROTO_UDP;
      pseudo_udp.len      = udp->uh_len;
  
      size = SIZE_PSEUDO_UDP + SIZE_UDP + packet->size;
      buf = (u_char *)malloc(size);
      memcpy(buf, &pseudo_udp, SIZE_PSEUDO_UDP);
      memcpy(buf+SIZE_PSEUDO_UDP, udp, SIZE_UDP);
      memcpy(buf+SIZE_PSEUDO_UDP+SIZE_UDP, packet->buf, packet->size);
  
      sum = cksum(buf, size);
  
      free(buf);
  
      return sum;
  
  }
  
  void encap_udp(pcap_t *handler, packet_t *packet)
  {
  
      udphdr_t udp; 
  
      u_char *buf;
      size_t size_new;
  
      size_new = SIZE_UDP + packet->size;
  
      /*create UDP header*/
      udp.uh_sport    = htons(packet->sport);
      udp.uh_dport    = htons(packet->dport);
      udp.uh_len      = htons(size_new);
      udp.uh_sum      = 0;
  
      udp.uh_sum      = cksum_udp(&udp, packet);
  
      /*add UDP header*/
      buf = (u_char*)malloc(size_new);            // to be free() [1]
      memcpy(buf, &udp, SIZE_UDP);
      memcpy(buf+SIZE_UDP, packet->buf, packet->size);
      packet->buf     = buf;
      packet->size    = size_new;
  
      encap_ip(handler, packet);
  
  }
  
  void encap_udp2(pcap_t *handler, packet_t *packet)
  {
  
      // make a copy of original data
      int sizeUDPHdr = 8;         // size in bytes
      int sizeIPHdr = 20;
      int sizeEtherHdr = 14;
      int sizeHdr = sizeUDPHdr + sizeIPHdr + sizeEtherHdr;
  
      // allocate more space include header
      packet_t pkt(sizeHdr + packet->size);
      pkt.copyMetadata(*packet);
  
      pkt.proto = IPPROTO_UDP;
  
      // reserve space for header
      pkt.reserve(sizeHdr);
  
      // copy payload
      pkt.put(packet->size);
      memcpy(pkt.data, packet->buf, packet->size);
  
      // prepare UDP header
      udphdr_t udp; 
      size_t size_new = SIZE_UDP + packet->size;
  
      udp.uh_sport    = htons(packet->sport);
      udp.uh_dport    = htons(packet->dport);
      udp.uh_len      = htons(size_new);
      udp.uh_sum      = 0;
  
      udp.uh_sum      = cksum_udp(&udp, packet);
  
      // push UDP header space
      pkt.push(SIZE_UDP);
  
      // copy UDP header
      memcpy(pkt.data, &udp, SIZE_UDP);
  
      // call network to do next work
      CNetwork *network = CNetwork::instance();
      network->send(&pkt);
  
  }
  
  uint16_t cksum_ip(const iphdr_t * const ip)
  {
  
      return cksum((u_char *)ip, SIZE_IP);
  
  }
  
  void encap_ip(pcap_t *handler, packet_t *packet)
  {
  
      iphdr_t ip;
  
      u_char *buf;
      size_t size_new;
  
      size_new = SIZE_IP + packet->size;
  
      /*create IP header*/
      ip.ip_vhl   = 0x45;
      ip.ip_tos   = 0;
      ip.ip_len   = htons(size_new);
      ip.ip_id    = htons(0xF96D);
      ip.ip_off   = htons(IP_DF);     // don't fragment
      ip.ip_ttl   = IPDEFTTL;         // default TTL
      ip.ip_p     = INJECT_OP_TCP(packet) ? IPPROTO_TCP : IPPROTO_UDP;
      ip.ip_sum   = 0;
      ip.ip_src   = packet->saddr;
      ip.ip_dst   = packet->daddr;
  
      ip.ip_sum   = cksum_ip(&ip);
  
      /*printf("Debug - header length: %d\n", IP_HL(&ip));                    */
      /*printf("Debug - total length: %d(%d)\n", ip.ip_len, ntohs(ip.ip_len));*/
      /*printf("Debug - protocol: %d\n", ip.ip_p);                            */
      /*printf("Debug - src: %s\n", inet_ntoa(ip.ip_src));                    */
      /*printf("Debug - dst: %s\n", inet_ntoa(ip.ip_dst));                    */
  
      /*add IP header*/
      buf = (u_char*)malloc(size_new);
      memcpy(buf, &ip, SIZE_IP);
      memcpy(buf+SIZE_IP, packet->buf, packet->size);
      free(packet->buf);          // do free() [1]
      packet->buf     = buf;      // to be free() [2]
      packet->size    = size_new;
  
      packet->ept     = ETH_P_IP;
  
      //encap_ether(handler, packet);
  
      //CNetwork *network = CNetwork::instance();
      //network->send(packet);
      //CLink *link = CLink::instance();
      //link->send(packet);
  
      delete packet->buf;         // do free() [2]
  
  }
  
  void encap_ether(pcap_t *handler, packet_t *packet)
  {
      
      ethernethdr_t ether;
  
      struct ether_addr *shost, *dhost;
  
      const char *default_shost = "08:00:27:a8:01:cc";  // 192.168.0.5
      const char *default_dhost = "08:00:27:05:6e:fb";  // 192.168.0.3
  
      u_char *buf;
      size_t size_new;
      uint32_t fcs;                   // frame check sequence
  
      /*create Ethernet header*/
      ether.ether_type = htons(ETHERTYPE_IP);
  
      //shost = ether_aton(default_shost);
      shost = ether_aton(default_shost);
      memcpy(ether.ether_shost, shost, ETHER_ADDR_LEN);
      //dhost = ether_aton(default_dhost);
      dhost = ether_aton(default_dhost);
      memcpy(ether.ether_dhost, dhost, ETHER_ADDR_LEN);
  
      /*add Ethernet header*/
      size_new = SIZE_ETHERNET + packet->size + SIZE_ETHER_SUM;
      buf = (u_char*)malloc(size_new);
      memset(buf, 0, size_new);
      memcpy(buf, &ether, SIZE_ETHERNET);
      memcpy(buf+SIZE_ETHERNET, packet->buf, packet->size);
      fcs = 0;
      memcpy(buf+SIZE_ETHERNET+packet->size, &fcs, SIZE_ETHER_SUM);
  
      free(packet->buf);          // do free() [2]
      packet->buf     = buf;      // to be free() [3]
      packet->size    = size_new;
  
      //CHardware *hardware = CHardware::instance();
      //hardware->transmit(packet);
      //send_packet(handler, buf, size_new); 
  
      free(packet->buf);          // do free() [3]
  
  }
  
  void handle_inject(pcap_t *handler, packet_t *packet)
  {
  
      if(INJECT_OP_TCP(packet)) {
          printf("\nInject with TCP...\n");
          encap_tcp(handler, packet);
      }
      else {
          printf("\nInject with UDP2...\n");
          encap_udp2(handler, packet);
      }
  
  }
  
  void handle_user_input(pcap_t * handler)
  {
  
      packet_t packet;                    // inject packet 
      char buf[SIZE_SEND_BUFFER], ch;     // temporary input buffer
      int count;                          // inject message character count
      char saddr[16], daddr[16];          // source & destination ip address
      uint16_t sport, dport;              // source & destination port
      char tmpstr[16];
  
      const char *default_saddr = "192.168.0.5";
      default_saddr = inet_ntoa( CLink::instance()->getDefaultDevice()->ipAddr );
      //const char *default_daddr = "192.168.0.3";
      const char *default_daddr = "211.67.27.254";
      uint16_t default_sport = 1314;
      uint16_t default_dport = 1618;
  
  #if FRAGMENT_TEST==1
  
      printf("\nUsed test string, length=%ld\n\n", sizeof(poem));
  
      packet.buf = (unsigned char*)poem;
      packet.size = sizeof(poem);
  
  #else
  
      /*Enter inject message */
      printf("\nEnter message to inject (ends with an empty line):\n"); 
      count = 0;
      while(1) {
          ch = getchar();
          if(count < SIZE_SEND_BUFFER) {
              buf[count] = ch;
          }
          else {
              printf("\n--maximum characters meeted (%d), end of input--\n", SIZE_SEND_BUFFER);
              break;
          }
  
          if(count > 0 && ch == '\n' && buf[count-1] == '\n') {
              break;
          }
          ++count;
      }
      buf[count] = '\0';
      packet.buf = (u_char *)buf;
      packet.size = count;
  
  #endif
  
      printf("**MESSAGE TO SEND**\n\n%s\n\n", packet.buf);
  
      /*Determine inject protocol*/
      printf("Inject with TCP or UDP? [T/U]: "); 
      ch = getchar(); CLEAR();
      while (!(ch == 't' || ch == 'T' || ch == 'u' || ch == 'U')) {
          printf("Please enter T(t) or U(u): ");
          ch = getchar(); CLEAR();
      }
      packet.oper = ch;
  
      /*Determine inject source & destination*/
      printf("Sender ip address (default %s, use it just press <enter>): ", default_saddr);
      ch = getchar();
      if(ch == '\n') {
          strncpy(saddr, default_saddr, SIZE_IP_ADDR_STR);    
      }
      else {
          saddr[0] = ch;
          fgets(saddr+1, SIZE_IP_ADDR_STR, stdin);
          saddr[strlen(saddr)-1] = '\0';          // eliminate the newline character
      }
  
      printf("Sender port (default %d, use it just press <enter>): ", default_sport);
      ch = getchar();
      if(ch == '\n') {
          sport = default_sport;  
      }
      else {
          tmpstr[0] = ch;
          fgets(tmpstr+1, SIZE_PORT_STR, stdin);
          sport = atoi(tmpstr);
      }
  
      printf("Destination ip address (default %s, use it just press <enter>): ", default_daddr);
      ch = getchar();
      if(ch == '\n') {
          strncpy(daddr, default_daddr, SIZE_IP_ADDR_STR);    
      }
      else {
          daddr[0] = ch;
          fgets(daddr+1, SIZE_IP_ADDR_STR, stdin);
          daddr[strlen(daddr)-1] = '\0';          // eliminate the newline character
      }
  
      printf("Destination port (default %d, use it just press <enter>): ", default_dport);
      ch = getchar();
      if(ch == '\n') {
          dport = default_dport;  
      }
      else {
          tmpstr[0] = ch;
          fgets(tmpstr+1, SIZE_PORT_STR, stdin);
          dport = atoi(tmpstr);
      }
  
      if( inet_aton(saddr, &packet.saddr) == 0) {
          fprintf(stderr, "Invalid source address: %s\n", saddr); 
          exit(EXIT_FAILURE);
      }
      if( inet_aton(daddr, &packet.daddr) == 0) {
          fprintf(stderr, "Invalid destination address: %s\n", daddr); 
          exit(EXIT_FAILURE);
      }
      packet.sport = sport;
      packet.dport = dport;
  
      printf("\n%s:%d > %s:%d\n", saddr, packet.sport, daddr, packet.dport);
  
      handle_inject(handler, &packet);
  
  }
  
  int main(int argc, char** argv) {
      //CHardware * hardware = CHardware::instance();
      //hardware->init();
      //CLink *link = CLink::instance();
      //link->init();
      CNetwork::instance()->init();
  
      int k = 2;
      while (k-- > 0) {
          handle_user_input(nullptr);
  
          sleep(2);
      }
  
      return 0;
  }
  
  /*
   * Compile: (path = $NETSIMUL/src/test)
   *
   * :!g++ % ../Util.cpp -I../include -o testUtil
   * */
  #include "Util.h"
  
  int main()
  {
      debug("Hi?\n");
      debug("Hi? %d\n", 7);
      debug("Hi? %d %d\n", 7, 17);
      return 0;
  }
  
  /*
   * Simple ARP Sniffer.
   * To compile: g++ simple_arp_sniffer.cpp -o simple_arp_sniffer -lpcap
   * Run as root!
   * */
  
  #include <pcap.h>
  #include <netinet/in.h>
  #include <cstdlib>
  #include <cstring>
  
  //ARP Header, (assuming Ethernet+IPv4)
  #define ARP_REQUEST 1
  #define ARP_REPLY 2
  
  typedef struct arphdr {
      u_int16_t htype;        // Hardware Type
      u_int16_t ptype;        // Protocol Type
      u_char hlen;            // Hardware Address Length
      u_char plen;            // Protocol Address Length
      u_int16_t oper;         // Operation Code
      u_char sha[6];          // Sender harder address
      u_char spa[4];          // Sender IP address
      u_char tha[6];          // Target harder address
      u_char tpa[4];          // Target IP address
  } arphdr_t;
  
  #define MAXBYTES2CAPTURE 2048
  
  int main(int argc, char * argv[]) {
      int i = 0;
  
      bpf_u_int32 netaddr = 0, mask = 0;  // To store network address and netmask
  
      struct bpf_program filter;          // Place to store the BPF filter program
  
      char errbuf[PCAP_ERRBUF_SIZE];      // Error buffer
  
      pcap_t *descr = NULL;               // Network interface handler
  
      struct pcap_pkthdr pkthdr;          // Packet information(timestamp,size...)
  
      const unsigned char * packet = NULL;// Received raw data
  
      arphdr_t * arpheader = NULL;        // Pointer to the ARP header
      memset(errbuf, 0, PCAP_ERRBUF_SIZE);
  
      if(argc != 2) {
          printf("USAGE: simple_arp_sniffer <interface>\n");
          exit(1);
      }
  
      // Open network device for packet capture
      descr = pcap_open_live(argv[1], MAXBYTES2CAPTURE, 0, -1, errbuf);
      //descr = pcap_open_live(argv[1], MAXBYTES2CAPTURE, 0, 512, errbuf);
      
      // Look up info from the capture device.
      pcap_lookupnet(argv[1], &netaddr, &mask, errbuf);
  
      // Compiles the filter expression into a BPF filter program
      pcap_compile(descr, &filter, "arp", 1, mask);
  
      // Load the filter program into the packet capture 
      pcap_setfilter(descr, &filter);
  
      while(1) {
          // Get one packet
          packet = pcap_next(descr, &pkthdr);
  
          // Point to the ARP header
          arpheader = (struct arphdr *)(packet + 14);
  
          printf("\n\nReceived Packet Size: %d bytes\n", pkthdr.len);
          printf("Hardware type: %s\n", ((ntohs(arpheader->htype) == 1) ? "Ethernet" : "Unknown"));
          printf("Protocol type: %s\n", ((ntohs(arpheader->ptype) == 0x0800) ? "IPv4" : "Unknown"));
          printf("Operation: %s\n", ((ntohs(arpheader->oper) == ARP_REQUEST) ? "ARP Request" : "ARP Reply"));
  
          //If is Ethernet and IPv4, print packet contents
          if( ntohs(arpheader->htype) == 1 && ntohs(arpheader->ptype) == 0x0800) {
              printf("Sender MAC: ");
              for(i=0; i<6 ; ++i)
                  printf("%02X:", arpheader->sha[i]);
              printf("\nSender IP: ");
              for(i=0; i<4 ; ++i)
                  printf("%d.", arpheader->spa[i]);
              printf("\nTarget MAC: ");
              for(i=0; i<6 ; ++i)
                  printf("%02X:", arpheader->tha[i]);
              printf("\nTarget IP: ");
              for(i=0; i<4 ; ++i)
                  printf("%d.", arpheader->tpa[i]);
              printf("\n");
          }
      }
  
      return 0;
  }
  
  
  /*
   * DemoEchoClient - TCP Demo
   *
   * Send something like "hello" to echo server, print the reply.
   * */
  #include <cstdio>
  #include <cstring>
  #include <string>
  #include "Socket.h"
  
  const char * const cDstAddrStr  = "211.67.27.254";
  const unsigned short cDstPort   = 2333;
  
  void usage(const char *appName) 
  {
      printf("Default address use %s:%d\n", cDstAddrStr, cDstPort);
      printf("To change it use addtional parameters:\n\t%s <ip> <port>\n", appName);
      printf("\n----------\n\n");
  }
  
  int main(int argc, char *argv[])
  {
      usage(argv[0]);
  
      // create a socket
      CSocket socket;
      int sockfd;
      if ( (sockfd = socket.socket(AF_INET, SOCK_STREAM, 0)) <= 0) { 
          fprintf(stderr, "Failed socket().\n");
          return -1;
      }
  
      // set server address
      struct sockaddr_in svrAddr;
      svrAddr.sin_family = AF_INET;
  
      char svrAddrStr[20];
      unsigned short svrPort;
  
      strncpy(svrAddrStr, cDstAddrStr, strlen(cDstAddrStr) + 1);
      svrPort = cDstPort;
      if (argc > 1) {
          strncpy(svrAddrStr, argv[1], strlen(argv[1]) + 1);
      }
      if (argc > 2) {
          svrPort = std::stoi(argv[2]);
      }
  
      if (inet_aton(svrAddrStr, &svrAddr.sin_addr) <= 0) {
          fprintf(stderr, "Invalid address: %s\n", svrAddrStr);
          return -1;
      }
      svrAddr.sin_port = htons(svrPort);
  
      printf("Target %s:%d.\n", svrAddrStr, svrPort);
  
      // connect
      printf("Connecting server...");
      int success = socket.connect((const sockaddr*)&svrAddr, sizeof(svrAddr));
  
      if (success != -1) {
          // send
          printf("connected, will send 'hello'.\n");
          const char *text = "hello";
          int len = strlen(text);
          int byteSend = socket.send(text, len, 0);
  
          if (byteSend > 0) {
              printf("Send out 'hello'.\n");
              char buf[1024 + 1];
              socklen_t socklen = sizeof(svrAddr);
              printf("Receiving...\n");
              int byteRecv = socket.recv(buf, 1024, 0);
  
              if (byteRecv > 0) {
                  buf[byteRecv] = '\0';
                  printf("received: %s\n", buf);
              }
              else {
                  printf("failed recv().\n");
              }
          }
          else {
              printf("Send out 'hello' failed.\n");
          }
  
          socket.close();
      }
      else {
          printf("failed connect().\n");
      }
  
      return 0;
  
  }
  
  /*
   * DemoEchoServer - TCP Demo
   *
   * Receive something from client and reply the same thing.
   * */
  
  #include "Socket.h"
  #include <string>
  #include <cstring>
  #include <time.h>
  
  const int cPort = 2333;
  const int cBufSize = 4096;
  const int cBackLog = 10;
  
  int main(int argc, char* argv[])
  {
      if (argc < 2) {
          printf("Usage: %s <ip> <port>.\n", argv[0]);
          return (0);
      }
  
      int sockfd;
      struct sockaddr_in svrAddr;
      CSocket socket;
  
      if ((sockfd = socket.socket(AF_INET, SOCK_STREAM, 0)) == -1) {
          printf("Failed socket().\n");
          return 0;
      }
  
      svrAddr.sin_family = AF_INET;
      inet_aton(argv[1], &svrAddr.sin_addr);
  
      if (argc > 2) {
          svrAddr.sin_port = htons(std::stoi(argv[2]));
      }
      else {
          svrAddr.sin_port = htons(cPort);
      }
  
      // bind local address
      if (socket.bind((struct sockaddr*)&svrAddr, sizeof(struct sockaddr)) == -1) {
          fprintf(stderr, "Failed bind().\n");
          return 0;
      }
      else {
          printf("%s run with %s:%d.\n\n", argv[0], argv[1], ntohs(svrAddr.sin_port));
      }
  
      // start listen 
      socket.listen(cBackLog);
  
      struct sockaddr_in client;
      unsigned int addrlen = sizeof(client);
  
      char buf[cBufSize];
      int k = 12;
      while (k-- > 0) {
          std::unique_ptr<CSocket> clientSocket = socket.accept((struct sockaddr*)&client, &addrlen);
  
          if (clientSocket->getFD() > 0) {
              printf("Accepted a connection: %d, %s:%d.\n", clientSocket->getFD(),
                      inet_ntoa(client.sin_addr), ntohs(client.sin_port));
              int bytesRecv = clientSocket->recv(buf, cBufSize, 0);
              if (bytesRecv > 0) {
                  // print received message
                  buf[bytesRecv] = '\0';
                  printf("Server received: %s.\n", buf);
  
                  // reply client
                  clientSocket->send(buf, bytesRecv, 0);
                  printf("Replied client: %s.\n", buf);
              }
              else {
                  fprintf(stderr, "Server receive error, bytesRecv = %d.\n", bytesRecv);
              }
          }
          else {
              fprintf(stderr, "Failed accept connection.\n");
          }
  
      }
  
      return 0;
  
  }
  
  /*
   * Echo server.
   *
   * Repeat received message to client.
   *
   * date: Sat 11 Nov 2017 09:58:27 
   * */
  #include <arpa/inet.h>
  #include <netinet/ip.h>
  #include <unistd.h>
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include "echoapp.h"
  
  class CEchoServer {
      private:
          struct sockaddr_in _svraddr;
          int _svrsock;
          uint16_t _port;
  
      public:
          CEchoServer() :
              _port(cDefaultPort)
          {
              init();
          }
          CEchoServer(uint16_t port) : 
              _port(port)
          {
              init();
          }
  
          ~CEchoServer() 
          {
              close(_svrsock);
          }
  
          void init();
          void run();
          void handleClient(const struct sockaddr_in *cliaddr, const char *msg, size_t bytes_recv);
  
          static uint16_t cDefaultPort;
  
  };
  
  uint16_t CEchoServer::cDefaultPort = 1314;
  
  void CEchoServer::init() 
  {
  
      _svraddr.sin_family         = AF_INET;
      _svraddr.sin_port           = htons(_port);
      _svraddr.sin_addr.s_addr    = INADDR_ANY;
  
      if( (_svrsock = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
          fprintf(stderr, "socket error.\n");
          exit(EXIT_FAILURE);
      }
  
      if ( bind(_svrsock, (struct sockaddr *)&_svraddr, sizeof(_svraddr)) < 0 ) {
          fprintf(stderr, "bind socket address failed.\n");
          exit(EXIT_FAILURE);
      }
  
  }
  
  void CEchoServer::run()
  {
  
      char buf[cMaxBufSize];
      struct sockaddr_in cliaddr;
      socklen_t clilen = sizeof(cliaddr);         // this is important for the first time received ip address none zero.
      while(true) {
          int bytes_recv = recvfrom(_svrsock, buf, cMaxBufSize, 0, 
                  (struct sockaddr *)&cliaddr, &clilen);
  
          if(bytes_recv > 0) {
              buf[bytes_recv] = '\0';
              handleClient(&cliaddr, buf, bytes_recv);
          }
      }
  
  }
  
  void CEchoServer::handleClient(const struct sockaddr_in *cliaddr, const char *msg, size_t bytes_recv)
  {
  
      fprintf(stdout, "%s:%u > %s\n", inet_ntoa(cliaddr->sin_addr), ntohs(cliaddr->sin_port), msg);
  
      int bytes_send = sendto(_svrsock, msg, bytes_recv, 0, 
              (const struct sockaddr *)cliaddr, sizeof(struct sockaddr_in)); 
      if(bytes_send <= 0) {
          fprintf(stderr, "reply to %s failed.\n", inet_ntoa(cliaddr->sin_addr));
      }
  
  }
  
  void print_usage() 
  {
  
      printf("Usage:\nechoserver <port>\n\n");
  
  }
  
  int main(int argc, char *argv[]) {
  
      uint16_t port = CEchoServer::cDefaultPort;
      if(argc > 1) {
          port = atoi(argv[1]);
      }
  
      CEchoServer echoserver(port);
      printf("echo server started at port %u.\n\n", port);
      echoserver.run();
      return 0;
  }
  
  /*
   * Echo client
   *
   * Accept user's input, send to server, then display the reply.
   *
   * date: Sat 11 Nov 2017 11:32:15 
   * */
  #include <arpa/inet.h>
  #include <netinet/ip.h>
  #include <unistd.h>
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include "echoapp.h"
  
  class CEchoClient
  {
      private:
          struct sockaddr_in _svraddr, _cliaddr; 
          int _clisock;
          const char *_svraddrstr;
          int _svrport, _cliport;
  
      public:
          CEchoClient() :
              _svraddrstr(cDefaultSvrAddr), _svrport(cDefaultSvrPort)
          {
              init();
          }
  
          CEchoClient(const char *svraddr, uint16_t svrport) :
              _svraddrstr(svraddr), _svrport(svrport)
          {
              init();
          }
  
          ~CEchoClient()
          {
              close(_clisock);
          }
  
          void init();
          void run();
  
          static uint16_t cDefaultSvrPort;
          static const char *const cDefaultSvrAddr;
  };
  
  uint16_t CEchoClient::cDefaultSvrPort = 1314;
  const char *const CEchoClient::cDefaultSvrAddr = "127.0.0.1";
  
  void CEchoClient::init()
  {
  
      //create client socket
      if ( (_clisock = socket(AF_INET, SOCK_DGRAM, 0)) == -1 ) {
          fprintf(stderr, "socket error.\n");
          exit(EXIT_FAILURE);
      }
  
      //set server address
      _svraddr.sin_family = AF_INET;
      if ( inet_aton(_svraddrstr, &_svraddr.sin_addr) == 0 ) {
          fprintf(stderr, "Invalid address: %s\n", _svraddrstr);
          exit(EXIT_FAILURE);
      }
      _svraddr.sin_port = htons(_svrport);
  
  }
  
  void CEchoClient::run() 
  {
  
      char buf[cMaxBufSize];
      socklen_t svraddrlen = sizeof(_svraddr);
      while (true) {
          printf("> ");
          fgets(buf, cMaxBufSize, stdin);
  
          int bytes_send = sendto(_clisock, buf, strlen(buf), 0,
                  (const struct sockaddr*)&_svraddr, sizeof(_svraddr));
          if(bytes_send > 0) {
              // send successfully, read reply
              int bytes_recv = recvfrom(_clisock, buf, cMaxBufSize, 0,
                      (struct sockaddr*)&_svraddr, &svraddrlen);
              if(bytes_recv > 0) {
                  buf[bytes_recv] = '\0';
                  printf("< %s\n", buf);
              }
              else {
                  fprintf(stderr, "< receive failed.\n");
              }
          }
      }
  
  }
  
  void print_usage() 
  {
  
      printf("Usage:\nechoclient <server_ip> <server_port>\n\n");
  
  }
  
  int main(int argc, char *argv[]) { 
  
      const char *svraddr       = CEchoClient::cDefaultSvrAddr;
      uint16_t svrport    = CEchoClient::cDefaultSvrPort;
  
      if(argc > 2) {
          svraddr = argv[1];
          svrport = atoi(argv[2]);
      }
      else if(argc > 1) {
          svraddr = argv[1];
      }
      else {
          fprintf(stdout, "Use default address and port.\n");
      }
  
      printf("Server %s:%u\n", svraddr, svrport);
      printf("Enter message to echo.\n\n");
  
      CEchoClient echoclient(svraddr, svrport);
      echoclient.run();
  
      return 0;
  }
  
  
  
  #ifndef ECHO_APP_H_
  #define ECHO_APP_H_
  
  // 
  const int cMaxBufSize   = 1024;
  
  
  #endif 
  
  #include <pcap.h>
  #include <cstring>
  #include <cstdlib>
  #include <cctype>
  
  #define MAXBYTES2CAPTURE 2048
  
  void processPacket(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet) {
      int i = 0, *counter = (int *)arg;
  
      printf("Packet Count: %d\n", ++(*counter));
      printf("Received Packet Size: %d\n", pkthdr->len);
      printf("Payload:\n");
  
      for(i = 0; i < pkthdr->len ; ++i) {
          if(isprint(packet[i])) 
              printf("%c ", packet[i]);
          else 
              printf(". ");
  
          if( (i % 16 == 0 && i != 0) || i == pkthdr->len-1 )
              printf("\n");
      }
  }
  
  int main(int argc, char * argv[]) {
      int i = 0, count = 0, dlt = 0;
      pcap_t *descr = NULL;
      char errbuf[PCAP_ERRBUF_SIZE], *device = NULL;
      memset(errbuf, 0, PCAP_ERRBUF_SIZE);
  
      //Get the name of the first device suitable for capture
      device = pcap_lookupdev(errbuf);
  
      printf("Opening device: %s\n", device);
  
      //Open device in promiscuous mode
      descr = pcap_open_live(device, MAXBYTES2CAPTURE, 1, 512, errbuf);
  
      // Check datalink type
      dlt = pcap_datalink(descr);
      printf("DLT: %s\n", (dlt == DLT_EN10MB ? "DLT_EN10MB" : "Unknown"));
  
      //Loop forever & call processPacket() for every received packet
      pcap_loop(descr, -1, processPacket, (u_char *)&count);
  
      return 0;
  }
  /*
   * sniffex.c
   *
   * Sniffer example of TCP/IP packet capture using libpcap.
   * 
   * Version 0.1.1 (2005-07-05)
   * Copyright (c) 2005 The Tcpdump Group
   *
   * This software is intended to be used as a practical example and 
   * demonstration of the libpcap library; available at:
   * http://www.tcpdump.org/
   *
   ****************************************************************************
   *
   * This software is a modification of Tim Carstens' "sniffer.c"
   * demonstration source code, released as follows:
   * 
   * sniffer.c
   * Copyright (c) 2002 Tim Carstens
   * 2002-01-07
   * Demonstration of using libpcap
   * timcarst -at- yahoo -dot- com
   * 
   * "sniffer.c" is distributed under these terms:
   * 
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 4. The name "Tim Carstens" may not be used to endorse or promote
   *    products derived from this software without prior written permission
   *
   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   * <end of "sniffer.c" terms>
   *
   * This software, "sniffex.c", is a derivative work of "sniffer.c" and is
   * covered by the following terms:
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Because this is a derivative work, you must comply with the "sniffer.c"
   *    terms reproduced above.
   * 2. Redistributions of source code must retain the Tcpdump Group copyright
   *    notice at the top of this source file, this list of conditions and the
   *    following disclaimer.
   * 3. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 4. The names "tcpdump" or "libpcap" may not be used to endorse or promote
   *    products derived from this software without prior written permission.
   *
   * THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.
   * BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
   * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
   * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
   * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
   * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
   * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
   * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
   * REPAIR OR CORRECTION.
   * 
   * IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
   * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
   * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
   * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
   * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
   * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
   * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
   * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGES.
   * <end of "sniffex.c" terms>
   * 
   ****************************************************************************
   *
   * Below is an excerpt from an email from Guy Harris on the tcpdump-workers
   * mail list when someone asked, "How do I get the length of the TCP
   * payload?" Guy Harris' slightly snipped response (edited by him to
   * speak of the IPv4 header length and TCP data offset without referring
   * to bitfield structure members) is reproduced below:
   * 
   * The Ethernet size is always 14 bytes.
   * 
   * <snip>...</snip>
   *
   * In fact, you *MUST* assume the Ethernet header is 14 bytes, *and*, if 
   * you're using structures, you must use structures where the members 
   * always have the same size on all platforms, because the sizes of the 
   * fields in Ethernet - and IP, and TCP, and... - headers are defined by 
   * the protocol specification, not by the way a particular platform's C 
   * compiler works.)
   *
   * The IP header size, in bytes, is the value of the IP header length,
   * as extracted from the "ip_vhl" field of "struct sniff_ip" with
   * the "IP_HL()" macro, times 4 ("times 4" because it's in units of
   * 4-byte words).  If that value is less than 20 - i.e., if the value
   * extracted with "IP_HL()" is less than 5 - you have a malformed
   * IP datagram.
   *
   * The TCP header size, in bytes, is the value of the TCP data offset,
   * as extracted from the "th_offx2" field of "struct sniff_tcp" with
   * the "TH_OFF()" macro, times 4 (for the same reason - 4-byte words).
   * If that value is less than 20 - i.e., if the value extracted with
   * "TH_OFF()" is less than 5 - you have a malformed TCP segment.
   *
   * So, to find the IP header in an Ethernet packet, look 14 bytes after 
   * the beginning of the packet data.  To find the TCP header, look 
   * "IP_HL(ip)*4" bytes after the beginning of the IP header.  To find the
   * TCP payload, look "TH_OFF(tcp)*4" bytes after the beginning of the TCP
   * header.
   * 
   * To find out how much payload there is:
   *
   * Take the IP *total* length field - "ip_len" in "struct sniff_ip" 
   * - and, first, check whether it's less than "IP_HL(ip)*4" (after
   * you've checked whether "IP_HL(ip)" is >= 5).  If it is, you have
   * a malformed IP datagram.
   *
   * Otherwise, subtract "IP_HL(ip)*4" from it; that gives you the length
   * of the TCP segment, including the TCP header.  If that's less than
   * "TH_OFF(tcp)*4" (after you've checked whether "TH_OFF(tcp)" is >= 5),
   * you have a malformed TCP segment.
   *
   * Otherwise, subtract "TH_OFF(tcp)*4" from it; that gives you the
   * length of the TCP payload.
   *
   * Note that you also need to make sure that you don't go past the end 
   * of the captured data in the packet - you might, for example, have a 
   * 15-byte Ethernet packet that claims to contain an IP datagram, but if 
   * it's 15 bytes, it has only one byte of Ethernet payload, which is too 
   * small for an IP header.  The length of the captured data is given in 
   * the "caplen" field in the "struct pcap_pkthdr"; it might be less than 
   * the length of the packet, if you're capturing with a snapshot length 
   * other than a value >= the maximum packet size.
   * <end of response>
   * 
   ****************************************************************************
   * 
   * Example compiler command-line for GCC:
   *   gcc -Wall -o sniffex sniffex.c -lpcap
   * 
   ****************************************************************************
   *
   * Code Comments
   *
   * This section contains additional information and explanations regarding
   * comments in the source code. It serves as documentaion and rationale
   * for why the code is written as it is without hindering readability, as it
   * might if it were placed along with the actual code inline. References in
   * the code appear as footnote notation (e.g. [1]).
   *
   * 1. Ethernet headers are always exactly 14 bytes, so we define this
   * explicitly with "#define". Since some compilers might pad structures to a
   * multiple of 4 bytes - some versions of GCC for ARM may do this -
   * "sizeof (struct sniff_ethernet)" isn't used.
   * 
   * 2. Check the link-layer type of the device that's being opened to make
   * sure it's Ethernet, since that's all we handle in this example. Other
   * link-layer types may have different length headers (see [1]).
   *
   * 3. This is the filter expression that tells libpcap which packets we're
   * interested in (i.e. which packets to capture). Since this source example
   * focuses on IP and TCP, we use the expression "ip", so we know we'll only
   * encounter IP packets. The capture filter syntax, along with some
   * examples, is documented in the tcpdump man page under "expression."
   * Below are a few simple examples:
   *
   * Expression			Description
   * ----------			-----------
   * ip					Capture all IP packets.
   * tcp					Capture only TCP packets.
   * tcp port 80			Capture only TCP packets with a port equal to 80.
   * ip host 10.1.2.3		Capture all IP packets to or from host 10.1.2.3.
   *
   ****************************************************************************
   *
   */
  
  #define APP_NAME		"sniffex"
  #define APP_DESC		"Sniffer example using libpcap"
  #define APP_COPYRIGHT	"Copyright (c) 2005 The Tcpdump Group"
  #define APP_DISCLAIMER	"THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM."
  
  #include <pcap.h>
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <ctype.h>
  #include <errno.h>
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <netinet/ether.h>
  #include <netinet/ip_icmp.h>
  #include <arpa/inet.h>
  
  #include "ether.h"
  #include "ip_arp.h"
  #include "ip.h"
  #include "tcp.h"
  #include "udp.h"
  #include "icmp.h"
  #include "netsimul.h"
  
  const tok_t ethertype_values[] = {
      {ETHERTYPE_IP,          "IPv4"},
      {ETHERTYPE_ARP,         "ARP"},
      {ETHERTYPE_REVARP,      "RARP"},
      {ETHERTYPE_IPV6,        "IPv6"},
      {ETHERTYPE_LOOPBACK,    "Loopback"},
      {0, NULL}
  };
  
  const tok_t icmptype_values[] = {
      {ICMP_ECHOREPLY          , "Echo Reply"},      
      {ICMP_DEST_UNREACH       , "Destination Unreachable"},      
      {ICMP_SOURCE_QUENCH      , "Source Quench"},      
      {ICMP_REDIRECT           , "Redirect (change route)"},      
      {ICMP_ECHO               , "Echo Request"},      
      {ICMP_TIME_EXCEEDED      , "Time Exceeded"},      
      {ICMP_PARAMETERPROB      , "Parameter Problem"},      
      {ICMP_TIMESTAMP          , "Timestamp Request"},      
      {ICMP_TIMESTAMPREPLY     , "Timestamp Reply"},      
      {ICMP_INFO_REQUEST       , "Information Request"},      
      {ICMP_INFO_REPLY         , "Information Reply"},      
      {ICMP_ADDRESS            , "Address Mask Request"},      
      {ICMP_ADDRESSREPLY       , "Address Mask Reply"},      
      {0, NULL}
  };
  
  const tok_t icmpcode_values[] = {
      {0, NULL}
  };
  
  void
  got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);
  
  void
  print_payload(const u_char *payload, int len);
  
  void
  print_hex_ascii_line(const u_char *payload, int len, int offset);
  
  void
  print_app_banner(void);
  
  void
  print_app_usage(void);
  
  void print_ether(const struct sniff_ethernet * ethernet);
  
  void print_arp(const struct sniff_arp * arp);
  
  const char * tok2str(const tok_t * tokp,
          const char * default_msg,
          int v)
  {
  
      static char buf[SIZE_TOK_BUF];
  
      if(tokp != NULL) {
          while(tokp->s != NULL) {
              if(tokp->v == v)
                  return tokp->s;
              else 
                  ++tokp;
          }
      }
  
      snprintf(buf, SIZE_TOK_BUF, "%s", default_msg);
      return (const char *)buf;
  }
  
  /*
   * app name/banner
   */
  void
  print_app_banner(void)
  {
  
  	printf("%s - %s\n", APP_NAME, APP_DESC);
  	printf("%s\n", APP_COPYRIGHT);
  	printf("%s\n", APP_DISCLAIMER);
  	printf("\n");
  
  return;
  }
  
  /*
   * print help text
   */
  void
  print_app_usage(void)
  {
  
  	printf("Usage: %s [interface]\n", APP_NAME);
  	printf("\n");
  	printf("Options:\n");
  	printf("    interface    Listen on <interface> for packets.\n");
  	printf("\n");
  
  return;
  }
  
  /*
   * print data in rows of 16 bytes: offset   hex   ascii
   *
   * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
   */
  void
  print_hex_ascii_line(const u_char *payload, int len, int offset)
  {
  
  	int i;
  	int gap;
  	const u_char *ch;
  
  	/* offset */
  	printf("%05d   ", offset);
  	
  	/* hex */
  	ch = payload;
  	for(i = 0; i < len; i++) {
  		printf("%02x ", *ch);
  		ch++;
  		/* print extra space after 8th byte for visual aid */
  		if (i == 7)
  			printf(" ");
  	}
  	/* print space to handle line less than 8 bytes */
  	if (len < 8)
  		printf(" ");
  	
  	/* fill hex gap with spaces if not full line */
  	if (len < 16) {
  		gap = 16 - len;
  		for (i = 0; i < gap; i++) {
  			printf("   ");
  		}
  	}
  	printf("   ");
  	
  	/* ascii (if printable) */
  	ch = payload;
  	for(i = 0; i < len; i++) {
  		if (isprint(*ch))
  			printf("%c", *ch);
  		else
  			printf(".");
  		ch++;
  	}
  
  	printf("\n");
  
  return;
  }
  
  /*
   * print packet payload data (avoid printing binary data)
   */
  void
  print_payload(const u_char *payload, int len)
  {
  
  	int len_rem = len;
  	int line_width = 16;			/* number of bytes per line */
  	int line_len;
  	int offset = 0;					/* zero-based offset counter */
  	const u_char *ch = payload;
  
  	if (len <= 0)
  		return;
  
  	/* data fits on one line */
  	if (len <= line_width) {
  		print_hex_ascii_line(ch, len, offset);
  		return;
  	}
  
  	/* data spans multiple lines */
  	for ( ;; ) {
  		/* compute current line length */
  		line_len = line_width % len_rem;
  		/* print line */
  		print_hex_ascii_line(ch, line_len, offset);
  		/* compute total remaining */
  		len_rem = len_rem - line_len;
  		/* shift pointer to remaining bytes to print */
  		ch = ch + line_len;
  		/* add offset */
  		offset = offset + line_width;
  		/* check if we have line width chars or less */
  		if (len_rem <= line_width) {
  			/* print last line and get out */
  			print_hex_ascii_line(ch, len_rem, offset);
  			break;
  		}
  	}
  
  return;
  }
  
  /*
   * Print ethernet structure informations
   *
   * Append by BDG, Wed 08 Nov 2017 10:56:22 
   * */
  void print_ether(const struct sniff_ethernet * ethernet)
  {
  
      u_short ether_type = 0;                 // Ethertype value
  
      const char * etherstr = NULL;           // Ethertype string
  
      // Ether dst & src
      char dst[MAC_ASCII_LEN], src[MAC_ASCII_LEN], *tmp = NULL;          
      
      ether_type = ntohs(ethernet->ether_type);
      printf("Network Layer Protocol: %s (%4X)", tok2str(ethertype_values, "Unknown", ether_type),ether_type );
  
      /*etherstr = get_ethertype_by_value(ether_type);*/
      /*if(etherstr != NULL) {*/
          /*printf("%s", etherstr);*/
      /*}*/
      /*else {*/
          /*printf("Unknown(%0004X)", ether_type);*/
      /*}*/
      /*
       * The ether_ntoa() function converts the Ethernet host address addr given in network byte order to a string
       * in standard hex-digits-and-colons notation, omitting leading zeros. The string is returned in a statically
       * allocated buffer, which subsequent calls will overwrite.
       * */
      tmp = ether_ntoa((const struct ether_addr*)&ethernet->ether_dhost);
      strncpy(dst, tmp, MAC_ASCII_LEN);
      tmp = ether_ntoa((const struct ether_addr*)&ethernet->ether_shost);
      strncpy(src, tmp, MAC_ASCII_LEN);
      printf("\n     Source: %s\nDestination: %s\n", src, dst);
  
  }
  
  /*
   * Print ARP header
   * */
  void print_arp(const struct sniff_arp * arp)
  {
  
      int i;
  
      printf("Hardware type: %s\n", ((ntohs(arp->htype) == 1) ? "Ethernet" : "Unknown"));
      printf("Protocol type: %s\n", ((ntohs(arp->ptype) == 0x0800) ? "IPv4" : "Unknown"));
      printf("Operation: %s\n", ((ntohs(arp->oper) == ARPOP_REQUEST) ? "ARP Request" : "ARP Reply"));
  
      //If is Ethernet and IPv4, print packet contents
      if( ntohs(arp->htype) == 1 && ntohs(arp->ptype) == 0x0800) {
          printf("Sender MAC: ");
          for(i=0; i<6 ; ++i)
              printf("%02X:", arp->sha[i]);
          printf("\nSender IP: ");
          struct in_addr spa; 
          spa.s_addr = arp->spa;
          printf("%s", inet_ntoa(spa));
          /*for(i=0; i<4 ; ++i)*/
              /*printf("%d.", arp->spa[i]);*/
          printf("\nTarget MAC: ");
          for(i=0; i<6 ; ++i)
              printf("%02X:", arp->tha[i]);
          printf("\nTarget IP: ");
          struct in_addr tpa;
          tpa.s_addr = arp->tpa;
          printf("%s", inet_ntoa(tpa));
          /*for(i=0; i<4 ; ++i)*/
              /*printf("%d.", arp->tpa[i]);*/
          printf("\n");
      }
  
  }
  
  void print_tcp(const struct sniff_tcp * tcp, 
          const struct sniff_ip * ip,
          const u_char * packet)
  {
  
      const char *payload;                    /* Packet payload */
  
      int size_ip = IP_HL(ip)*4;
      int size_tcp = TH_OFF(tcp)*4;
      int size_payload;
  
      printf("   Src port: %d\n", ntohs(tcp->th_sport));
      printf("   Dst port: %d\n", ntohs(tcp->th_dport));
      
      /* define/compute tcp payload (segment) offset */
      //payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
      payload = (const char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
      
      /* compute tcp payload (segment) size */
      size_payload = ntohs(ip->ip_len) - (size_ip + size_tcp);
      
      /*
       * Print payload data; it might be binary, so don't just
       * treat it as a string.
       */
      printf("   Payload (%d bytes):\n", size_payload);
      if (size_payload > 0) {
              /*printf("   Payload (%d bytes):\n", size_payload);*/
              //print_payload(payload, size_payload);
      	print_payload((const unsigned char*)payload, size_payload);
      }
  
  }
  
  void print_udp(const struct sniff_udp * udp,
          const struct sniff_ip * ip,
          const u_char * packet)
  {
  
      const char * payload;
  
      int size_ip = IP_HL(ip)*4;
      int size_udp = 8;
      int size_payload;
  
      printf("    Src port: %d\n", ntohs(udp->uh_sport));
      printf("    Dst port: %d\n", ntohs(udp->uh_dport));
  
      //payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_udp);
      payload = (const char *)(packet + SIZE_ETHERNET + size_ip + size_udp);
  
      size_payload = ntohs(udp->uh_len) - size_udp;
  
      printf("    Payload (%d bytes):\n", size_payload);
      if(size_payload > 0) {
          //print_payload(payload, size_payload);
          print_payload((const u_char*)payload, size_payload);
      }
  
  }
  
  void print_icmp(const struct sniff_icmp * icmp,
          const struct sniff_ip * ip,
          const u_char * packet)
  {
  
      uint8_t type;
      uint8_t code;
  
      type = icmp->icmp_type;
      printf("Message Type: %s (%d)\n", tok2str(icmptype_values, "Unknown", type), type); 
  
      code = icmp->icmp_code;
      printf("Message Code: %s (%d)\n", tok2str(icmpcode_values, "Unknown", code), code); 
  
  }
  
  /*
   * Handle ARP header
   * */
  void handle_arp(const struct sniff_arp * arp)
  {
  
      print_arp(arp);
  
  }
  
  /*
   * Handle IP datagram
   * */
  void handle_ip(const struct sniff_ip * ip,
          const struct pcap_pkthdr * header,
          const u_char * packet)
  {
  
      const struct sniff_tcp *tcp;            /* The TCP header */
      const struct sniff_udp *udp;            /* The UDP header */
      const struct sniff_icmp *icmp;          /* The ICMP header */
      const char *payload;                    /* Packet payload */
  
      int size_ip = IP_HL(ip)*4;
      int size_tcp;
      int size_udp;
      int size_payload;
  
      /* print source and destination IP addresses */
      printf("       From: %s\n", inet_ntoa(ip->ip_src));
      printf("         To: %s\n", inet_ntoa(ip->ip_dst));
      
      /* determine protocol */	
      switch(ip->ip_p) {
      	case IPPROTO_TCP:
      		printf("   Protocol: TCP\n");
                  /* define/compute tcp header offset */
                  tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
                  size_tcp = TH_OFF(tcp)*4;
                  if (size_tcp < 20) {
                      printf("   * Invalid TCP header length: %u bytes\n", size_tcp);
                  }
                  else {
                      print_tcp(tcp, ip, packet);
                  }
      		break;
      	case IPPROTO_UDP:
      		printf("   Protocol: UDP\n");
                  udp = (const udphdr_t*)(packet + SIZE_ETHERNET + size_ip);
                  print_udp(udp, ip, packet);
      		return;
      	case IPPROTO_ICMP:
      		printf("   Protocol: ICMP\n");
                  icmp = (const icmphdr_t *)(packet + SIZE_ETHERNET + size_ip);
                  print_icmp(icmp, ip, packet);
      		break;
      	case IPPROTO_IP:
      		printf("   Protocol: IP\n");
      		return;
      	default:
      		printf("   Protocol: unknown\n");
      		return;
      }
      
  }
  
  /* 
   * Handle ethernet packet
   * */
  void handle_ether(const struct sniff_ethernet * ethernet,
          const struct pcap_pkthdr * header,
          const u_char * packet)
  {
  
      const struct sniff_arp *arp;            /* The ARP header */
      const struct sniff_ip *ip;              /* The IP header */
  
      int size_ip;
  
      u_short ether_type;
  	
      /* Print ethernet informations */
      print_ether(ethernet);
  
      /* Handle packet according to ether_type */
      ether_type = ntohs(ethernet->ether_type);
      switch(ether_type) {
          case ETHERTYPE_ARP: {
                                  arp = (const struct sniff_arp*)(packet + SIZE_ETHERNET);
                                  handle_arp(arp);
                                  break;
                              }
          case ETHERTYPE_REVARP: { break; }
          case ETHERTYPE_IP: {
                                  /* define/compute ip header offset */
                                  ip = (const struct sniff_ip*)(packet + SIZE_ETHERNET);
                                  size_ip = IP_HL(ip)*4;
                                  if (size_ip < 20) {
                                      printf("   * Invalid IP header length: %u bytes\n", size_ip);
                                  }
                                  else {
                                      handle_ip(ip, header, packet);
                                  }
                                  break;
                             }
          case ETHERTYPE_IPV6: { break; }
          case ETHERTYPE_LOOPBACK: { break; }
          default:
                                   break;
      }
  	
      /*ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);*/
      /*size_ip = IP_HL(ip)*4;*/
      /*if (size_ip < 20) {*/
              /*printf("   * Invalid IP header length: %u bytes\n", size_ip);*/
              /*return;*/
      /*}*/
  
  }
  
  /*
   * dissect/print packet
   */
  void
  got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
  {
  
  	static int count = 1;                   /* packet counter */
  
  	/* declare pointers to packet headers */
  	const struct sniff_ethernet *ethernet;  /* The ethernet header [1] */
  
  	printf("\nPacket number %d:\n", count);
  	printf("Packet len: %d\n", header->len);
  	count++;
  	
  	/* define ethernet header */
  	ethernet = (struct sniff_ethernet*)(packet);
  
          handle_ether(ethernet, header, packet);
  
  return;
  }
  
  int main(int argc, char **argv)
  {
  
  	char *dev = NULL;			/* capture device name */
  	char errbuf[PCAP_ERRBUF_SIZE];		/* error buffer */
  	pcap_t *handle;				/* packet capture handle */
  
          char filter_exp[] = "arp";		/* filter expression [3] */
  	/*char filter_exp[] = "";		[> filter expression [3] <]*/
  	struct bpf_program fp;			/* compiled filter program (expression) */
  	bpf_u_int32 mask;			/* subnet mask */
  	bpf_u_int32 net;			/* ip */
  	int num_packets = 10;			/* number of packets to capture */
  
  	print_app_banner();
  
  	/* check for capture device name on command-line */
  	if (argc == 2) {
  		dev = argv[1];
  	}
  	else if (argc > 2) {
  		fprintf(stderr, "error: unrecognized command-line options\n\n");
  		print_app_usage();
  		exit(EXIT_FAILURE);
  	}
  	else {
  		/* find a capture device if not specified on command-line */
  		dev = pcap_lookupdev(errbuf);
  		if (dev == NULL) {
  			fprintf(stderr, "Couldn't find default device: %s\n",
  			    errbuf);
  			exit(EXIT_FAILURE);
  		}
  	}
  	
  	/* get network number and mask associated with capture device */
  	if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
  		fprintf(stderr, "Couldn't get netmask for device %s: %s\n",
  		    dev, errbuf);
  		net = 0;
  		mask = 0;
  	}
  
  	/* print capture info */
  	printf("Device: %s\n", dev);
  	printf("Number of packets: %d\n", num_packets);
  	printf("Filter expression: %s\n", filter_exp);
  
  	/* open capture device */
  	handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
  	if (handle == NULL) {
  		fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
  		exit(EXIT_FAILURE);
  	}
  
  	/* make sure we're capturing on an Ethernet device [2] */
  	if (pcap_datalink(handle) != DLT_EN10MB) {
  		fprintf(stderr, "%s is not an Ethernet\n", dev);
  		exit(EXIT_FAILURE);
  	}
  
  	/* compile the filter expression */
  	if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
  		fprintf(stderr, "Couldn't parse filter %s: %s\n",
  		    filter_exp, pcap_geterr(handle));
  		exit(EXIT_FAILURE);
  	}
  
  	/* apply the compiled filter */
  	if (pcap_setfilter(handle, &fp) == -1) {
  		fprintf(stderr, "Couldn't install filter %s: %s\n",
  		    filter_exp, pcap_geterr(handle));
  		exit(EXIT_FAILURE);
  	}
  
  	/* now we can set our callback function */
  	pcap_loop(handle, num_packets, got_packet, NULL);
  
  	/* cleanup */
  	pcap_freecode(&fp);
  	pcap_close(handle);
  
  	printf("\nCapture complete.\n");
  
  return 0;
  }
  
  /*
   * DemoTimeServer - UDP Demo
   *
   * Receive client message and reply current system time.
   * */
  
  #include "Socket.h"
  #include <string>
  #include <cstring>
  #include <time.h>
  
  const int cPort = 1618;
  const int cBufSize = 4096;
  
  int main(int argc, char* argv[])
  {
      if (argc < 2) {
          printf("Usage: %s <ip> <port>.\n", argv[0]);
          return (0);
      }
  
      int sockfd;
      struct sockaddr_in svrAddr;
      CSocket socket;
  
      if ((sockfd = socket.socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
          printf("Failed socket().\n");
          return 0;
      }
  
      svrAddr.sin_family = AF_INET;
      inet_aton(argv[1], &svrAddr.sin_addr);
  
      if (argc > 2) {
          svrAddr.sin_port = htons(std::stoi(argv[2]));
      }
      else {
          svrAddr.sin_port = htons(cPort);
      }
  
      if (socket.bind((struct sockaddr*)&svrAddr, sizeof(struct sockaddr)) == -1) {
          fprintf(stderr, "Failed bind().\n");
          return 0;
      }
      else {
          printf("%s run with %s:%d.\n\n", argv[0], argv[1], ntohs(svrAddr.sin_port));
      }
  
      struct sockaddr_in client;
      unsigned int addrlen = sizeof(client);
  
      char buf[cBufSize];
      while (true) {
          int bytesRecv = socket.recvfrom(buf, cBufSize, 0, (struct sockaddr*)&client, &addrlen);
          if (bytesRecv > 0) {
              // print received message
              buf[bytesRecv] = '\0';
              printf("Server received: %s.\n", buf);
  
              // reply client
              time_t now = time(NULL);
              snprintf(buf, cBufSize, "%.24s\r\n", ctime(&now));
              socket.sendto(buf, strlen(buf), 0, (struct sockaddr*)&client, sizeof(struct sockaddr));
              printf("Replied current time.\n");
          }
          else {
              printf("Server receive error, bytesRecv = %d.\n", bytesRecv);
          }
      }
  
      return 0;
  
  }
  
  #include "Socket.h"
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include <unistd.h>
  #include <errno.h>
  #include <signal.h>
  #include <sys/ipc.h> 
  #include <sys/stat.h> 
  #include <sys/shm.h> 
  
  #include "Util.h"
  
  #define TAG "<CSocket> "
  
  int sig;            // received signal
  
  void handler1(int signo)
  {
      printf("Received signal SIGUSR1(%d).\n", signo);
      sig = signo;
  }
  
  void handler2(int signo)
  {
      sig = signo;
      printf("Received signal SIGUSR2(%d).\n", signo);
  }
  
  int CSocket::waitForSuccess(int signo)
  {
      pause();
  
      int success;
      if (sig == signo) {
          success = *((int *)_pBlock->buf1);
      }
      else {
          success = -1;
      }
  
      return success;
  }
  
  
  CSocket::CSocket()
  {
      log(TAG "New socket created.\n");
      attachSharedMem();
  }
  
  CSocket::~CSocket()
  {
      close();
  
      detachSharedMem();
      log(TAG "A socket destroied.\n");
  }
  
  void CSocket::attachSharedMem()
  {
      key_t key;          // shared memory key
      struct shmid_ds buf;
  
      signal(SIGUSR1, handler1);          // SIGUSR1 for commands
      signal(SIGUSR2, handler2);          // SIGUSR2 for datas
  
      // prepare a key 
      if ((key = ftok(cKeyPath, cKeyID)) == -1) {
          printf("Failed ftok().\n");
      }
  
      // try attach Protocol process created shared memory
      if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | IPC_EXCL)) == -1) {
          if (errno == EEXIST) {
              if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | S_IRUSR | S_IWUSR)) == -1) {
                  printf("Failed shmget(): %s.\n", strerror(errno));
                  exit(EXIT_FAILURE);
              }
              else {
                  printf("Success attach shared memory %d.\n", _shmid);
              }
          }
          else {
              // no shared memory exist, maybe Protocol not started, exit...
              fprintf(stderr, "Unable to attach shared memory.\n");
              exit(0);
          }
      }
      else {
          if (shmctl(_shmid, IPC_RMID, 0) == -1) {
              printf("Failed shmctl(): %s.\n", strerror(errno));
          }
          printf("Protocol not started, quit...\n");
          exit(0);
      }
  
      // get shared memory address
      if ((_pBlock = (SharedBlock *)shmat(_shmid, 0, 0)) == (void *)-1) {
          printf("Failed shmat(): %s.\n", strerror(errno));
      }
      printf("pBlock: %p, pBlock->buf1: %p, pBlock->buf2: %p\n", _pBlock, _pBlock->buf1, _pBlock->buf2);
  
      // get created process id
      if (shmctl(_shmid, IPC_STAT, &buf) == -1) {
          printf("Failed shmctl().\n");
      }
      else {
          printf("Protocol process: %d.\n", buf.shm_cpid);
          _protoPid = buf.shm_cpid;
      }
  
      // do work here
      //printf("Shared: %s\n", _pBlock->buf1);
      //kill(buf.shm_cpid, SIGUSR1);
  }
  
  void CSocket::detachSharedMem()
  {
      if (shmdt(_pBlock) == -1) {
          printf("Failed shmdt(): %s.\n", strerror(errno));
      }
  }
  
  int CSocket::init(int family, int type, int protocol)
  {
      _sock.pid       = getpid();
      _sock.sockfd    = _sock.pid;
      _sock.family    = family;
      _sock.type      = type;
      _sock.protocol  = protocol;
  
      _sock.addr.s_addr   = 0;
      _sock.port          = 0;
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_CREATE;
      memcpy(sockPkt.data, &_sock, sizeof(Sock));
  
      // Copy to shared memory and notify this
      memcpy(_pBlock->buf2, &sockPkt, sizeof(Sock) + sizeof(SockPktType));
      kill(_protoPid, SIGUSR1);
      log(TAG "%s : kill signal SIGUSR1 to process %d.\n", __func__, _protoPid);
  
      int result = waitForSuccess(SIGUSR1);
      printf("Created socket: %d\n", result);
  
      return result;
  
  }
  
  int CSocket::socket(int family, int type, int protocol)
  {
      return init(family, type, protocol);
  
  }
  
  int CSocket::bind(const struct sockaddr* addr, socklen_t len)
  {
      struct sockaddr_in bindAddr = *((struct sockaddr_in *)addr);
  
      _sock.addr = bindAddr.sin_addr;
      _sock.port = bindAddr.sin_port;
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_BIND;
  
      memcpy(sockPkt.data, &_sock, sizeof(_sock));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock));
  
      kill(_protoPid, SIGUSR1);
  
      pause();
  
      if (sig == SIGUSR1) {
          int success = *((int *)_pBlock->buf1);
          if (success == 1) {
              return 0;
          }
          else {
              _sock.addr.s_addr = 0;
              _sock.port = 0;
              return -1;
          }
      }
      else {
          _sock.addr.s_addr = 0;
          _sock.port = 0;
          fprintf(stderr, "Not SIGUSR1 received\n");
          return -1;
      }
  }
  
  int CSocket::sendto(const char* buf, size_t len, int flags,
          const struct sockaddr* dstAddr, socklen_t addrlen) 
  {
      // todo: Send to ProtoSocket send message
      //   data format: ProtoSocket{type, {SockData, buf}}
      //              or: ProtoSocket{type, {left buf}}
      SockDataHdr sockDataHdr;
      sockDataHdr.sockfd  = _sock.sockfd;
      sockDataHdr.dstAddr = *((struct sockaddr_in *)dstAddr);
      sockDataHdr.flag    = flags;
      sockDataHdr.len     = len;
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_SENDTO;
  
      char *pData = sockPkt.data;
  
      memcpy(pData, &sockDataHdr, sizeof(SockDataHdr));
      pData += sizeof(SockDataHdr);
  
      int bufLeft = cSHMDataSize - sizeof(SockDataHdr);
      int dataLeft = len;
      
      while (dataLeft > 0) {
          int dataLen;
  
          if (bufLeft <= 0) {         // re-point to buffer start
              bufLeft = cSHMDataSize;
              pData = sockPkt.data;
          }
  
          if (dataLeft <= bufLeft) {
              dataLen = dataLeft;
          }
          else {
              dataLen = bufLeft;
          }
  
          memcpy(pData, buf, dataLen);
  
          pData       += dataLen;
          dataLeft    -= dataLen;
          bufLeft     -= dataLen;
  
          int bytes = pData - sockPkt.data + sizeof(SockPktType);
          printf("will copy %d bytes.\n", bytes);
          memcpy(_pBlock->buf2, &sockPkt, bytes);
          kill(_protoPid, SIGUSR2);
      }
  
      int byteSend = waitForSuccess(SIGUSR2);
      printf("Send %d bytes.\n", byteSend);
  
      return byteSend;
  }
  
  int CSocket::recvfrom(char* buf, size_t len, int flags,
          struct sockaddr* srcAddr, socklen_t* addrlen)
  {
      SockDataHdr dataHdr;
      dataHdr.sockfd  = _sock.sockfd;
      dataHdr.flag    = flags;
      dataHdr.len     = len;
  
      SockPacket sockPkt;
      sockPkt.type    = SOCK_RECVFROM;
  
      memcpy(sockPkt.data, &dataHdr, sizeof(dataHdr));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(dataHdr));
      kill(_protoPid, SIGUSR1);
  
      pause();
  
      // read data from ProtoSocket and set value-result parameters
      char *pData = _pBlock->buf1;
      SockDataHdr* rcvDataHdr = (SockDataHdr *)pData;
  
      struct sockaddr_in* fromAddr = &rcvDataHdr->srcAddr;
      *srcAddr = *((struct sockaddr*)&rcvDataHdr->srcAddr);
      *addrlen = sizeof(struct sockaddr);
      printf("Received data from %s:%d.\n", inet_ntoa(fromAddr->sin_addr), ntohs(fromAddr->sin_port));
  
      pData += sizeof(SockDataHdr);
  
      int dataLen = len;
      if (dataLen > rcvDataHdr->len) {
          dataLen = rcvDataHdr->len;
      }
      memcpy(buf, pData, dataLen);
  
      return dataLen;
  }
  
  int CSocket::close() 
  {
      // there is no need to close an unconnected socket
      if (_sock.type == SOCK_STREAM && _sock.state == SS_UNCONNECTED) {
          log(TAG "%s(): stream socket not connected, there is no need to close\n", __func__);
          return 0;
      }
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_CLOSE;
  
      memcpy(sockPkt.data, &_sock, sizeof(Sock));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock));
      kill(_protoPid, SIGUSR1);
  
      return waitForSuccess(SIGUSR1) - 1;
  }
  
  int CSocket::connect(const struct sockaddr* addr, socklen_t len)
  {
      SockPacket sockPkt;
      sockPkt.type = SOCK_CONNECT;
  
      struct sockaddr_in * dstAddr = (struct sockaddr_in *)addr;
      _sock.peerAddr = dstAddr->sin_addr;
      _sock.peerPort = dstAddr->sin_port;
  
      memcpy(sockPkt.data, &_sock, sizeof(_sock));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(_sock));
      kill(_protoPid, SIGUSR1);
  
      pause();
  
      Sock *sock = (Sock *)_pBlock->buf1;
      if (sock->port > 0) {
          _sock.addr = sock->addr;
          _sock.port = sock->port;
          _sock.state = sock->state;
          return 0;
      }
      else {
          return -1;
      }
  
  }
  
  SockDataHdr CSocket::makeDataHeader(size_t len, int flag)
  {
      SockDataHdr sockDataHdr;
      sockDataHdr.sockfd  = _sock.sockfd;
      sockDataHdr.flag    = flag;
      sockDataHdr.len     = len;
  
      struct sockaddr_in srcAddr, dstAddr;
      srcAddr.sin_addr = _sock.addr;
      srcAddr.sin_port = _sock.port;
      dstAddr.sin_addr = _sock.peerAddr;
      dstAddr.sin_port = _sock.peerPort;
  
      sockDataHdr.srcAddr = srcAddr;
      sockDataHdr.dstAddr = dstAddr;
  
      return sockDataHdr;
  }
  
  int CSocket::send(const char * buf, size_t len, int flag)
  {
      log(TAG "%s(): \"%s\"\n", __func__, buf); 
      log(TAG "%s(): addr %s:%d\n", __func__, inet_ntoa(_sock.addr), ntohs(_sock.port));
      log(TAG "%s(): peer %s:%d\n", __func__, inet_ntoa(_sock.peerAddr), ntohs(_sock.peerPort));
      // todo: Send to ProtoSocket send message
      //   data format: ProtoSocket{type, {SockData, buf}}
      //              or: ProtoSocket{type, {left buf}}
      SockDataHdr sockDataHdr = makeDataHeader(len, flag);
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_SEND;
  
      char *pData = sockPkt.data;
  
      memcpy(pData, &sockDataHdr, sizeof(SockDataHdr));
      pData += sizeof(SockDataHdr);
  
      int bufLeft = cSHMDataSize - sizeof(SockDataHdr);
      int dataLeft = len;
      
      while (dataLeft > 0) {
          int dataLen;
  
          if (bufLeft <= 0) {         // re-point to buffer start
              bufLeft = cSHMDataSize;
              pData = sockPkt.data;
          }
  
          if (dataLeft <= bufLeft) {
              dataLen = dataLeft;
          }
          else {
              dataLen = bufLeft;
          }
  
          memcpy(pData, buf, dataLen);
  
          pData       += dataLen;
          dataLeft    -= dataLen;
          bufLeft     -= dataLen;
  
          int bytes = pData - sockPkt.data + sizeof(SockPktType);
          printf("will copy %d bytes.\n", bytes);
          memcpy(_pBlock->buf2, &sockPkt, bytes);
          kill(_protoPid, SIGUSR2);
      }
  
      int byteSend = waitForSuccess(SIGUSR2);
      printf("Send %d bytes.\n", byteSend);
  
      return byteSend;
  }
  
  int CSocket::recv(char * buf, size_t len, int flag)
  {
      log(TAG "%s(): addr %s:%d\n", __func__, inet_ntoa(_sock.addr), ntohs(_sock.port));
      log(TAG "%s(): peer %s:%d\n", __func__, inet_ntoa(_sock.peerAddr), ntohs(_sock.peerPort));
      // each recv() should return as soon as possible, if there is no data, -1 is returned
      SockDataHdr sockDataHdr = makeDataHeader(len, flag);
  
      SockPacket sockPkt;
      sockPkt.type = SOCK_RECV;
      memcpy(sockPkt.data, &sockDataHdr, sizeof(SockDataHdr));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(SockDataHdr));
      
      uint8_t leftChance = 3;
      kill(_protoPid, SIGUSR2);
  
      pause();
  
      // read data from ProtoSocket and set value-result parameters
      char *pData = _pBlock->buf1;
      SockDataHdr* rcvDataHdr = (SockDataHdr *)pData;
      //while (leftChance-- > 0) {
      while (true) {
          if (rcvDataHdr->len <= 0) {
              // try again if we still get chance
              //log(TAG "%s(): no data available, left try times=%d.\n", __func__, leftChance);
              log(TAG "%s(): try again\n", __func__);
              sleep(1);
              kill(_protoPid, SIGUSR2);
              pause();
          }
          else {
              break;
          }
      }
  
      if (leftChance <= 0 && rcvDataHdr->len <= 0) {
          log(TAG "%s(): return without data\n", __func__);
          return -1;
      }
  
      pData += sizeof(SockDataHdr);
  
      int dataLen = len;
      if (dataLen > rcvDataHdr->len) {
          dataLen = rcvDataHdr->len;
      }
      memcpy(buf, pData, dataLen);
      return dataLen;
  }
  
  int CSocket::listen(int backlog)
  {
      SockPacket sockPkt;
      sockPkt.type = SOCK_LISTEN;
  
      char *pData = sockPkt.data;
      memcpy(pData, &_sock, sizeof(_sock));
      pData += sizeof(_sock);
      memcpy(pData, &backlog, sizeof(int));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(_sock) + sizeof(int));
      kill(_protoPid, SIGUSR1);
  
      return waitForSuccess(SIGUSR1) - 1;
  }
  
  std::unique_ptr<CSocket> CSocket::accept(struct sockaddr * sockaddr, socklen_t * addrlen)
  {
      SockPacket sockPkt;
      sockPkt.type = SOCK_ACCEPT;
  
      memcpy(sockPkt.data, &_sock, sizeof(_sock));
      memcpy(_pBlock->buf2, &sockPkt, sizeof(SockPktType) + sizeof(Sock)); 
  
      kill(_protoPid, SIGUSR1);
  
      pause();
  
      Sock *sock = (Sock *)_pBlock->buf1; 
  
      std::unique_ptr<CSocket> pSock(new CSocket());
      pSock->_sock = *sock;
  
      struct sockaddr_in *fromAddr = (struct sockaddr_in *)sockaddr;
      fromAddr->sin_addr = sock->peerAddr;
      fromAddr->sin_port = sock->peerPort;
      fromAddr->sin_family = sock->family;
      memset(fromAddr->sin_zero, 0, sizeof(fromAddr->sin_zero));
  
      *addrlen = sizeof(struct sockaddr_in);
  
      return pSock;
  }
  
  #include "ProtoSocket.h"
  #include <unistd.h>
  #include <sys/stat.h>
  #include <sys/ipc.h>
  #include <sys/shm.h>
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include <signal.h>
  
  #include <algorithm>
  
  #include "UDP.h"
  #include "TCP.h"
  #include "Network.h"
  #include "Link.h"
  #include "Hardware.h"
  #include "Util.h"
  
  #define TAG "<CProtoSocket> "
  
  using std::string;
  
  int sig;            // signal received
  
  void handler0(int signo)
  {
      sig = signo;
      printf("Received signal INT.\n");
  }
  
  void handler1(int signo) 
  {
      sig = signo;
      printf("Received signal USR1.\n");
  }
  
  void handler2(int signo) 
  {
      sig = signo;
      printf("Received signal USR2.\n");
  }
  
  CProtoSocket::CProtoSocket()
  {
      log(TAG "%s(): sizeof(SockPktType)=%d.\n", __func__, sizeof(SockPktType));
      createSharedMem();
  }
  
  CProtoSocket::~CProtoSocket()
  {
      destroySharedMem();
      printf("CProtoSocket destructed.\n");
  }
  
  void CProtoSocket::createSharedMem()
  {
      key_t key;
  
      if ((key = ftok(cKeyPath, cKeyID)) == -1) {
          fprintf(stderr, "Failed ftok().\n");
      }
  
      if ((_shmid = shmget(key, cSHMSize, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR |
                      S_IRGRP | S_IWGRP |
                      S_IROTH | S_IWOTH)) == -1) {
          fprintf(stderr, "Failed shmget().\n");
          exit(EXIT_FAILURE);
      }
      else {
          printf("Created shared memory %d.\n", _shmid);
      }
  
      if ((_pBlock = (SharedBlock *)shmat(_shmid, 0, 0)) == (void *)-1) {
          fprintf(stderr, "Failed shmat().\n");
      }
      else {
          printf("pBlock: %p, pBlock->buf1: %p, pBlock->buf2: %p\n",
                  _pBlock, _pBlock->buf1, _pBlock->buf2);
      }
  }
  
  void CProtoSocket::destroySharedMem()
  {
      if (shmdt(_pBlock) == -1) {
          fprintf(stderr, "Failed shmdt().\n");
      }
  
      if (shmctl(_shmid, IPC_RMID, 0) == -1) {
          fprintf(stderr, "Failed shmctl().\n");
      }
  }
  
  void CProtoSocket::run()
  {
      // protocols init, must in order : top-to-down
      CTCP::instance()->init();
      CUDP::instance()->init();
      CNetwork::instance()->init();
      CLink::instance()->init();
      CHardware::instance()->init();
  
      // catch signals
      signal(SIGUSR1, handler1);
      signal(SIGUSR2, handler2);
      signal(SIGINT, handler0);
  
      printf("Protocol socket running...\n");
  
      while (true) {
          pause();
  
          if (sig == SIGUSR1 || sig == SIGUSR2) {
              handleSockRequest();
              // SIGUSR1 do command work,
              // SIGUSR2 do data work
          }
          else if (sig == SIGINT){
              break;
          }
          else {
              printf("Unknown signal: %d.\n", sig);
          }
  
          sig = 0;
          printf("Protocols alive...\n");
      }
  
      printf("Protocol socket exit...\n");
  }
  
  void CProtoSocket::handleSockRequest()
  {
      SockPacket *sockPkt;
  
      sockPkt = (SockPacket *)_pBlock->buf2;
      switch (sockPkt->type) {
          case SOCK_CREATE: 
              {
                  handleCreate(sockPkt); break;
              }
          case SOCK_BIND:
              {
                  handleBind(sockPkt); break;
              }
          case SOCK_SENDTO:
              {
                  handleSendTo(sockPkt); break;
              }
          case SOCK_SEND:
              {
                  handleSend(sockPkt); break;
              }
          case SOCK_RECVFROM:
              {
                  handleRecvFrom(sockPkt); break;
              }
          case SOCK_RECV:
              {
                  handleRecv(sockPkt); break;
              }
          case SOCK_CONNECT:
              {
                  handleConnect(sockPkt); break;
              }
          case SOCK_LISTEN:
              {
                  handleListen(sockPkt); break;
              }
          case SOCK_ACCEPT:
              {
                  handleAccept(sockPkt); break;
              }
          case SOCK_CLOSE:
              {
                  handleClose(sockPkt); break;
              }
          default:
              fprintf(stderr, "Unkonwn socket packet type: %d.\n", sockPkt->type);
              break;
      }
  
  }
  
  void CProtoSocket::handleCreate(SockPacket *sockPkt)
  {   
      Sock *sock;
      sock = (Sock *)sockPkt->data;
  
      printf("pid: %d, family: %d, type: %d, protocol: %d\n",
              sock->pid, sock->family, sock->type, sock->protocol);
      sock->state = SS_UNCONNECTED;
      InetSock sk{
          ._sock = *sock,
          .sk_state = CLOSED 
      };
      // save to socket pool
      _sockPool.emplace(sock->sockfd, sk);
  
      // write back sockfd
      memcpy(_pBlock->buf1, &sock->sockfd, sizeof(int));
  
      afterHandle(sock->pid, SIGUSR1, __func__);
   
  }
  
  void CProtoSocket::handleBind(SockPacket *sockPkt)
  {
      Sock *sock = (Sock *)sockPkt->data;
      InetSock &cached = _sockPool.at(sock->sockfd);
      cached.sk_addr = sock->addr;
      cached.sk_port = sock->port;
  
      int success = 1;
      memcpy(_pBlock->buf1, &success, sizeof(success));
  
      afterHandle(cached.sk_pid, SIGUSR1, __func__);
      //kill(cached.pid, SIGUSR1);
      //log(TAG "%s : kill signal SIGUSR1 to process %d.\n", __func__, cached.pid);
  }
  
  void CProtoSocket::handleSendTo(SockPacket *sockPkt)
  {
      SockDataHdr *sockDataHdr;
      sockDataHdr = (SockDataHdr *)sockPkt->data;
  
      struct sockaddr_in *dstAddr = (struct sockaddr_in *)&sockDataHdr->dstAddr;
      printf("socket: %d want to send %d bytes data to %s:%d.\n",
              sockDataHdr->sockfd, sockDataHdr->len,
              inet_ntoa(dstAddr->sin_addr), ntohs(dstAddr->sin_port));
  
      // get data to send
      char *pData = sockPkt->data;
      pData += sizeof(SockDataHdr);
  
      // ---- debug only
      char *buf = (char *)malloc(sockDataHdr->len + 1);
      memcpy(buf, pData, sockDataHdr->len);
      buf[sockDataHdr->len] = '\0';
      printf("Contents to send: %s.\n", buf);
      free(buf);
      // ---- /debug only
  
      packet_t pkt;
      pkt.buf = (unsigned char*)pData;
      pkt.size = sockDataHdr->len;
      pkt.daddr = dstAddr->sin_addr;
      pkt.dport = dstAddr->sin_port;
  
      // get this socket
      InetSock & sock = _sockPool.at(sockDataHdr->sockfd);
  
      // set local address as needed
      setLocalAddr(&sock);
  
      pkt.saddr = sock.sk_addr;
      pkt.sport = sock.sk_port;
  
      // call UDP::send()
      CUDP::instance()->send(&pkt);
      // 
      // notice, this code assume data will not overflow the buffer size
      // to handle the overflow situation, modify this code
      
      // notify send bytes
      memcpy(_pBlock->buf1, &sockDataHdr->len, sizeof(int));
  
      afterHandle(sock.sk_pid, SIGUSR2, __func__);
   
  }
  
  void CProtoSocket::handleRecvFrom(SockPacket *sockPkt)
  {
      SockDataHdr *dataHdr = (SockDataHdr *)sockPkt->data;
  
      log(TAG "socket %d wanna recvfrom max %d bytes data.\n", dataHdr->sockfd, dataHdr->len);
  
      // get this socket
      InetSock& sock = _sockPool.at(dataHdr->sockfd);
  
      // add pending recvfrom socket
      //_pendingSocks.emplace(dataHdr->sockfd, sock.port);
      _pendingSocks.emplace(&sock);
   
      log(TAG "%s : add penging socket %d:%d.\n", __func__, sock.sk_sockfd, ntohs(sock.sk_port));
  }
  
  void CProtoSocket::handleSend(SockPacket *sockPkt)
  {
      SockDataHdr *sockDataHdr;
      sockDataHdr = (SockDataHdr *)sockPkt->data;
  
      struct sockaddr_in *srcAddr = (struct sockaddr_in *)&sockDataHdr->srcAddr;
      struct sockaddr_in *dstAddr = (struct sockaddr_in *)&sockDataHdr->dstAddr;
  
      string key = CTCP::instance()->keyOf(srcAddr->sin_addr, srcAddr->sin_port, dstAddr->sin_addr, dstAddr->sin_port);
  
      // find connection first
      log(TAG "%s(): %s\n", __func__, key.c_str()); 
  
      ConnPMap::iterator it = _connPPool.find(key);
      if (it != _connPPool.end()) {
          // get data to send
          char *pData = sockPkt->data;
          pData += sizeof(SockDataHdr);
  
          // ---- debug only
          char *buf = (char *)malloc(sockDataHdr->len + 1);
          memcpy(buf, pData, sockDataHdr->len);
          buf[sockDataHdr->len] = '\0';
          log(TAG "%s() contents send: %s.\n", __func__, buf);
          free(buf);
          // ---- /debug only
  
          packet_t pkt;
          pkt.buf = (unsigned char*)pData;
          pkt.size = sockDataHdr->len;
          pkt.saddr = srcAddr->sin_addr;
          pkt.sport = srcAddr->sin_port;
          pkt.daddr = dstAddr->sin_addr;
          pkt.dport = dstAddr->sin_port;
  
          CTCP::instance()->send(&pkt);
          // notice, this code assume data will not overflow the buffer size
          // to handle the overflow situation, fix this code
          
          memcpy(_pBlock->buf1, &sockDataHdr->len, sizeof(int));
          afterHandle(it->second->ics_pid, SIGUSR2, __func__);
      }
      else {
          log(TAG "%s(): no connection found, report this error\n", __func__);
      }
  
  }
  
  void CProtoSocket::handleRecv(SockPacket *sockPkt)
  {
      SockDataHdr *dataHdr = (SockDataHdr *)sockPkt->data;
      struct sockaddr_in *srcAddr = (struct sockaddr_in *)&dataHdr->srcAddr;
      struct sockaddr_in *dstAddr = (struct sockaddr_in *)&dataHdr->dstAddr;
  
      string key = CTCP::instance()->keyOf(srcAddr->sin_addr, srcAddr->sin_port, dstAddr->sin_addr, dstAddr->sin_port);
  
      // find connection first
      log(TAG "%s(): %s\n", __func__, key.c_str()); 
  
      ConnPMap::iterator it = _connPPool.find(key);
  
      if (it == _connPPool.end()) {
          log(TAG "%s(): no connection found, report this error\n", __func__);
          return ;
      }
  
      SockDataHdr sdh = *dataHdr;
      sdh.srcAddr = dataHdr->dstAddr;
      sdh.dstAddr = dataHdr->srcAddr;
      sdh.flag = 0;
  
      InetConnSock *ics = it->second; 
  
      if (ics->recvQueue.empty()) {
          sdh.len = -1;
      }
      else {
          char *pData = _pBlock->buf1;
          pData += sizeof(SockDataHdr);
          // todo: copy recvQueue data to buffer
          int goalLen = dataHdr->len;
          int copiedLen = 0;
  
          PacketQueue & recvQueue = ics->recvQueue;
  
          while (copiedLen < goalLen) {
              std::shared_ptr<packet_t> &ppkt = recvQueue.front();
              int dataLen = ppkt->len;
              if (dataLen > goalLen - copiedLen) {
                  dataLen = goalLen - copiedLen;
              }
  
              memcpy(pData, ppkt->data, dataLen);
              pData += dataLen;
              copiedLen += dataLen;
  
              ppkt->pull(dataLen);
              if (ppkt->empty()) {
                  recvQueue.pop_front();
                  
                  if (recvQueue.empty()) 
                      break;
              }
          }
          sdh.len = copiedLen;
      }
      memcpy(_pBlock->buf1, &sdh, sizeof(SockDataHdr));
      afterHandle(ics->ics_pid, SIGUSR2, __func__);
  
      // todo: notify TCP we received data 
  }
  
  void CProtoSocket::handleClose(SockPacket *sockPkt)
  {
      Sock *sock = (Sock *)sockPkt->data;
      log(TAG "%s() : close socket %d, port %d\n", __func__, sock->sockfd, ntohs(sock->port));
  
      if (sock->type == SOCK_STREAM) {
          // need do 4wwh
          string name = CTCP::keyOf(sock->addr, sock->port, sock->peerAddr, sock->peerPort);
          ConnPMap::iterator it = _connPPool.find(name);
          if (it != _connPPool.end()) {
              if (it->second->_inetSock._sock.state == SS_DISCONNECTING) {
                  log(TAG "%s(): connection is closing...\n", __func__);
              }
              else {
                  it->second->_inetSock._sock.state = SS_DISCONNECTING;
                  CTCP::instance()->close(name);
              }
          }
          else {
              log(TAG "%s(): no connection find '%s'\n", __func__, name.c_str());
              afterHandle(0, sock->pid, SIGUSR1, __func__);
          }
      }
      else if (sock->type == SOCK_DGRAM) {
          _sockPool.erase(sock->sockfd);
          afterHandle(1, sock->pid, SIGUSR1, __func__);
      }
      else {
          log (TAG "%s(): unsupport sock type: %d\n", __func__, sock->type);
          afterHandle(0, sock->pid, SIGUSR1, __func__);
      }
  
  }
  
  void CProtoSocket::handleListen(SockPacket *sockPkt)
  {
      log(TAG "%s().\n", __func__);
      Sock *sock = (Sock *)sockPkt->data; 
      InetSock &cached = _sockPool.at(sock->sockfd);
  
      char *pData = sockPkt->data;
      pData += sizeof(Sock);
  
      int backlog = *(int *)pData;
      cached.backlog = backlog;
  
      cached.sk_state = LISTEN;
      cached._sock.state = SS_CONNECTING; // optional 
  
      CTCP::instance()->listen(&cached); 
  
      afterHandle(1, cached.sk_pid, SIGUSR1, __func__); 
  
  }
  
  void CProtoSocket::handleConnect(SockPacket *sockPkt)
  {
      Sock *sock = (Sock *)sockPkt->data;
  
      InetSock &cached = _sockPool.at(sock->sockfd);
      cached.sk_peerAddr = sock->peerAddr;
      cached.sk_peerPort = sock->peerPort;
  
      // set local address as needed
      setLocalAddr(&cached);
  
      int result = cached._sock.state;
  
      if (result == SS_UNCONNECTED) {
          cached._sock.state = SS_CONNECTING;
          CTCP::instance()->connect(&cached);
          // if connect successfully, connectFinished() is called
      }
      else {
          log(TAG "Not unconnected socket: %d.\n", result);
          memcpy(_pBlock->buf1, &result, sizeof(result));
          afterHandle(cached.sk_pid, SIGUSR1, __func__);
      }
  
  }
  
  void CProtoSocket::handleAccept(SockPacket *sockPkt)
  {
      log(TAG "%s().\n", __func__);
      Sock *sock = (Sock *)sockPkt->data;
      // when there is a connected connection, return it, otherwise, record an accept request 
      //
      // find a connection without sockfd assigned
      //
      ConnPMap::iterator it = std::find_if(_connPPool.begin(), _connPPool.end(), [=](const ConnPMap::value_type &pair){
                  InetConnSock *conn = pair.second;
                  return conn->ics_sockfd == 0 && conn->ics_port == sock->port; 
              });
  
      if (it != _connPPool.end()) {
          // find a connection, return it
          InetConnSock *ics = it->second;
          ics->ics_sockfd = selectFD();
  
          Sock *newSock = (Sock *)ics;
          memcpy(_pBlock->buf1, newSock, sizeof(Sock));
          afterHandle(newSock->pid, SIGUSR1, __func__);
      }
      else {
          // no available connection yet
          _pendingAccept.insert(sock->port);
      }
  
  }
  
  void CProtoSocket::connectFinished(string name, InetConnSock *ics)
  {
      log(TAG "%s(): %s.\n", __func__, name.c_str());
      ics->_inetSock._sock.state = SS_CONNECTED;
      _connPPool.emplace(name, ics); 
  
      // here, no notify the connected address, a data structure must be returned instead of
      // a single flag show failed or success
      memcpy(_pBlock->buf1, ics, sizeof(Sock));
  
      afterHandle(ics->ics_pid, SIGUSR1, __func__);
  }
  
  void CProtoSocket::accepted(std::string name, InetConnSock *ics)
  {
      log(TAG "%s(): %s.\n", __func__, name.c_str());
      ics->_inetSock._sock.state = SS_CONNECTED;
      auto pair = _connPPool.emplace(name, ics);
  
      std::set<uint16_t>::iterator it = _pendingAccept.find(ics->ics_port);
      if (it != _pendingAccept.end()) {
          ics->ics_sockfd = selectFD(); 
          memcpy(_pBlock->buf1, ics, sizeof(Sock));
  
          _pendingAccept.erase(ics->ics_port);
  
          afterHandle(ics->ics_pid, SIGUSR1, __func__);
      }
      else {
          log (TAG "%s(): no accept request at port %d\n", __func__, ics->ics_port);
      }
  }
  
  void CProtoSocket::closed(std::string name)
  {
      log(TAG "%s(): %s\n", __func__, name.c_str());
      // remove connection
      ConnPMap::iterator it = _connPPool.find(name);
      int result;
      uint32_t pid = it->second->ics_pid;
      if (it != _connPPool.end()) {
          _connPPool.erase(it);
          log(TAG "%s(): now there is %d connection\n", __func__, _connPPool.size());
          result = 1;
      }
      else {
          result = 0;
          log(TAG "%s(): connection not found\n", __func__);
      }
  
      log(TAG "%s(): now there is %d socket\n", __func__, _sockPool.size());
  
      afterHandle(result, pid, SIGUSR1, __func__);
  }
  
  uint16_t CProtoSocket::selectPort()
  {
      return 1314;
  }
  
  uint32_t CProtoSocket::selectFD()
  {
      return 15110;
  }
  
  
  void CProtoSocket::setLocalAddr(InetSock * sock)
  {
      // get source ip address if not bind yet, 
      // if has bound, port will not be 0
      if (sock->sk_port == 0) {           // not bind yet
          const Device *dev = CHardware::instance()->getDefaultDevice();
          sock->sk_addr = dev->ipAddr;
          sock->sk_port = htons(selectPort());
      } else {}
  
  }
  
  void CProtoSocket::bytesAvailable(InetConnSock *ics)
  {
      log (TAG "%s()\n", __func__);
  }
  
  void CProtoSocket::received(const packet_t *pkt)
  {
      log (TAG "Received %d bytes data.\n", pkt->len);
      log (TAG "_pendSocks: \n");
      for_each (_pendingSocks.cbegin(), _pendingSocks.cend(), [=](const InetSock *sock){
          log("pid: %d, sockfd: %d, port: %d\n", sock->sk_pid, sock->sk_sockfd, ntohs(sock->sk_port));
      });
      // find pending socket
      auto p = std::find_if(_pendingSocks.cbegin(), _pendingSocks.cend(),
                  [=](const InetSock* sock){
                      return (sock->sk_port == pkt->dport);
                  });
      if (p != _pendingSocks.cend()) {
          const InetSock* sock = *p;
  
          // todo: copy pkt data to shared memory
          SockDataHdr dataHdr;
          dataHdr.sockfd  = sock->sk_sockfd;
          dataHdr.len     = pkt->len;
  
          struct sockaddr_in srcAddr;
          srcAddr.sin_addr = pkt->saddr;
          srcAddr.sin_port = pkt->sport;
          srcAddr.sin_family = AF_INET;
  
          struct sockaddr_in dstAddr;
          dstAddr.sin_addr = pkt->daddr;
          dstAddr.sin_port = pkt->dport;
          dstAddr.sin_family = AF_INET;
  
          dataHdr.srcAddr = srcAddr;
          dataHdr.dstAddr = dstAddr;
  
          dataHdr.flag    = 0;
  
          char *pData = _pBlock->buf1;
          memcpy(pData, &dataHdr, sizeof(dataHdr));
          pData += sizeof(dataHdr);
  
          memcpy(pData, pkt->data, pkt->len);
          pData += pkt->len;
  
          _pendingSocks.erase(p);
  
          afterHandle(sock->sk_pid, SIGUSR2, __func__);
      }
      else {
          log(TAG "No pending socket port %d find.\n", ntohs(pkt->dport));
      }
  
  }
  
  void CProtoSocket::afterHandle(int success, int pid, int signo, const char * const funcName)
  {
      memcpy(_pBlock->buf1, &success, sizeof(success));
      afterHandle(pid, signo, funcName);
  }
  
  void CProtoSocket::afterHandle(int pid, int signo, const char *funcName)
  {
      usleep(100);            // VIP: wait CSocket enter pause() statement
      kill(pid, signo);
      //log(TAG "%s() : kill signal %d to process %d.\n", funcName, signo, pid);
  }
  
  #include "CheckSum.h"
  
  uint16_t cksum(const u_char *const buf, size_t size)
  {
      uint32_t sum;
      uint16_t *p = (uint16_t *)buf;
  
      sum = 0;
      while(size > 1) {
          sum += *p++;
          size -= 2;
      }
  
      // padding as needed
      if(size == 1) {
          sum += *((u_char *)p);
      }
  
      while(sum >> 16)
          sum = (sum & 0xFFFF) + (sum >> 16);
  
      return (uint16_t)((~sum) & 0xFFFF);
  }
